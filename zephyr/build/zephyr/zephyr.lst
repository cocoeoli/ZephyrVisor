
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section text:

0000000040000000 <__text_region_start>:
#define HEADER_FLAGS	(HEADER_PGSIZE << 1)

_ASM_FILE_PROLOGUE

SECTION_SUBSEC_FUNC(image_header,_image_header_section,_image_header)
	b	__start				// branch to kernel start
    40000000:	140003ff 	b	40000ffc <__reset>
	...
    40000010:	4005a708 	.word	0x4005a708
    40000014:	00000000 	.word	0x00000000
    40000018:	00000002 	.word	0x00000002
	...
    40000038:	644d5241 	.word	0x644d5241
    4000003c:	00000000 	.word	0x00000000

0000000040000040 <_vector_start>:
	...

0000000040000800 <_vector_table>:
	/* The whole table must be 2K aligned */
	.align 11

	/* Current EL with SP0 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000800:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000810:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000820:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000830:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000840:	927ff800 8b010000 d51bd060 9400085f     ........`..._...
	b	z_arm64_sync_exc
    40000850:	14000816 d503201f d503201f d503201f     ..... ... ... ..
    40000860:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000870:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000880:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000890:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400008a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400008b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400008c0:	927ff800 8b010000 d51bd060 9400083f     ........`...?...
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    400008d0:	140001ec d503201f d503201f d503201f     ..... ... ... ..
    400008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SP0 / FIQ */
	.align 7
	b 	.
    40000900:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000970:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000980:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000990:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400009a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400009b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400009c0:	927ff800 8b010000 d51bd060 940007ff     ........`.......
	b	z_arm64_serror
    400009d0:	140007e3 d503201f d503201f d503201f     ..... ... ... ..
    400009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000a20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000a30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000a40:	927ff800 8b010000 d51bd060 940007df     ........`.......
	b	z_arm64_sync_exc
    40000a50:	14000796 d503201f d503201f d503201f     ..... ... ... ..
    40000a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000aa0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000ab0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000ac0:	927ff800 8b010000 d51bd060 940007bf     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000ad0:	1400016c d503201f d503201f d503201f     l.... ... ... ..
    40000ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SPx / FIQ */
	.align 7
	b	.
    40000b00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000b80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000b90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ba0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000bb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000bc0:	927ff800 8b010000 d51bd060 9400077f     ........`.......
	b	z_arm64_serror
    40000bd0:	14000763 d503201f d503201f d503201f     c.... ... ... ..
    40000be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000c20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000c30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000c40:	927ff800 8b010000 d51bd060 9400075f     ........`..._...
	b	z_arm64_sync_exc
    40000c50:	14000716 d503201f d503201f d503201f     ..... ... ... ..
    40000c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ca0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000cb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000cc0:	927ff800 8b010000 d51bd060 9400073f     ........`...?...
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000cd0:	140000ec d503201f d503201f d503201f     ..... ... ... ..
    40000ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Lower EL using AArch64 / FIQ */
	.align 7
	b	.
    40000d00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000d80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000d90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000da0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000db0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000dc0:	927ff800 8b010000 d51bd060 940006ff     ........`.......
	b	z_arm64_serror
    40000dd0:	140006e3 d503201f d503201f d503201f     ..... ... ... ..
    40000de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / Synchronous */
	.align 7
	b	.
    40000e00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / IRQ */
	.align 7
	b	.
    40000e80:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / FIQ */
	.align 7
	b	.
    40000f00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / SError */
	.align 7
	b	.
    40000f80:	14000000                                ....

0000000040000f84 <_vector_end>:
    40000f84:	00000000 	udf	#0

0000000040000f88 <__reset_prep_c>:
 */

GTEXT(__reset_prep_c)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset_prep_c)
	/* return address: x23 */
	mov	x23, x30
    40000f88:	aa1e03f7 	mov	x23, x30

	switch_el x0, 3f, 2f, 1f
    40000f8c:	d5384240 	mrs	x0, currentel
    40000f90:	f100301f 	cmp	x0, #0xc
    40000f94:	540000a0 	b.eq	40000fa8 <__reset_prep_c+0x20>  // b.none
    40000f98:	f100201f 	cmp	x0, #0x8
    40000f9c:	54000100 	b.eq	40000fbc <__reset_prep_c+0x34>  // b.none
    40000fa0:	f100101f 	cmp	x0, #0x4
    40000fa4:	54000180 	b.eq	40000fd4 <__reset_prep_c+0x4c>  // b.none
3:
	/* Reinitialize SCTLR from scratch in EL3 */
	ldr	w0, =(SCTLR_EL3_RES1 | SCTLR_I_BIT | SCTLR_SA_BIT)
    40000fa8:	18000600 	ldr	w0, 40001068 <switch_el+0x58>
	msr	sctlr_el3, x0
    40000fac:	d51e1000 	msr	sctlr_el3, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el3_plat_prep_c
    40000fb0:	940005bb 	bl	4000269c <z_arm64_el3_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    40000fb4:	d51c4118 	msr	sp_el1, x24

	b	out
    40000fb8:	1400000d 	b	40000fec <out>
2:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el2
    40000fbc:	d53c1000 	mrs	x0, sctlr_el2
	bic	x0, x0, SCTLR_A_BIT
    40000fc0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el2, x0
    40000fc4:	d51c1000 	msr	sctlr_el2, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el2_plat_prep_c
    40000fc8:	940005b6 	bl	400026a0 <z_arm64_el2_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    40000fcc:	d51c4118 	msr	sp_el1, x24

	b	out
    40000fd0:	14000007 	b	40000fec <out>
1:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el1
    40000fd4:	d5381000 	mrs	x0, sctlr_el1
	bic	x0, x0, SCTLR_A_BIT
    40000fd8:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el1, x0
    40000fdc:	d5181000 	msr	sctlr_el1, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el1_plat_prep_c
    40000fe0:	940005b1 	bl	400026a4 <z_arm64_el1_plat_prep_c>

	/* Set SP_EL1. We cannot use sp_el1 at EL1 */
	msr     SPSel, #1
    40000fe4:	d50041bf 	msr	spsel, #0x1
	mov     sp, x24
    40000fe8:	9100031f 	mov	sp, x24

0000000040000fec <out>:
out:
	isb
    40000fec:	d5033fdf 	isb

	/* Select SP_EL0 */
	msr	SPSel, #0
    40000ff0:	d50040bf 	msr	spsel, #0x0

	/* Initialize stack */
	mov	sp, x24
    40000ff4:	9100031f 	mov	sp, x24

	ret	x23
    40000ff8:	d65f02e0 	ret	x23

0000000040000ffc <__reset>:
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset)

GTEXT(__start)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)
	/* Mask all exceptions */
	msr	DAIFSet, #0xf
    40000ffc:	d5034fdf 	msr	daifset, #0xf
primary_core:
	/* advertise ourself */
	str	x1, [x0, #BOOT_PARAM_MPID_OFFSET]
#endif
	/* load primary stack and entry point */
	ldr	x24, =(z_interrupt_stacks + CONFIG_ISR_STACK_SIZE)
    40001000:	58000398 	ldr	x24, 40001070 <switch_el+0x60>
	ldr	x25, =z_arm64_prep_c
    40001004:	580003b9 	ldr	x25, 40001078 <switch_el+0x68>
2:
	/* Prepare for calling C code */
	bl	__reset_prep_c
    40001008:	97ffffe0 	bl	40000f88 <__reset_prep_c>

	/* Platform hook for highest EL */
	bl	z_arm64_el_highest_init
    4000100c:	940005b4 	bl	400026dc <z_arm64_el_highest_init>

0000000040001010 <switch_el>:

switch_el:
	switch_el x0, 3f, 2f, 1f
    40001010:	d5384240 	mrs	x0, currentel
    40001014:	f100301f 	cmp	x0, #0xc
    40001018:	540000a0 	b.eq	4000102c <switch_el+0x1c>  // b.none
    4000101c:	f100201f 	cmp	x0, #0x8
    40001020:	540000e0 	b.eq	4000103c <switch_el+0x2c>  // b.none
    40001024:	f100101f 	cmp	x0, #0x4
    40001028:	54000180 	b.eq	40001058 <switch_el+0x48>  // b.none
3:
	/* EL3 init */
	bl	z_arm64_el3_init
    4000102c:	940005d1 	bl	40002770 <z_arm64_el3_init>

	/* Get next EL */
	adr	x0, switch_el
    40001030:	10ffff00 	adr	x0, 40001010 <switch_el>
	bl	z_arm64_el3_get_next_el
    40001034:	940005f8 	bl	40002814 <z_arm64_el3_get_next_el>
	eret
    40001038:	d69f03e0 	eret

2:
	/* EL2 init */
	bl	z_arm64_el2_init
    4000103c:	940005ba 	bl	40002724 <z_arm64_el2_init>

	/* Move to EL1 with all exceptions masked */
	mov_imm	x0, (SPSR_DAIF_MASK | SPSR_MODE_EL1T)
    40001040:	d2a00000 	movz	x0, #0x0, lsl #16
    40001044:	f2807880 	movk	x0, #0x3c4
	msr	spsr_el2, x0
    40001048:	d51c4000 	msr	spsr_el2, x0

	adr	x0, 1f
    4000104c:	10000060 	adr	x0, 40001058 <switch_el+0x48>
	msr	elr_el2, x0
    40001050:	d51c4020 	msr	elr_el2, x0
	eret
    40001054:	d69f03e0 	eret

1:
	/* EL1 init */
	bl	z_arm64_el1_init
    40001058:	940005dc 	bl	400027c8 <z_arm64_el1_init>

	/* Enable SError interrupts */
	msr	DAIFClr, #(DAIFCLR_ABT_BIT)
    4000105c:	d50344ff 	msr	daifclr, #0x4
	isb
    40001060:	d5033fdf 	isb

	ret	x25  /* either z_arm64_prep_c or z_arm64_secondary_prep_c */
    40001064:	d65f0320 	ret	x25
    40001068:	30c51838 	.word	0x30c51838
    4000106c:	00000000 	udf	#0
    40001070:	4005a6b0 	.word	0x4005a6b0
    40001074:	00000000 	.word	0x00000000
    40001078:	40002658 	.word	0x40002658
    4000107c:	00000000 	.word	0x00000000

0000000040001080 <_isr_wrapper>:

GTEXT(_isr_wrapper)
SECTION_FUNC(TEXT, _isr_wrapper)

	/* ++(_kernel->nested) to be checked by arch_is_in_isr() */
	inc_nest_counter x0, x1
    40001080:	d53bd060 	mrs	x0, tpidrro_el0
    40001084:	927db000 	and	x0, x0, #0xfffffffffff8
    40001088:	f9400001 	ldr	x1, [x0]
    4000108c:	91000421 	add	x1, x1, #0x1
    40001090:	f9000001 	str	x1, [x0]
	bl	sys_trace_isr_enter
#endif

	/* Get active IRQ number from the interrupt controller */
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_get_active
    40001094:	94000927 	bl	40003530 <arm_gic_get_active>
#if CONFIG_GIC_VER >= 3
	/*
	 * Ignore Special INTIDs 1020..1023 see 2.2.1 of Arm Generic Interrupt Controller
	 * Architecture Specification GIC architecture version 3 and version 4
	 */
	cmp	x0, 1019
    40001098:	f10fec1f 	cmp	x0, #0x3fb
	b.le	oob
    4000109c:	5400008d 	b.le	400010ac <oob>
	cmp	x0, 1023
    400010a0:	f10ffc1f 	cmp	x0, #0x3ff
	b.gt	oob
    400010a4:	5400004c 	b.gt	400010ac <oob>
	b	spurious_continue
    400010a8:	1400000c 	b	400010d8 <spurious_continue>

00000000400010ac <oob>:

oob:
#endif
	/* IRQ out of bounds */
	mov	x1, #(CONFIG_NUM_IRQS - 1)
    400010ac:	d2801b61 	mov	x1, #0xdb                  	// #219
	cmp	x0, x1
    400010b0:	eb01001f 	cmp	x0, x1
	b.hi	spurious_continue
    400010b4:	54000128 	b.hi	400010d8 <spurious_continue>  // b.pmore

	stp	x0, xzr, [sp, #-16]!
    400010b8:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* Retrieve the interrupt service routine */
	ldr	x1, =_sw_isr_table
    400010bc:	580002e1 	ldr	x1, 40001118 <exit+0x8>
	add	x1, x1, x0, lsl #4	/* table is 16-byte wide */
    400010c0:	8b001021 	add	x1, x1, x0, lsl #4
	ldp	x0, x3, [x1] /* arg in x0, ISR in x3 */
    400010c4:	a9400c20 	ldp	x0, x3, [x1]

	/*
	 * Call the ISR. Unmask and mask again the IRQs to support nested
	 * exception handlers
	 */
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    400010c8:	d50342ff 	msr	daifclr, #0x2
	blr	x3
    400010cc:	d63f0060 	blr	x3
	msr	daifset, #(DAIFSET_IRQ_BIT)
    400010d0:	d50342df 	msr	daifset, #0x2

	/* Signal end-of-interrupt */
	ldp	x0, xzr, [sp], #16
    400010d4:	a8c17fe0 	ldp	x0, xzr, [sp], #16

00000000400010d8 <spurious_continue>:

spurious_continue:
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_eoi
    400010d8:	94000918 	bl	40003538 <arm_gic_eoi>
#ifdef CONFIG_TRACING
	bl	sys_trace_isr_exit
#endif

	/* if (--(_kernel->nested) != 0) exit */
	dec_nest_counter x0, x1
    400010dc:	d53bd060 	mrs	x0, tpidrro_el0
    400010e0:	927db000 	and	x0, x0, #0xfffffffffff8
    400010e4:	f9400001 	ldr	x1, [x0]
    400010e8:	f1000421 	subs	x1, x1, #0x1
    400010ec:	f9000001 	str	x1, [x0]

	bne	exit
    400010f0:	54000101 	b.ne	40001110 <exit>  // b.any
	 * - The next thread to schedule in x0
	 * - The current thread in x1. This value is returned using the
	 *   **old_thread parameter, so we need to make space on the stack for
	 *   that.
	 */
	sub	sp, sp, #16
    400010f4:	d10043ff 	sub	sp, sp, #0x10
	mov	x0, sp
    400010f8:	910003e0 	mov	x0, sp
	bl	z_arch_get_next_switch_handle
    400010fc:	94000613 	bl	40002948 <z_arch_get_next_switch_handle>
	ldp	x1, xzr, [sp], #16
    40001100:	a8c17fe1 	ldp	x1, xzr, [sp], #16

	/*
	 * x0: 1st thread in the ready queue
	 * x1: _current thread
	 */
	cmp	x0, x1
    40001104:	eb01001f 	cmp	x0, x1
	beq	exit
    40001108:	54000040 	b.eq	40001110 <exit>  // b.none

	/* Switch thread */
	bl	z_arm64_context_switch
    4000110c:	940005cd 	bl	40002840 <z_arm64_context_switch>

0000000040001110 <exit>:

exit:
#ifdef CONFIG_STACK_SENTINEL
	bl	z_check_stack_sentinel
#endif
	b	z_arm64_exit_exc
    40001110:	14000617 	b	4000296c <z_arm64_exit_exc>
    40001114:	00000000 	udf	#0
    40001118:	400050a0 	.word	0x400050a0
    4000111c:	00000000 	.word	0x00000000

0000000040001120 <_OffsetAbsSyms>:
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a4, a4_a5);
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a6, a6_a7);

#endif /* CONFIG_HAS_ARM_SMCCC */

GEN_ABS_SYM_END
    40001120:	d65f03c0 	ret

0000000040001124 <main>:
/*
 * #include <lib/util/getopt/getopt.h>
 */
/*#include <unistd.h>*/

int main(int argc, char **argv){
    40001124:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   printk("Hello world!\n");
    40001128:	b0000020 	adrp	x0, 40006000 <levels.0+0x10>
    4000112c:	91027000 	add	x0, x0, #0x9c
int main(int argc, char **argv){
    40001130:	910003fd 	mov	x29, sp
   printk("Hello world!\n");
    40001134:	9400001f 	bl	400011b0 <printk>
   return 0;
}
    40001138:	52800000 	mov	w0, #0x0                   	// #0
    4000113c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001140:	d65f03c0 	ret

0000000040001144 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    40001144:	52800000 	mov	w0, #0x0                   	// #0
    40001148:	d65f03c0 	ret

000000004000114c <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    4000114c:	b9400022 	ldr	w2, [x1]
    40001150:	11000442 	add	w2, w2, #0x1
    40001154:	b9000022 	str	w2, [x1]
	return _char_out(c);
    40001158:	b00002c1 	adrp	x1, 4005a000 <z_interrupt_stacks+0x950>
    4000115c:	f9435821 	ldr	x1, [x1, #1712]
    40001160:	aa0103f0 	mov	x16, x1
    40001164:	d61f0200 	br	x16

0000000040001168 <__printk_hook_install>:
	_char_out = fn;
    40001168:	b00002c1 	adrp	x1, 4005a000 <z_interrupt_stacks+0x950>
    4000116c:	f9035820 	str	x0, [x1, #1712]
}
    40001170:	d65f03c0 	ret

0000000040001174 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    40001174:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001178:	910003fd 	mov	x29, sp
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    4000117c:	a9400c22 	ldp	x2, x3, [x1]
    40001180:	a9010fe2 	stp	x2, x3, [sp, #16]
    40001184:	a9410c22 	ldp	x2, x3, [x1, #16]
    40001188:	9100e3e1 	add	x1, sp, #0x38
    4000118c:	a9020fe2 	stp	x2, x3, [sp, #32]
    40001190:	910043e3 	add	x3, sp, #0x10
    40001194:	aa0003e2 	mov	x2, x0
    40001198:	90000000 	adrp	x0, 40001000 <__reset+0x4>
    4000119c:	91053000 	add	x0, x0, #0x14c
	struct out_context ctx = { 0 };
    400011a0:	b9003bff 	str	wzr, [sp, #56]
	cbvprintf(char_out, &ctx, fmt, ap);
    400011a4:	94000087 	bl	400013c0 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    400011a8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400011ac:	d65f03c0 	ret

00000000400011b0 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
    400011b0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    400011b4:	910003fd 	mov	x29, sp
    400011b8:	a90d8be1 	stp	x1, x2, [sp, #216]
	va_list ap;

	va_start(ap, fmt);
    400011bc:	910443e1 	add	x1, sp, #0x110
    400011c0:	a90307e1 	stp	x1, x1, [sp, #48]
    400011c4:	910343e1 	add	x1, sp, #0xd0
    400011c8:	f90023e1 	str	x1, [sp, #64]
    400011cc:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    400011d0:	b9004be1 	str	w1, [sp, #72]
    400011d4:	12800fe1 	mov	w1, #0xffffff80            	// #-128
    400011d8:	b9004fe1 	str	w1, [sp, #76]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    400011dc:	910043e1 	add	x1, sp, #0x10
{
    400011e0:	a90e93e3 	stp	x3, x4, [sp, #232]
		vprintk(fmt, ap);
    400011e4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400011e8:	a9010fe2 	stp	x2, x3, [sp, #16]
    400011ec:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400011f0:	a9020fe2 	stp	x2, x3, [sp, #32]
{
    400011f4:	3d8017e0 	str	q0, [sp, #80]
    400011f8:	3d801be1 	str	q1, [sp, #96]
    400011fc:	3d801fe2 	str	q2, [sp, #112]
    40001200:	3d8023e3 	str	q3, [sp, #128]
    40001204:	3d8027e4 	str	q4, [sp, #144]
    40001208:	3d802be5 	str	q5, [sp, #160]
    4000120c:	3d802fe6 	str	q6, [sp, #176]
    40001210:	3d8033e7 	str	q7, [sp, #192]
    40001214:	a90f9be5 	stp	x5, x6, [sp, #248]
    40001218:	f90087e7 	str	x7, [sp, #264]
		vprintk(fmt, ap);
    4000121c:	97ffffd6 	bl	40001174 <vprintk>
	}
	va_end(ap);
}
    40001220:	a8d17bfd 	ldp	x29, x30, [sp], #272
    40001224:	d65f03c0 	ret

0000000040001228 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    40001228:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000122c:	aa0003e4 	mov	x4, x0
    40001230:	aa0103e0 	mov	x0, x1
    40001234:	910003fd 	mov	x29, sp
    40001238:	aa0203e1 	mov	x1, x2
    4000123c:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    40001240:	d63f0080 	blr	x4
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    40001244:	94000cf4 	bl	40004614 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    40001248:	94000d31 	bl	4000470c <z_impl_k_thread_abort>

000000004000124c <_get_digit>:

/* Extract the next decimal character in the converted representation of a
 * fractional component.
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
    4000124c:	aa0003e3 	mov	x3, x0
	char rval;

	if (*digit_count > 0) {
    40001250:	b9400020 	ldr	w0, [x1]
    40001254:	7100001f 	cmp	w0, #0x0
    40001258:	5400016d 	b.le	40001284 <_get_digit+0x38>
		--*digit_count;
    4000125c:	51000400 	sub	w0, w0, #0x1
    40001260:	b9000020 	str	w0, [x1]
		*fr *= 10U;
    40001264:	f9400061 	ldr	x1, [x3]
    40001268:	d2800140 	mov	x0, #0xa                   	// #10
    4000126c:	9b007c21 	mul	x1, x1, x0
		rval = ((*fr >> 60) & 0xF) + '0';
    40001270:	d37cfc22 	lsr	x2, x1, #60
		*fr &= (BIT64(60) - 1U);
    40001274:	9240ec21 	and	x1, x1, #0xfffffffffffffff
		rval = ((*fr >> 60) & 0xF) + '0';
    40001278:	1100c040 	add	w0, w2, #0x30
		*fr &= (BIT64(60) - 1U);
    4000127c:	f9000061 	str	x1, [x3]
	} else {
		rval = '0';
	}

	return rval;
}
    40001280:	d65f03c0 	ret
		rval = '0';
    40001284:	52800600 	mov	w0, #0x30                  	// #48
    40001288:	17fffffe 	b	40001280 <_get_digit+0x34>

000000004000128c <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    4000128c:	aa0003e5 	mov	x5, x0
    40001290:	aa0303e0 	mov	x0, x3
	bool upcase = isupper((int)conv->specifier);
    40001294:	39400c23 	ldrb	w3, [x1, #3]
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40001298:	51010468 	sub	w8, w3, #0x41
	switch (specifier) {
    4000129c:	7101bc7f 	cmp	w3, #0x6f
    400012a0:	54000380 	b.eq	40001310 <encode_uint+0x84>  // b.none
    400012a4:	54000308 	b.hi	40001304 <encode_uint+0x78>  // b.pmore
		return 16;
    400012a8:	7101607f 	cmp	w3, #0x58
    400012ac:	d2800144 	mov	x4, #0xa                   	// #10
    400012b0:	d2800203 	mov	x3, #0x10                  	// #16
    400012b4:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    400012b8:	9ac408a7 	udiv	x7, x5, x4
    400012bc:	9b0494e6 	msub	x6, x7, x4, x5

		*--bp = (lsv <= 9) ? ('0' + lsv)
    400012c0:	12001cc3 	and	w3, w6, #0xff
    400012c4:	f10024df 	cmp	x6, #0x9
    400012c8:	540002c8 	b.hi	40001320 <encode_uint+0x94>  // b.pmore
    400012cc:	1100c063 	add	w3, w3, #0x30
    400012d0:	12001c63 	and	w3, w3, #0xff
    400012d4:	381ffc03 	strb	w3, [x0, #-1]!
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
	} while ((value != 0) && (bps < bp));
    400012d8:	eb0400bf 	cmp	x5, x4
    400012dc:	fa422000 	ccmp	x0, x2, #0x0, cs  // cs = hs, nlast
    400012e0:	540001c8 	b.hi	40001318 <encode_uint+0x8c>  // b.pmore

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    400012e4:	79400022 	ldrh	w2, [x1]
    400012e8:	362800c2 	tbz	w2, #5, 40001300 <encode_uint+0x74>
		if (radix == 8) {
    400012ec:	f100209f 	cmp	x4, #0x8
    400012f0:	54000261 	b.ne	4000133c <encode_uint+0xb0>  // b.any
			conv->altform_0 = true;
    400012f4:	39400822 	ldrb	w2, [x1, #2]
    400012f8:	321d0042 	orr	w2, w2, #0x8
		} else if (radix == 16) {
			conv->altform_0c = true;
    400012fc:	39000822 	strb	w2, [x1, #2]
			;
		}
	}

	return bp;
}
    40001300:	d65f03c0 	ret
	switch (specifier) {
    40001304:	121c7863 	and	w3, w3, #0xfffffff7
		return 16;
    40001308:	7101c07f 	cmp	w3, #0x70
    4000130c:	17ffffe8 	b	400012ac <encode_uint+0x20>
	switch (specifier) {
    40001310:	d2800104 	mov	x4, #0x8                   	// #8
	char *bp = bps + (bpe - bps);
    40001314:	17ffffe9 	b	400012b8 <encode_uint+0x2c>
		value /= radix;
    40001318:	aa0703e5 	mov	x5, x7
    4000131c:	17ffffe7 	b	400012b8 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    40001320:	1100dc66 	add	w6, w3, #0x37
    40001324:	11015c63 	add	w3, w3, #0x57
    40001328:	12001cc6 	and	w6, w6, #0xff
    4000132c:	12001c63 	and	w3, w3, #0xff
    40001330:	7100651f 	cmp	w8, #0x19
    40001334:	1a868063 	csel	w3, w3, w6, hi  // hi = pmore
    40001338:	17ffffe7 	b	400012d4 <encode_uint+0x48>
		} else if (radix == 16) {
    4000133c:	f100409f 	cmp	x4, #0x10
    40001340:	54fffe01 	b.ne	40001300 <encode_uint+0x74>  // b.any
			conv->altform_0c = true;
    40001344:	39400822 	ldrb	w2, [x1, #2]
    40001348:	321c0042 	orr	w2, w2, #0x10
    4000134c:	17ffffec 	b	400012fc <encode_uint+0x70>

0000000040001350 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    40001350:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001354:	910003fd 	mov	x29, sp
    40001358:	a90153f3 	stp	x19, x20, [sp, #16]
    4000135c:	aa0203f4 	mov	x20, x2
	size_t count = 0;
    40001360:	d2800013 	mov	x19, #0x0                   	// #0
{
    40001364:	a9025bf5 	stp	x21, x22, [sp, #32]
    40001368:	aa0003f6 	mov	x22, x0
    4000136c:	aa0303f5 	mov	x21, x3
    40001370:	f9001bf7 	str	x23, [sp, #48]
    40001374:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    40001378:	8b130280 	add	x0, x20, x19
    4000137c:	eb0002bf 	cmp	x21, x0
    40001380:	54000148 	b.hi	400013a8 <outs+0x58>  // b.pmore
    40001384:	b40000f5 	cbz	x21, 400013a0 <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
    40001388:	2a1303e0 	mov	w0, w19
}
    4000138c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001390:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001394:	f9401bf7 	ldr	x23, [sp, #48]
    40001398:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000139c:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    400013a0:	38736a80 	ldrb	w0, [x20, x19]
    400013a4:	34ffff20 	cbz	w0, 40001388 <outs+0x38>
		int rc = out((int)*sp++, ctx);
    400013a8:	38736a80 	ldrb	w0, [x20, x19]
    400013ac:	aa1703e1 	mov	x1, x23
    400013b0:	d63f02c0 	blr	x22
		if (rc < 0) {
    400013b4:	37fffec0 	tbnz	w0, #31, 4000138c <outs+0x3c>
		++count;
    400013b8:	91000673 	add	x19, x19, #0x1
    400013bc:	17ffffef 	b	40001378 <outs+0x28>

00000000400013c0 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    400013c0:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    400013c4:	910003fd 	mov	x29, sp
    400013c8:	a90153f3 	stp	x19, x20, [sp, #16]
    400013cc:	aa0003f4 	mov	x20, x0
    400013d0:	a90363f7 	stp	x23, x24, [sp, #48]
    400013d4:	a9406073 	ldp	x19, x24, [x3]
    400013d8:	a90573fb 	stp	x27, x28, [sp, #80]
    400013dc:	b940187c 	ldr	w28, [x3, #24]
    400013e0:	f9400860 	ldr	x0, [x3, #16]
    400013e4:	a9025bf5 	stp	x21, x22, [sp, #32]
    400013e8:	aa0103f5 	mov	x21, x1
    400013ec:	f90037e0 	str	x0, [sp, #104]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    400013f0:	d280001b 	mov	x27, #0x0                   	// #0
    400013f4:	b9401c60 	ldr	w0, [x3, #28]
{
    400013f8:	a9046bf9 	stp	x25, x26, [sp, #64]
    400013fc:	b9007be0 	str	w0, [sp, #120]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    40001400:	39400040 	ldrb	w0, [x2]
    40001404:	35000060 	cbnz	w0, 40001410 <cbvprintf+0x50>
			OUTC(' ');
			--width;
		}
	}

	return count;
    40001408:	2a1b03e0 	mov	w0, w27
    4000140c:	14000425 	b	400024a0 <cbvprintf+0x10e0>
			OUTC(*fp++);
    40001410:	91000456 	add	x22, x2, #0x1
		if (*fp != '%') {
    40001414:	7100941f 	cmp	w0, #0x25
    40001418:	540000c0 	b.eq	40001430 <cbvprintf+0x70>  // b.none
			OUTC(*fp++);
    4000141c:	aa1503e1 	mov	x1, x21
			OUTC('%');
    40001420:	d63f0280 	blr	x20
    40001424:	37f883e0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40001428:	9100077b 	add	x27, x27, #0x1
		if (bps == NULL) {
    4000142c:	14000195 	b	40001a80 <cbvprintf+0x6c0>
	if (*sp == '%') {
    40001430:	39400440 	ldrb	w0, [x2, #1]
		} state = {
    40001434:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	if (*sp == '%') {
    40001438:	7100941f 	cmp	w0, #0x25
		} state = {
    4000143c:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	if (*sp == '%') {
    40001440:	540006a1 	b.ne	40001514 <cbvprintf+0x154>  // b.any
		conv->specifier = *sp++;
    40001444:	91000856 	add	x22, x2, #0x2
    40001448:	39030fe0 	strb	w0, [sp, #195]
		if (conv->width_star) {
    4000144c:	794183e0 	ldrh	w0, [sp, #192]
    40001450:	36402900 	tbz	w0, #8, 40001970 <cbvprintf+0x5b0>
			width = va_arg(ap, int);
    40001454:	37f8279c 	tbnz	w28, #31, 40001944 <cbvprintf+0x584>
    40001458:	91002e61 	add	x1, x19, #0xb
    4000145c:	aa1303e0 	mov	x0, x19
    40001460:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001464:	b9400017 	ldr	w23, [x0]
			if (width < 0) {
    40001468:	36f800b7 	tbz	w23, #31, 4000147c <cbvprintf+0xbc>
				conv->flag_dash = true;
    4000146c:	794183e0 	ldrh	w0, [sp, #192]
				width = -width;
    40001470:	4b1703f7 	neg	w23, w23
				conv->flag_dash = true;
    40001474:	321e0000 	orr	w0, w0, #0x4
    40001478:	790183e0 	strh	w0, [sp, #192]
		if (conv->prec_star) {
    4000147c:	794183e0 	ldrh	w0, [sp, #192]
    40001480:	36502960 	tbz	w0, #10, 400019ac <cbvprintf+0x5ec>
			int arg = va_arg(ap, int);
    40001484:	37f827fc 	tbnz	w28, #31, 40001980 <cbvprintf+0x5c0>
    40001488:	91002e61 	add	x1, x19, #0xb
    4000148c:	aa1303e0 	mov	x0, x19
    40001490:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001494:	b9400009 	ldr	w9, [x0]
			if (arg < 0) {
    40001498:	36f800a9 	tbz	w9, #31, 400014ac <cbvprintf+0xec>
				conv->prec_present = false;
    4000149c:	794183e0 	ldrh	w0, [sp, #192]
		int precision = -1;
    400014a0:	12800009 	mov	w9, #0xffffffff            	// #-1
				conv->prec_present = false;
    400014a4:	12167800 	and	w0, w0, #0xfffffdff
    400014a8:	790183e0 	strh	w0, [sp, #192]
		    && (conv->specifier_cat == SPECIFIER_FP)
    400014ac:	39430be0 	ldrb	w0, [sp, #194]
		conv->pad0_value = 0;
    400014b0:	f80c43ff 	stur	xzr, [sp, #196]
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    400014b4:	12000800 	and	w0, w0, #0x7
    400014b8:	7100101f 	cmp	w0, #0x4
    400014bc:	f94063e3 	ldr	x3, [sp, #192]
    400014c0:	54000101 	b.ne	400014e0 <cbvprintf+0x120>  // b.any
		    && !conv->prec_present) {
    400014c4:	7217007f 	tst	w3, #0x200
    400014c8:	540000c1 	b.ne	400014e0 <cbvprintf+0x120>  // b.any
			if (conv->specifier_a) {
    400014cc:	79c183e0 	ldrsh	w0, [sp, #192]
				precision = 6;
    400014d0:	528001a9 	mov	w9, #0xd                   	// #13
    400014d4:	7100001f 	cmp	w0, #0x0
    400014d8:	528000c0 	mov	w0, #0x6                   	// #6
    400014dc:	1a80b129 	csel	w9, w9, w0, lt  // lt = tstop
		enum specifier_cat_enum specifier_cat
    400014e0:	53104860 	ubfx	w0, w3, #16, #3
			= (enum length_mod_enum)conv->length_mod;
    400014e4:	530b3861 	ubfx	w1, w3, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
    400014e8:	7100041f 	cmp	w0, #0x1
    400014ec:	54002ce1 	b.ne	40001a88 <cbvprintf+0x6c8>  // b.any
			switch (length_mod) {
    400014f0:	51000c24 	sub	w4, w1, #0x3
    400014f4:	7100109f 	cmp	w4, #0x4
    400014f8:	54002628 	b.hi	400019bc <cbvprintf+0x5fc>  // b.pmore
    400014fc:	b0000020 	adrp	x0, 40006000 <levels.0+0x10>
    40001500:	91006000 	add	x0, x0, #0x18
    40001504:	78645800 	ldrh	w0, [x0, w4, uxtw #1]
    40001508:	10000064 	adr	x4, 40001514 <cbvprintf+0x154>
    4000150c:	8b20a880 	add	x0, x4, w0, sxth #2
    40001510:	d61f0000 	br	x0
    40001514:	52800003 	mov	w3, #0x0                   	// #0
    40001518:	52800005 	mov	w5, #0x0                   	// #0
    4000151c:	52800004 	mov	w4, #0x0                   	// #0
    40001520:	52800006 	mov	w6, #0x0                   	// #0
    40001524:	52800001 	mov	w1, #0x0                   	// #0
		switch (*sp) {
    40001528:	394002c0 	ldrb	w0, [x22]
    4000152c:	7100ac1f 	cmp	w0, #0x2b
    40001530:	540009a0 	b.eq	40001664 <cbvprintf+0x2a4>  // b.none
    40001534:	540008c8 	b.hi	4000164c <cbvprintf+0x28c>  // b.pmore
    40001538:	7100801f 	cmp	w0, #0x20
    4000153c:	540009a0 	b.eq	40001670 <cbvprintf+0x2b0>  // b.none
    40001540:	71008c1f 	cmp	w0, #0x23
    40001544:	540009a0 	b.eq	40001678 <cbvprintf+0x2b8>  // b.none
    40001548:	34000081 	cbz	w1, 40001558 <cbvprintf+0x198>
    4000154c:	794183e1 	ldrh	w1, [sp, #192]
    40001550:	321e0021 	orr	w1, w1, #0x4
    40001554:	790183e1 	strh	w1, [sp, #192]
    40001558:	34000086 	cbz	w6, 40001568 <cbvprintf+0x1a8>
    4000155c:	794183e1 	ldrh	w1, [sp, #192]
    40001560:	321d0021 	orr	w1, w1, #0x8
    40001564:	790183e1 	strh	w1, [sp, #192]
    40001568:	34000084 	cbz	w4, 40001578 <cbvprintf+0x1b8>
    4000156c:	794183e1 	ldrh	w1, [sp, #192]
    40001570:	321c0021 	orr	w1, w1, #0x10
    40001574:	790183e1 	strh	w1, [sp, #192]
    40001578:	34000085 	cbz	w5, 40001588 <cbvprintf+0x1c8>
    4000157c:	794183e1 	ldrh	w1, [sp, #192]
    40001580:	321b0021 	orr	w1, w1, #0x20
    40001584:	790183e1 	strh	w1, [sp, #192]
    40001588:	34000083 	cbz	w3, 40001598 <cbvprintf+0x1d8>
    4000158c:	794183e1 	ldrh	w1, [sp, #192]
    40001590:	321a0021 	orr	w1, w1, #0x40
    40001594:	790183e1 	strh	w1, [sp, #192]
	if (conv->flag_zero && conv->flag_dash) {
    40001598:	b940c3e1 	ldr	w1, [sp, #192]
    4000159c:	52800883 	mov	w3, #0x44                  	// #68
    400015a0:	0a030021 	and	w1, w1, w3
    400015a4:	6b03003f 	cmp	w1, w3
    400015a8:	54000081 	b.ne	400015b8 <cbvprintf+0x1f8>  // b.any
		conv->flag_zero = false;
    400015ac:	794183e1 	ldrh	w1, [sp, #192]
    400015b0:	12197821 	and	w1, w1, #0xffffffbf
    400015b4:	790183e1 	strh	w1, [sp, #192]
	conv->width_present = true;
    400015b8:	794183e3 	ldrh	w3, [sp, #192]
	if (*sp == '*') {
    400015bc:	7100a81f 	cmp	w0, #0x2a
	conv->width_present = true;
    400015c0:	32190061 	orr	w1, w3, #0x80
    400015c4:	790183e1 	strh	w1, [sp, #192]
	if (*sp == '*') {
    400015c8:	54000861 	b.ne	400016d4 <cbvprintf+0x314>  // b.any
			++sp;
    400015cc:	910006c1 	add	x1, x22, #0x1
		conv->width_star = true;
    400015d0:	32190463 	orr	w3, w3, #0x180
    400015d4:	790183e3 	strh	w3, [sp, #192]
	conv->prec_present = (*sp == '.');
    400015d8:	39400020 	ldrb	w0, [x1]
    400015dc:	7100b81f 	cmp	w0, #0x2e
    400015e0:	794183e0 	ldrh	w0, [sp, #192]
    400015e4:	1a9f17e3 	cset	w3, eq  // eq = none
    400015e8:	33170060 	bfi	w0, w3, #9, #1
    400015ec:	790183e0 	strh	w0, [sp, #192]
	if (!conv->prec_present) {
    400015f0:	54000841 	b.ne	400016f8 <cbvprintf+0x338>  // b.any
	if (*sp == '*') {
    400015f4:	39400423 	ldrb	w3, [x1, #1]
    400015f8:	7100a87f 	cmp	w3, #0x2a
    400015fc:	54000780 	b.eq	400016ec <cbvprintf+0x32c>  // b.none
	++sp;
    40001600:	91000421 	add	x1, x1, #0x1
	size_t val = 0;
    40001604:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40001608:	d2800146 	mov	x6, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp)) {
    4000160c:	aa0103e3 	mov	x3, x1
    40001610:	38401464 	ldrb	w4, [x3], #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40001614:	5100c085 	sub	w5, w4, #0x30
    40001618:	710024bf 	cmp	w5, #0x9
    4000161c:	54000c49 	b.ls	400017a4 <cbvprintf+0x3e4>  // b.plast
	conv->unsupported |= ((conv->prec_value < 0)
    40001620:	f94063e3 	ldr	x3, [sp, #192]
	conv->prec_value = prec;
    40001624:	b900cbe0 	str	w0, [sp, #200]
	conv->unsupported |= ((conv->prec_value < 0)
    40001628:	53010463 	ubfx	w3, w3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    4000162c:	37f80c60 	tbnz	w0, #31, 400017b8 <cbvprintf+0x3f8>
    40001630:	eb20c01f 	cmp	x0, w0, sxtw
    40001634:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
    40001638:	2a000060 	orr	w0, w3, w0
    4000163c:	794183e3 	ldrh	w3, [sp, #192]
    40001640:	331f0003 	bfi	w3, w0, #1, #1
    40001644:	790183e3 	strh	w3, [sp, #192]
	return sp;
    40001648:	1400002c 	b	400016f8 <cbvprintf+0x338>
		switch (*sp) {
    4000164c:	7100b41f 	cmp	w0, #0x2d
    40001650:	54000180 	b.eq	40001680 <cbvprintf+0x2c0>  // b.none
    40001654:	7100c01f 	cmp	w0, #0x30
    40001658:	54fff781 	b.ne	40001548 <cbvprintf+0x188>  // b.any
			conv->flag_zero = true;
    4000165c:	52800023 	mov	w3, #0x1                   	// #1
    40001660:	14000002 	b	40001668 <cbvprintf+0x2a8>
			conv->flag_plus = true;
    40001664:	52800026 	mov	w6, #0x1                   	// #1
			++sp;
    40001668:	910006d6 	add	x22, x22, #0x1
	} while (loop);
    4000166c:	17ffffaf 	b	40001528 <cbvprintf+0x168>
			conv->flag_space = true;
    40001670:	52800024 	mov	w4, #0x1                   	// #1
    40001674:	17fffffd 	b	40001668 <cbvprintf+0x2a8>
			conv->flag_hash = true;
    40001678:	52800025 	mov	w5, #0x1                   	// #1
    4000167c:	17fffffb 	b	40001668 <cbvprintf+0x2a8>
		switch (*sp) {
    40001680:	52800021 	mov	w1, #0x1                   	// #1
    40001684:	17fffff9 	b	40001668 <cbvprintf+0x2a8>
		val = 10U * val + *sp++ - '0';
    40001688:	9b067c00 	mul	x0, x0, x6
    4000168c:	aa0303e1 	mov	x1, x3
    40001690:	d100c000 	sub	x0, x0, #0x30
    40001694:	8b240000 	add	x0, x0, w4, uxtb
	while (isdigit((int)(unsigned char)*sp)) {
    40001698:	aa0103e3 	mov	x3, x1
    4000169c:	38401464 	ldrb	w4, [x3], #1
    400016a0:	5100c085 	sub	w5, w4, #0x30
    400016a4:	710024bf 	cmp	w5, #0x9
    400016a8:	54ffff09 	b.ls	40001688 <cbvprintf+0x2c8>  // b.plast
	if (sp != wp) {
    400016ac:	eb0102df 	cmp	x22, x1
    400016b0:	54fff940 	b.eq	400015d8 <cbvprintf+0x218>  // b.none
		conv->width_value = width;
    400016b4:	b900c7e0 	str	w0, [sp, #196]
				      || (width != (size_t)conv->width_value));
    400016b8:	37f80160 	tbnz	w0, #31, 400016e4 <cbvprintf+0x324>
    400016bc:	eb20c01f 	cmp	x0, w0, sxtw
    400016c0:	1a9f07e3 	cset	w3, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
    400016c4:	794183e0 	ldrh	w0, [sp, #192]
    400016c8:	331f0060 	bfi	w0, w3, #1, #1
    400016cc:	790183e0 	strh	w0, [sp, #192]
    400016d0:	17ffffc2 	b	400015d8 <cbvprintf+0x218>
    400016d4:	aa1603e1 	mov	x1, x22
	size_t val = 0;
    400016d8:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    400016dc:	d2800146 	mov	x6, #0xa                   	// #10
    400016e0:	17ffffee 	b	40001698 <cbvprintf+0x2d8>
				      || (width != (size_t)conv->width_value));
    400016e4:	52800023 	mov	w3, #0x1                   	// #1
    400016e8:	17fffff7 	b	400016c4 <cbvprintf+0x304>
		return ++sp;
    400016ec:	91000821 	add	x1, x1, #0x2
		conv->prec_star = true;
    400016f0:	32160000 	orr	w0, w0, #0x400
    400016f4:	790183e0 	strh	w0, [sp, #192]
	switch (*sp) {
    400016f8:	aa0103f6 	mov	x22, x1
    400016fc:	384016c0 	ldrb	w0, [x22], #1
    40001700:	7101b01f 	cmp	w0, #0x6c
    40001704:	54000860 	b.eq	40001810 <cbvprintf+0x450>  // b.none
    40001708:	540005c8 	b.hi	400017c0 <cbvprintf+0x400>  // b.pmore
    4000170c:	7101a01f 	cmp	w0, #0x68
    40001710:	54000660 	b.eq	400017dc <cbvprintf+0x41c>  // b.none
    40001714:	7101a81f 	cmp	w0, #0x6a
    40001718:	540008c0 	b.eq	40001830 <cbvprintf+0x470>  // b.none
    4000171c:	7101301f 	cmp	w0, #0x4c
    40001720:	54000940 	b.eq	40001848 <cbvprintf+0x488>  // b.none
    40001724:	aa0103f6 	mov	x22, x1
	conv->specifier = *sp++;
    40001728:	384016c0 	ldrb	w0, [x22], #1
    4000172c:	39030fe0 	strb	w0, [sp, #195]
	switch (conv->specifier) {
    40001730:	7101e01f 	cmp	w0, #0x78
    40001734:	54001008 	b.hi	40001934 <cbvprintf+0x574>  // b.pmore
    40001738:	71015c1f 	cmp	w0, #0x57
    4000173c:	54000928 	b.hi	40001860 <cbvprintf+0x4a0>  // b.pmore
    40001740:	7101041f 	cmp	w0, #0x41
    40001744:	540000a0 	b.eq	40001758 <cbvprintf+0x398>  // b.none
    40001748:	51011401 	sub	w1, w0, #0x45
    4000174c:	12001c21 	and	w1, w1, #0xff
    40001750:	7100083f 	cmp	w1, #0x2
    40001754:	54000f08 	b.hi	40001934 <cbvprintf+0x574>  // b.pmore
			|| (conv->specifier == 'A');
    40001758:	121a7800 	and	w0, w0, #0xffffffdf
		conv->specifier_a = (conv->specifier == 'a')
    4000175c:	784c13e1 	ldurh	w1, [sp, #193]
			|| (conv->specifier == 'A');
    40001760:	7101041f 	cmp	w0, #0x41
    40001764:	1a9f17e0 	cset	w0, eq  // eq = none
		conv->specifier_a = (conv->specifier == 'a')
    40001768:	12156c21 	and	w1, w1, #0xfffff87f
    4000176c:	53196000 	lsl	w0, w0, #7
    40001770:	32160000 	orr	w0, w0, #0x400
    40001774:	2a010000 	orr	w0, w0, w1
    40001778:	780c13e0 	sturh	w0, [sp, #193]
		if (conv->specifier_a
    4000177c:	79c183e1 	ldrsh	w1, [sp, #192]
    40001780:	794183e0 	ldrh	w0, [sp, #192]
    40001784:	37f80dc1 	tbnz	w1, #31, 4000193c <cbvprintf+0x57c>
		if (conv->length_mod == LENGTH_L) {
    40001788:	12150c03 	and	w3, w0, #0x7800
    4000178c:	52830001 	mov	w1, #0x1800                	// #6144
    40001790:	6b01007f 	cmp	w3, w1
    40001794:	54000a61 	b.ne	400018e0 <cbvprintf+0x520>  // b.any
			conv->length_mod = LENGTH_NONE;
    40001798:	12116c00 	and	w0, w0, #0xffff87ff
    4000179c:	790183e0 	strh	w0, [sp, #192]
    400017a0:	14000045 	b	400018b4 <cbvprintf+0x4f4>
		val = 10U * val + *sp++ - '0';
    400017a4:	9b067c00 	mul	x0, x0, x6
    400017a8:	aa0303e1 	mov	x1, x3
    400017ac:	d100c000 	sub	x0, x0, #0x30
    400017b0:	8b240000 	add	x0, x0, w4, uxtb
    400017b4:	17ffff96 	b	4000160c <cbvprintf+0x24c>
			      || (prec != (size_t)conv->prec_value));
    400017b8:	52800020 	mov	w0, #0x1                   	// #1
    400017bc:	17ffff9f 	b	40001638 <cbvprintf+0x278>
	switch (*sp) {
    400017c0:	7101d01f 	cmp	w0, #0x74
    400017c4:	540003c0 	b.eq	4000183c <cbvprintf+0x47c>  // b.none
    400017c8:	7101e81f 	cmp	w0, #0x7a
    400017cc:	54fffac1 	b.ne	40001724 <cbvprintf+0x364>  // b.any
		conv->length_mod = LENGTH_Z;
    400017d0:	794183e0 	ldrh	w0, [sp, #192]
    400017d4:	528000c1 	mov	w1, #0x6                   	// #6
    400017d8:	1400000b 	b	40001804 <cbvprintf+0x444>
		if (*++sp == 'h') {
    400017dc:	39400420 	ldrb	w0, [x1, #1]
    400017e0:	7101a01f 	cmp	w0, #0x68
    400017e4:	794183e0 	ldrh	w0, [sp, #192]
    400017e8:	540000c1 	b.ne	40001800 <cbvprintf+0x440>  // b.any
			conv->length_mod = LENGTH_HH;
    400017ec:	52800023 	mov	w3, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
    400017f0:	33150c60 	bfi	w0, w3, #11, #4
			++sp;
    400017f4:	91000836 	add	x22, x1, #0x2
			conv->length_mod = LENGTH_LL;
    400017f8:	790183e0 	strh	w0, [sp, #192]
			++sp;
    400017fc:	17ffffcb 	b	40001728 <cbvprintf+0x368>
			conv->length_mod = LENGTH_H;
    40001800:	52800041 	mov	w1, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
    40001804:	33150c20 	bfi	w0, w1, #11, #4
		conv->unsupported = true;
    40001808:	790183e0 	strh	w0, [sp, #192]
		break;
    4000180c:	17ffffc7 	b	40001728 <cbvprintf+0x368>
		if (*++sp == 'l') {
    40001810:	39400420 	ldrb	w0, [x1, #1]
    40001814:	7101b01f 	cmp	w0, #0x6c
    40001818:	794183e0 	ldrh	w0, [sp, #192]
    4000181c:	54000061 	b.ne	40001828 <cbvprintf+0x468>  // b.any
			conv->length_mod = LENGTH_LL;
    40001820:	52800083 	mov	w3, #0x4                   	// #4
    40001824:	17fffff3 	b	400017f0 <cbvprintf+0x430>
			conv->length_mod = LENGTH_L;
    40001828:	52800061 	mov	w1, #0x3                   	// #3
    4000182c:	17fffff6 	b	40001804 <cbvprintf+0x444>
		conv->length_mod = LENGTH_J;
    40001830:	794183e0 	ldrh	w0, [sp, #192]
    40001834:	528000a1 	mov	w1, #0x5                   	// #5
    40001838:	17fffff3 	b	40001804 <cbvprintf+0x444>
		conv->length_mod = LENGTH_T;
    4000183c:	794183e0 	ldrh	w0, [sp, #192]
    40001840:	528000e1 	mov	w1, #0x7                   	// #7
    40001844:	17fffff0 	b	40001804 <cbvprintf+0x444>
		conv->unsupported = true;
    40001848:	794183e0 	ldrh	w0, [sp, #192]
    4000184c:	128f0041 	mov	w1, #0xffff87fd            	// #-30723
    40001850:	0a010000 	and	w0, w0, w1
    40001854:	52880041 	mov	w1, #0x4002                	// #16386
    40001858:	2a010000 	orr	w0, w0, w1
    4000185c:	17ffffeb 	b	40001808 <cbvprintf+0x448>
	switch (conv->specifier) {
    40001860:	51016003 	sub	w3, w0, #0x58
    40001864:	7100807f 	cmp	w3, #0x20
    40001868:	54000668 	b.hi	40001934 <cbvprintf+0x574>  // b.pmore
    4000186c:	b0000021 	adrp	x1, 40006000 <levels.0+0x10>
    40001870:	91009021 	add	x1, x1, #0x24
    40001874:	38634821 	ldrb	w1, [x1, w3, uxtw]
    40001878:	10000063 	adr	x3, 40001884 <cbvprintf+0x4c4>
    4000187c:	8b218861 	add	x1, x3, w1, sxtb #2
    40001880:	d61f0020 	br	x1
		conv->specifier_cat = SPECIFIER_SINT;
    40001884:	39430be1 	ldrb	w1, [sp, #194]
    40001888:	52800023 	mov	w3, #0x1                   	// #1
		conv->specifier_cat = SPECIFIER_UINT;
    4000188c:	33000861 	bfxil	w1, w3, #0, #3
    40001890:	39030be1 	strb	w1, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40001894:	794183e1 	ldrh	w1, [sp, #192]
    40001898:	12150c23 	and	w3, w1, #0x7800
    4000189c:	7140107f 	cmp	w3, #0x4, lsl #12
    400018a0:	54000061 	b.ne	400018ac <cbvprintf+0x4ec>  // b.any
			conv->invalid = true;
    400018a4:	32000021 	orr	w1, w1, #0x1
    400018a8:	790183e1 	strh	w1, [sp, #192]
		if (conv->specifier == 'c') {
    400018ac:	71018c1f 	cmp	w0, #0x63
    400018b0:	540003a0 	b.eq	40001924 <cbvprintf+0x564>  // b.none
	bool unsupported = false;
    400018b4:	52800000 	mov	w0, #0x0                   	// #0
	conv->unsupported |= unsupported;
    400018b8:	f94063e1 	ldr	x1, [sp, #192]
    400018bc:	d3410421 	ubfx	x1, x1, #1, #1
    400018c0:	2a010000 	orr	w0, w0, w1
    400018c4:	794183e1 	ldrh	w1, [sp, #192]
    400018c8:	331f0001 	bfi	w1, w0, #1, #1
    400018cc:	790183e1 	strh	w1, [sp, #192]
	return sp;
    400018d0:	17fffedf 	b	4000144c <cbvprintf+0x8c>
		conv->specifier_cat = SPECIFIER_UINT;
    400018d4:	39430be1 	ldrb	w1, [sp, #194]
    400018d8:	52800043 	mov	w3, #0x2                   	// #2
    400018dc:	17ffffec 	b	4000188c <cbvprintf+0x4cc>
		} else if ((conv->length_mod != LENGTH_NONE)
    400018e0:	7215081f 	tst	w0, #0x3800
    400018e4:	54fffe80 	b.eq	400018b4 <cbvprintf+0x4f4>  // b.none
		conv->invalid = true;
    400018e8:	32000000 	orr	w0, w0, #0x1
    400018ec:	17ffffac 	b	4000179c <cbvprintf+0x3dc>
		conv->specifier_cat = SPECIFIER_PTR;
    400018f0:	39430be0 	ldrb	w0, [sp, #194]
    400018f4:	52800061 	mov	w1, #0x3                   	// #3
    400018f8:	33000820 	bfxil	w0, w1, #0, #3
    400018fc:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40001900:	794183e0 	ldrh	w0, [sp, #192]
    40001904:	12150c00 	and	w0, w0, #0x7800
    40001908:	7140101f 	cmp	w0, #0x4, lsl #12
    4000190c:	1a9f17e0 	cset	w0, eq  // eq = none
    40001910:	17ffffea 	b	400018b8 <cbvprintf+0x4f8>
		conv->specifier_cat = SPECIFIER_PTR;
    40001914:	39430be0 	ldrb	w0, [sp, #194]
    40001918:	52800061 	mov	w1, #0x3                   	// #3
    4000191c:	33000820 	bfxil	w0, w1, #0, #3
    40001920:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod != LENGTH_NONE) {
    40001924:	794183e0 	ldrh	w0, [sp, #192]
    40001928:	72150c1f 	tst	w0, #0x7800
    4000192c:	1a9f07e0 	cset	w0, ne  // ne = any
    40001930:	17ffffe2 	b	400018b8 <cbvprintf+0x4f8>
		conv->invalid = true;
    40001934:	794183e0 	ldrh	w0, [sp, #192]
    40001938:	17ffffec 	b	400018e8 <cbvprintf+0x528>
			unsupported = true;
    4000193c:	52800020 	mov	w0, #0x1                   	// #1
    40001940:	17ffffde 	b	400018b8 <cbvprintf+0x4f8>
			width = va_arg(ap, int);
    40001944:	11002381 	add	w1, w28, #0x8
    40001948:	7100003f 	cmp	w1, #0x0
    4000194c:	540000cd 	b.le	40001964 <cbvprintf+0x5a4>
    40001950:	91002e63 	add	x3, x19, #0xb
    40001954:	aa1303e0 	mov	x0, x19
    40001958:	2a0103fc 	mov	w28, w1
    4000195c:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40001960:	17fffec1 	b	40001464 <cbvprintf+0xa4>
    40001964:	8b3cc300 	add	x0, x24, w28, sxtw
    40001968:	2a0103fc 	mov	w28, w1
    4000196c:	17fffebe 	b	40001464 <cbvprintf+0xa4>
			width = conv->width_value;
    40001970:	b940c7f7 	ldr	w23, [sp, #196]
    40001974:	f279001f 	tst	x0, #0x80
    40001978:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
    4000197c:	17fffec0 	b	4000147c <cbvprintf+0xbc>
			int arg = va_arg(ap, int);
    40001980:	11002381 	add	w1, w28, #0x8
    40001984:	7100003f 	cmp	w1, #0x0
    40001988:	540000cd 	b.le	400019a0 <cbvprintf+0x5e0>
    4000198c:	91002e63 	add	x3, x19, #0xb
    40001990:	aa1303e0 	mov	x0, x19
    40001994:	2a0103fc 	mov	w28, w1
    40001998:	927df073 	and	x19, x3, #0xfffffffffffffff8
    4000199c:	17fffebe 	b	40001494 <cbvprintf+0xd4>
    400019a0:	8b3cc300 	add	x0, x24, w28, sxtw
    400019a4:	2a0103fc 	mov	w28, w1
    400019a8:	17fffebb 	b	40001494 <cbvprintf+0xd4>
			precision = conv->prec_value;
    400019ac:	b940cbe9 	ldr	w9, [sp, #200]
    400019b0:	f277001f 	tst	x0, #0x200
    400019b4:	5a9f1129 	csinv	w9, w9, wzr, ne  // ne = any
    400019b8:	17fffebd 	b	400014ac <cbvprintf+0xec>
				value->sint = va_arg(ap, int);
    400019bc:	37f8019c 	tbnz	w28, #31, 400019ec <cbvprintf+0x62c>
    400019c0:	91002e60 	add	x0, x19, #0xb
    400019c4:	2a1c03e4 	mov	w4, w28
    400019c8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400019cc:	b9800265 	ldrsw	x5, [x19]
				value->sint =
    400019d0:	f9005be5 	str	x5, [sp, #176]
				break;
    400019d4:	2a0403fc 	mov	w28, w4
    400019d8:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    400019dc:	7100043f 	cmp	w1, #0x1
    400019e0:	54000361 	b.ne	40001a4c <cbvprintf+0x68c>  // b.any
				value->uint = (unsigned char)value->uint;
    400019e4:	3942c3e0 	ldrb	w0, [sp, #176]
    400019e8:	1400001c 	b	40001a58 <cbvprintf+0x698>
				value->sint = va_arg(ap, int);
    400019ec:	11002384 	add	w4, w28, #0x8
    400019f0:	7100009f 	cmp	w4, #0x0
    400019f4:	5400008d 	b.le	40001a04 <cbvprintf+0x644>
    400019f8:	91002e60 	add	x0, x19, #0xb
    400019fc:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001a00:	17fffff3 	b	400019cc <cbvprintf+0x60c>
    40001a04:	aa1303e0 	mov	x0, x19
    40001a08:	8b3cc313 	add	x19, x24, w28, sxtw
    40001a0c:	17fffff0 	b	400019cc <cbvprintf+0x60c>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    40001a10:	37f800dc 	tbnz	w28, #31, 40001a28 <cbvprintf+0x668>
    40001a14:	91003e60 	add	x0, x19, #0xf
    40001a18:	2a1c03e4 	mov	w4, w28
    40001a1c:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->sint =
    40001a20:	f9400265 	ldr	x5, [x19]
    40001a24:	17ffffeb 	b	400019d0 <cbvprintf+0x610>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    40001a28:	11002384 	add	w4, w28, #0x8
    40001a2c:	7100009f 	cmp	w4, #0x0
    40001a30:	5400008d 	b.le	40001a40 <cbvprintf+0x680>
    40001a34:	91003e60 	add	x0, x19, #0xf
    40001a38:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001a3c:	17fffff9 	b	40001a20 <cbvprintf+0x660>
    40001a40:	aa1303e0 	mov	x0, x19
    40001a44:	8b3cc313 	add	x19, x24, w28, sxtw
    40001a48:	17fffff6 	b	40001a20 <cbvprintf+0x660>
			} else if (length_mod == LENGTH_H) {
    40001a4c:	7100083f 	cmp	w1, #0x2
    40001a50:	54000061 	b.ne	40001a5c <cbvprintf+0x69c>  // b.any
				value->sint = (short)value->sint;
    40001a54:	798163e0 	ldrsh	x0, [sp, #176]
				value->uint = (unsigned short)value->uint;
    40001a58:	f9005be0 	str	x0, [sp, #176]
		if (conv->invalid || conv->unsupported) {
    40001a5c:	b940c3e0 	ldr	w0, [sp, #192]
    40001a60:	f240041f 	tst	x0, #0x3
    40001a64:	540011c0 	b.eq	40001c9c <cbvprintf+0x8dc>  // b.none
			OUTS(sp, fp);
    40001a68:	aa1603e3 	mov	x3, x22
    40001a6c:	aa1503e1 	mov	x1, x21
    40001a70:	aa1403e0 	mov	x0, x20
    40001a74:	97fffe37 	bl	40001350 <outs>
    40001a78:	37f85140 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40001a7c:	8b20c37b 	add	x27, x27, w0, sxtw
			while (pad_len-- > 0) {
    40001a80:	aa1603e2 	mov	x2, x22
    40001a84:	17fffe5f 	b	40001400 <cbvprintf+0x40>
		} else if (specifier_cat == SPECIFIER_UINT) {
    40001a88:	7100081f 	cmp	w0, #0x2
    40001a8c:	54000881 	b.ne	40001b9c <cbvprintf+0x7dc>  // b.any
			switch (length_mod) {
    40001a90:	51000c24 	sub	w4, w1, #0x3
    40001a94:	7100109f 	cmp	w4, #0x4
    40001a98:	540000e8 	b.hi	40001ab4 <cbvprintf+0x6f4>  // b.pmore
    40001a9c:	b0000020 	adrp	x0, 40006000 <levels.0+0x10>
    40001aa0:	91012000 	add	x0, x0, #0x48
    40001aa4:	38644800 	ldrb	w0, [x0, w4, uxtw]
    40001aa8:	10000064 	adr	x4, 40001ab4 <cbvprintf+0x6f4>
    40001aac:	8b208880 	add	x0, x4, w0, sxtb #2
    40001ab0:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
    40001ab4:	37f801dc 	tbnz	w28, #31, 40001aec <cbvprintf+0x72c>
    40001ab8:	91002e60 	add	x0, x19, #0xb
    40001abc:	2a1c03e4 	mov	w4, w28
    40001ac0:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001ac4:	b9400265 	ldr	w5, [x19]
				value->uint =
    40001ac8:	f9005be5 	str	x5, [sp, #176]
				break;
    40001acc:	2a0403fc 	mov	w28, w4
    40001ad0:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    40001ad4:	7100043f 	cmp	w1, #0x1
    40001ad8:	54fff860 	b.eq	400019e4 <cbvprintf+0x624>  // b.none
			} else if (length_mod == LENGTH_H) {
    40001adc:	7100083f 	cmp	w1, #0x2
    40001ae0:	54fffbe1 	b.ne	40001a5c <cbvprintf+0x69c>  // b.any
				value->uint = (unsigned short)value->uint;
    40001ae4:	794163e0 	ldrh	w0, [sp, #176]
    40001ae8:	17ffffdc 	b	40001a58 <cbvprintf+0x698>
				value->uint = va_arg(ap, unsigned int);
    40001aec:	11002384 	add	w4, w28, #0x8
    40001af0:	7100009f 	cmp	w4, #0x0
    40001af4:	5400008d 	b.le	40001b04 <cbvprintf+0x744>
    40001af8:	91002e60 	add	x0, x19, #0xb
    40001afc:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001b00:	17fffff1 	b	40001ac4 <cbvprintf+0x704>
    40001b04:	aa1303e0 	mov	x0, x19
    40001b08:	8b3cc313 	add	x19, x24, w28, sxtw
    40001b0c:	17ffffee 	b	40001ac4 <cbvprintf+0x704>
				if ((!WCHAR_IS_SIGNED)
    40001b10:	39430fe0 	ldrb	w0, [sp, #195]
    40001b14:	71018c1f 	cmp	w0, #0x63
    40001b18:	54000a41 	b.ne	40001c60 <cbvprintf+0x8a0>  // b.any
					value->uint = (wchar_t)va_arg(ap,
    40001b1c:	37f8011c 	tbnz	w28, #31, 40001b3c <cbvprintf+0x77c>
    40001b20:	91002e60 	add	x0, x19, #0xb
    40001b24:	2a1c03e4 	mov	w4, w28
    40001b28:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001b2c:	b9400265 	ldr	w5, [x19]
			value->ptr = va_arg(ap, void *);
    40001b30:	2a0403fc 	mov	w28, w4
    40001b34:	f9005be5 	str	x5, [sp, #176]
    40001b38:	1400003a 	b	40001c20 <cbvprintf+0x860>
					value->uint = (wchar_t)va_arg(ap,
    40001b3c:	11002384 	add	w4, w28, #0x8
    40001b40:	7100009f 	cmp	w4, #0x0
    40001b44:	5400008d 	b.le	40001b54 <cbvprintf+0x794>
    40001b48:	91002e60 	add	x0, x19, #0xb
    40001b4c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001b50:	17fffff7 	b	40001b2c <cbvprintf+0x76c>
    40001b54:	aa1303e0 	mov	x0, x19
    40001b58:	8b3cc313 	add	x19, x24, w28, sxtw
    40001b5c:	17fffff4 	b	40001b2c <cbvprintf+0x76c>
					(uint_value_type)va_arg(ap, size_t);
    40001b60:	37f800dc 	tbnz	w28, #31, 40001b78 <cbvprintf+0x7b8>
    40001b64:	91003e60 	add	x0, x19, #0xf
    40001b68:	2a1c03e4 	mov	w4, w28
    40001b6c:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->uint =
    40001b70:	f9400265 	ldr	x5, [x19]
    40001b74:	17ffffd5 	b	40001ac8 <cbvprintf+0x708>
					(uint_value_type)va_arg(ap, size_t);
    40001b78:	11002384 	add	w4, w28, #0x8
    40001b7c:	7100009f 	cmp	w4, #0x0
    40001b80:	5400008d 	b.le	40001b90 <cbvprintf+0x7d0>
    40001b84:	91003e60 	add	x0, x19, #0xf
    40001b88:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001b8c:	17fffff9 	b	40001b70 <cbvprintf+0x7b0>
    40001b90:	aa1303e0 	mov	x0, x19
    40001b94:	8b3cc313 	add	x19, x24, w28, sxtw
    40001b98:	17fffff6 	b	40001b70 <cbvprintf+0x7b0>
		} else if (specifier_cat == SPECIFIER_FP) {
    40001b9c:	7100101f 	cmp	w0, #0x4
    40001ba0:	540005c1 	b.ne	40001c58 <cbvprintf+0x898>  // b.any
				value->ldbl = va_arg(ap, long double);
    40001ba4:	b9407be0 	ldr	w0, [sp, #120]
			if (length_mod == LENGTH_UPPER_L) {
    40001ba8:	7100203f 	cmp	w1, #0x8
    40001bac:	540002c1 	b.ne	40001c04 <cbvprintf+0x844>  // b.any
				value->ldbl = va_arg(ap, long double);
    40001bb0:	37f80120 	tbnz	w0, #31, 40001bd4 <cbvprintf+0x814>
    40001bb4:	91003e60 	add	x0, x19, #0xf
    40001bb8:	b9407be4 	ldr	w4, [sp, #120]
    40001bbc:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    40001bc0:	91004013 	add	x19, x0, #0x10
    40001bc4:	3dc00000 	ldr	q0, [x0]
    40001bc8:	b9007be4 	str	w4, [sp, #120]
    40001bcc:	3d802fe0 	str	q0, [sp, #176]
    40001bd0:	17ffffa3 	b	40001a5c <cbvprintf+0x69c>
    40001bd4:	b9407be0 	ldr	w0, [sp, #120]
    40001bd8:	11004004 	add	w4, w0, #0x10
    40001bdc:	7100009f 	cmp	w4, #0x0
    40001be0:	540000ad 	b.le	40001bf4 <cbvprintf+0x834>
    40001be4:	91003e60 	add	x0, x19, #0xf
    40001be8:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    40001bec:	91004013 	add	x19, x0, #0x10
    40001bf0:	17fffff5 	b	40001bc4 <cbvprintf+0x804>
    40001bf4:	f94037e5 	ldr	x5, [sp, #104]
    40001bf8:	b9407be0 	ldr	w0, [sp, #120]
    40001bfc:	8b20c0a0 	add	x0, x5, w0, sxtw
    40001c00:	17fffff1 	b	40001bc4 <cbvprintf+0x804>
				value->dbl = va_arg(ap, double);
    40001c04:	37f80120 	tbnz	w0, #31, 40001c28 <cbvprintf+0x868>
    40001c08:	91003e60 	add	x0, x19, #0xf
    40001c0c:	b9407be4 	ldr	w4, [sp, #120]
    40001c10:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001c14:	fd400260 	ldr	d0, [x19]
    40001c18:	b9007be4 	str	w4, [sp, #120]
    40001c1c:	fd005be0 	str	d0, [sp, #176]
			value->ptr = va_arg(ap, void *);
    40001c20:	aa0003f3 	mov	x19, x0
    40001c24:	17ffff8e 	b	40001a5c <cbvprintf+0x69c>
				value->dbl = va_arg(ap, double);
    40001c28:	b9407be0 	ldr	w0, [sp, #120]
    40001c2c:	11004004 	add	w4, w0, #0x10
    40001c30:	7100009f 	cmp	w4, #0x0
    40001c34:	5400008d 	b.le	40001c44 <cbvprintf+0x884>
    40001c38:	91003e60 	add	x0, x19, #0xf
    40001c3c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001c40:	17fffff5 	b	40001c14 <cbvprintf+0x854>
    40001c44:	f94037e6 	ldr	x6, [sp, #104]
    40001c48:	aa1303e0 	mov	x0, x19
    40001c4c:	b9407be5 	ldr	w5, [sp, #120]
    40001c50:	8b25c0d3 	add	x19, x6, w5, sxtw
    40001c54:	17fffff0 	b	40001c14 <cbvprintf+0x854>
		} else if (specifier_cat == SPECIFIER_PTR) {
    40001c58:	71000c1f 	cmp	w0, #0x3
    40001c5c:	54fff001 	b.ne	40001a5c <cbvprintf+0x69c>  // b.any
			value->ptr = va_arg(ap, void *);
    40001c60:	37f800dc 	tbnz	w28, #31, 40001c78 <cbvprintf+0x8b8>
    40001c64:	91003e60 	add	x0, x19, #0xf
    40001c68:	2a1c03e4 	mov	w4, w28
    40001c6c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001c70:	f9400265 	ldr	x5, [x19]
    40001c74:	17ffffaf 	b	40001b30 <cbvprintf+0x770>
    40001c78:	11002384 	add	w4, w28, #0x8
    40001c7c:	7100009f 	cmp	w4, #0x0
    40001c80:	5400008d 	b.le	40001c90 <cbvprintf+0x8d0>
    40001c84:	91003e60 	add	x0, x19, #0xf
    40001c88:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40001c8c:	17fffff9 	b	40001c70 <cbvprintf+0x8b0>
    40001c90:	aa1303e0 	mov	x0, x19
    40001c94:	8b3cc313 	add	x19, x24, w28, sxtw
    40001c98:	17fffff6 	b	40001c70 <cbvprintf+0x8b0>
		switch (conv->specifier) {
    40001c9c:	39430fe5 	ldrb	w5, [sp, #195]
    40001ca0:	7101e0bf 	cmp	w5, #0x78
    40001ca4:	54ffeee8 	b.hi	40001a80 <cbvprintf+0x6c0>  // b.pmore
    40001ca8:	71015cbf 	cmp	w5, #0x57
    40001cac:	54000468 	b.hi	40001d38 <cbvprintf+0x978>  // b.pmore
    40001cb0:	710094bf 	cmp	w5, #0x25
    40001cb4:	54000540 	b.eq	40001d5c <cbvprintf+0x99c>  // b.none
    40001cb8:	710090bf 	cmp	w5, #0x24
    40001cbc:	54ffee29 	b.ls	40001a80 <cbvprintf+0x6c0>  // b.plast
    40001cc0:	710104bf 	cmp	w5, #0x41
    40001cc4:	540000a0 	b.eq	40001cd8 <cbvprintf+0x918>  // b.none
    40001cc8:	510114a0 	sub	w0, w5, #0x45
    40001ccc:	12001c00 	and	w0, w0, #0xff
    40001cd0:	7100081f 	cmp	w0, #0x2
    40001cd4:	54ffed68 	b.hi	40001a80 <cbvprintf+0x6c0>  // b.pmore
	} u = {
    40001cd8:	f9405be0 	ldr	x0, [sp, #176]
	if ((u.u64 & SIGN_MASK) != 0U) {
    40001cdc:	b7f81240 	tbnz	x0, #63, 40001f24 <cbvprintf+0xb64>
	} else if (conv->flag_plus) {
    40001ce0:	794183e4 	ldrh	w4, [sp, #192]
    40001ce4:	37181244 	tbnz	w4, #3, 40001f2c <cbvprintf+0xb6c>
		*sign = ' ';
    40001ce8:	d3441084 	ubfx	x4, x4, #4, #1
    40001cec:	531b6884 	lsl	w4, w4, #5
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    40001cf0:	d374f801 	ubfx	x1, x0, #52, #11
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    40001cf4:	9240cc00 	and	x0, x0, #0xfffffffffffff
    40001cf8:	f90047e0 	str	x0, [sp, #136]
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    40001cfc:	711ffc3f 	cmp	w1, #0x7ff
    40001d00:	54001341 	b.ne	40001f68 <cbvprintf+0xba8>  // b.any
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40001d04:	510104a5 	sub	w5, w5, #0x41
			if (isupper((int)c)) {
    40001d08:	710064bf 	cmp	w5, #0x19
		if (fract == 0) {
    40001d0c:	b50011c0 	cbnz	x0, 40001f44 <cbvprintf+0xb84>
			if (isupper((int)c)) {
    40001d10:	54001128 	b.hi	40001f34 <cbvprintf+0xb74>  // b.pmore
				*buf++ = 'I';
    40001d14:	5289c920 	mov	w0, #0x4e49                	// #20041
    40001d18:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'F';
    40001d1c:	528008c0 	mov	w0, #0x46                  	// #70
				*buf++ = 'n';
    40001d20:	39024be0 	strb	w0, [sp, #146]
		*bpe = buf;
    40001d24:	91024ff9 	add	x25, sp, #0x93
		conv->flag_zero = false;
    40001d28:	794183e0 	ldrh	w0, [sp, #192]
    40001d2c:	12197800 	and	w0, w0, #0xffffffbf
    40001d30:	790183e0 	strh	w0, [sp, #192]
		return bps;
    40001d34:	1400001d 	b	40001da8 <cbvprintf+0x9e8>
		switch (conv->specifier) {
    40001d38:	510160a2 	sub	w2, w5, #0x58
    40001d3c:	7100805f 	cmp	w2, #0x20
    40001d40:	54ffea08 	b.hi	40001a80 <cbvprintf+0x6c0>  // b.pmore
    40001d44:	b0000020 	adrp	x0, 40006000 <levels.0+0x10>
    40001d48:	91014000 	add	x0, x0, #0x50
    40001d4c:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
    40001d50:	10000062 	adr	x2, 40001d5c <cbvprintf+0x99c>
    40001d54:	8b20a840 	add	x0, x2, w0, sxth #2
    40001d58:	d61f0000 	br	x0
			OUTC('%');
    40001d5c:	aa1503e1 	mov	x1, x21
    40001d60:	2a0503e0 	mov	w0, w5
    40001d64:	17fffdaf 	b	40001420 <cbvprintf+0x60>
			bps = (const char *)value->ptr;
    40001d68:	f9405bfa 	ldr	x26, [sp, #176]
			if (precision >= 0) {
    40001d6c:	37f80109 	tbnz	w9, #31, 40001d8c <cbvprintf+0x9cc>
				len = strnlen(bps, precision);
    40001d70:	93407d21 	sxtw	x1, w9
    40001d74:	aa1a03e0 	mov	x0, x26
    40001d78:	940004ee 	bl	40003130 <strnlen>
			bpe = bps + len;
    40001d7c:	8b000359 	add	x25, x26, x0
		char sign = 0;
    40001d80:	52800004 	mov	w4, #0x0                   	// #0
		if (bps == NULL) {
    40001d84:	b500015a 	cbnz	x26, 40001dac <cbvprintf+0x9ec>
    40001d88:	17ffff3e 	b	40001a80 <cbvprintf+0x6c0>
				len = strlen(bps);
    40001d8c:	aa1a03e0 	mov	x0, x26
    40001d90:	940004e1 	bl	40003114 <strlen>
    40001d94:	17fffffa 	b	40001d7c <cbvprintf+0x9bc>
			bpe = buf + 1;
    40001d98:	910247f9 	add	x25, sp, #0x91
		char sign = 0;
    40001d9c:	52800004 	mov	w4, #0x0                   	// #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    40001da0:	f9405be0 	ldr	x0, [sp, #176]
    40001da4:	390243e0 	strb	w0, [sp, #144]
				bps = encode_float(value->dbl, conv, precision,
    40001da8:	910243fa 	add	x26, sp, #0x90
		size_t nj_len = (bpe - bps);
    40001dac:	cb1a0320 	sub	x0, x25, x26
		if (sign != 0) {
    40001db0:	34000044 	cbz	w4, 40001db8 <cbvprintf+0x9f8>
			nj_len += 1U;
    40001db4:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
    40001db8:	39430be5 	ldrb	w5, [sp, #194]
    40001dbc:	36202b85 	tbz	w5, #4, 4000232c <cbvprintf+0xf6c>
			nj_len += 2U;
    40001dc0:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
    40001dc4:	b980c7e1 	ldrsw	x1, [sp, #196]
    40001dc8:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
    40001dcc:	36300065 	tbz	w5, #6, 40001dd8 <cbvprintf+0xa18>
			nj_len += conv->pad0_pre_exp;
    40001dd0:	b980cbe1 	ldrsw	x1, [sp, #200]
    40001dd4:	8b010000 	add	x0, x0, x1
		if (width > 0) {
    40001dd8:	710002ff 	cmp	w23, #0x0
    40001ddc:	54002c8d 	b.le	4000236c <cbvprintf+0xfac>
			width -= (int)nj_len;
    40001de0:	4b0002f7 	sub	w23, w23, w0
			if (!conv->flag_dash) {
    40001de4:	f94063e0 	ldr	x0, [sp, #192]
    40001de8:	721e001f 	tst	w0, #0x4
    40001dec:	54002c01 	b.ne	4000236c <cbvprintf+0xfac>  // b.any
				if (conv->flag_zero) {
    40001df0:	794183e0 	ldrh	w0, [sp, #192]
    40001df4:	36303080 	tbz	w0, #6, 40002404 <cbvprintf+0x1044>
					if (sign != 0) {
    40001df8:	340000e4 	cbz	w4, 40001e14 <cbvprintf+0xa54>
						OUTC(sign);
    40001dfc:	aa1503e1 	mov	x1, x21
    40001e00:	2a0403e0 	mov	w0, w4
    40001e04:	d63f0280 	blr	x20
    40001e08:	37f834c0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40001e0c:	9100077b 	add	x27, x27, #0x1
						sign = 0;
    40001e10:	52800004 	mov	w4, #0x0                   	// #0
					pad = '0';
    40001e14:	52800605 	mov	w5, #0x30                  	// #48
    40001e18:	1400017c 	b	40002408 <cbvprintf+0x1048>
			if (conv->flag_plus) {
    40001e1c:	794183e4 	ldrh	w4, [sp, #192]
    40001e20:	37180384 	tbnz	w4, #3, 40001e90 <cbvprintf+0xad0>
				sign = ' ';
    40001e24:	d3441084 	ubfx	x4, x4, #4, #1
    40001e28:	531b6884 	lsl	w4, w4, #5
			sint = value->sint;
    40001e2c:	f9405be0 	ldr	x0, [sp, #176]
			if (sint < 0) {
    40001e30:	b6f80080 	tbz	x0, #63, 40001e40 <cbvprintf+0xa80>
				value->uint = (uint_value_type)-sint;
    40001e34:	cb0003e0 	neg	x0, x0
				sign = '-';
    40001e38:	528005a4 	mov	w4, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
    40001e3c:	f9005be0 	str	x0, [sp, #176]
			bps = encode_uint(value->uint, conv, buf, bpe);
    40001e40:	f9405be0 	ldr	x0, [sp, #176]
    40001e44:	9102a7e3 	add	x3, sp, #0xa9
    40001e48:	910243e2 	add	x2, sp, #0x90
    40001e4c:	910303e1 	add	x1, sp, #0xc0
    40001e50:	b90073e4 	str	w4, [sp, #112]
    40001e54:	97fffd0e 	bl	4000128c <encode_uint>
    40001e58:	aa0003fa 	mov	x26, x0
    40001e5c:	b94073e4 	ldr	w4, [sp, #112]
			if (precision >= 0) {
    40001e60:	9102a7e3 	add	x3, sp, #0xa9
    40001e64:	37f80129 	tbnz	w9, #31, 40001e88 <cbvprintf+0xac8>
				conv->flag_zero = false;
    40001e68:	794183e1 	ldrh	w1, [sp, #192]
				size_t len = bpe - bps;
    40001e6c:	cb1a0060 	sub	x0, x3, x26
				if (len < (size_t)precision) {
    40001e70:	eb29c01f 	cmp	x0, w9, sxtw
				conv->flag_zero = false;
    40001e74:	12197821 	and	w1, w1, #0xffffffbf
    40001e78:	790183e1 	strh	w1, [sp, #192]
				if (len < (size_t)precision) {
    40001e7c:	54000062 	b.cs	40001e88 <cbvprintf+0xac8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
    40001e80:	4b000120 	sub	w0, w9, w0
    40001e84:	b900c7e0 	str	w0, [sp, #196]
		const char *bpe = buf + sizeof(buf);
    40001e88:	aa0303f9 	mov	x25, x3
    40001e8c:	17ffffbe 	b	40001d84 <cbvprintf+0x9c4>
				sign = '+';
    40001e90:	52800564 	mov	w4, #0x2b                  	// #43
    40001e94:	17ffffe6 	b	40001e2c <cbvprintf+0xa6c>
		switch (conv->specifier) {
    40001e98:	52800004 	mov	w4, #0x0                   	// #0
    40001e9c:	17ffffe9 	b	40001e40 <cbvprintf+0xa80>
			if (value->ptr != NULL) {
    40001ea0:	f9405be0 	ldr	x0, [sp, #176]
    40001ea4:	b4002380 	cbz	x0, 40002314 <cbvprintf+0xf54>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    40001ea8:	910303e1 	add	x1, sp, #0xc0
    40001eac:	9102a7e3 	add	x3, sp, #0xa9
    40001eb0:	910243e2 	add	x2, sp, #0x90
    40001eb4:	97fffcf6 	bl	4000128c <encode_uint>
    40001eb8:	aa0003fa 	mov	x26, x0
				conv->altform_0c = true;
    40001ebc:	794187e0 	ldrh	w0, [sp, #194]
    40001ec0:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
    40001ec4:	52800004 	mov	w4, #0x0                   	// #0
				conv->altform_0c = true;
    40001ec8:	0a010000 	and	w0, w0, w1
    40001ecc:	528f0201 	mov	w1, #0x7810                	// #30736
    40001ed0:	2a010000 	orr	w0, w0, w1
    40001ed4:	790187e0 	strh	w0, [sp, #194]
				goto prec_int_pad0;
    40001ed8:	17ffffe2 	b	40001e60 <cbvprintf+0xaa0>
				store_count(conv, value->ptr, count);
    40001edc:	93407f60 	sxtw	x0, w27
	switch ((enum length_mod_enum)conv->length_mod) {
    40001ee0:	71001c3f 	cmp	w1, #0x7
				store_count(conv, value->ptr, count);
    40001ee4:	f9405be2 	ldr	x2, [sp, #176]
	switch ((enum length_mod_enum)conv->length_mod) {
    40001ee8:	54ffdcc8 	b.hi	40001a80 <cbvprintf+0x6c0>  // b.pmore
    40001eec:	b0000023 	adrp	x3, 40006000 <levels.0+0x10>
    40001ef0:	91025063 	add	x3, x3, #0x94
    40001ef4:	38614861 	ldrb	w1, [x3, w1, uxtw]
    40001ef8:	10000063 	adr	x3, 40001f04 <cbvprintf+0xb44>
    40001efc:	8b218861 	add	x1, x3, w1, sxtb #2
    40001f00:	d61f0020 	br	x1
		*(int *)dp = count;
    40001f04:	b9000040 	str	w0, [x2]
		break;
    40001f08:	17fffede 	b	40001a80 <cbvprintf+0x6c0>
		*(signed char *)dp = (signed char)count;
    40001f0c:	3900005b 	strb	w27, [x2]
		break;
    40001f10:	17fffedc 	b	40001a80 <cbvprintf+0x6c0>
		*(short *)dp = (short)count;
    40001f14:	7900005b 	strh	w27, [x2]
		break;
    40001f18:	17fffeda 	b	40001a80 <cbvprintf+0x6c0>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    40001f1c:	f9000040 	str	x0, [x2]
		break;
    40001f20:	17fffed8 	b	40001a80 <cbvprintf+0x6c0>
		*sign = '-';
    40001f24:	528005a4 	mov	w4, #0x2d                  	// #45
    40001f28:	17ffff72 	b	40001cf0 <cbvprintf+0x930>
		*sign = '+';
    40001f2c:	52800564 	mov	w4, #0x2b                  	// #43
    40001f30:	17ffff70 	b	40001cf0 <cbvprintf+0x930>
				*buf++ = 'i';
    40001f34:	528dcd20 	mov	w0, #0x6e69                	// #28265
    40001f38:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'f';
    40001f3c:	52800cc0 	mov	w0, #0x66                  	// #102
    40001f40:	17ffff78 	b	40001d20 <cbvprintf+0x960>
			if (isupper((int)c)) {
    40001f44:	540000a8 	b.hi	40001f58 <cbvprintf+0xb98>  // b.pmore
				*buf++ = 'N';
    40001f48:	528829c0 	mov	w0, #0x414e                	// #16718
    40001f4c:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'N';
    40001f50:	528009c0 	mov	w0, #0x4e                  	// #78
    40001f54:	17ffff73 	b	40001d20 <cbvprintf+0x960>
				*buf++ = 'n';
    40001f58:	528c2dc0 	mov	w0, #0x616e                	// #24942
    40001f5c:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'n';
    40001f60:	52800dc0 	mov	w0, #0x6e                  	// #110
    40001f64:	17ffff6f 	b	40001d20 <cbvprintf+0x960>
		c = 'f';
    40001f68:	52800cc2 	mov	w2, #0x66                  	// #102
    40001f6c:	710118bf 	cmp	w5, #0x46
    40001f70:	1a8210a5 	csel	w5, w5, w2, ne  // ne = any
	fract <<= EXPONENT_BITS;
    40001f74:	d375d002 	lsl	x2, x0, #11
	fract &= ~SIGN_MASK;
    40001f78:	f90047e2 	str	x2, [sp, #136]
	if ((expo | fract) != 0) {
    40001f7c:	93407c26 	sxtw	x6, w1
    40001f80:	aa0200c6 	orr	x6, x6, x2
    40001f84:	b4000f66 	cbz	x6, 40002170 <cbvprintf+0xdb0>
	bool is_subnormal = (expo == 0) && (fract != 0);
    40001f88:	7100003f 	cmp	w1, #0x0
		if (is_subnormal) {
    40001f8c:	fa400804 	ccmp	x0, #0x0, #0x4, eq  // eq = none
    40001f90:	54000c61 	b.ne	4000211c <cbvprintf+0xd5c>  // b.any
		fract |= BIT_63;
    40001f94:	f94047e2 	ldr	x2, [sp, #136]
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    40001f98:	510ff821 	sub	w1, w1, #0x3fe
		fract |= BIT_63;
    40001f9c:	52800000 	mov	w0, #0x0                   	// #0
    40001fa0:	52800006 	mov	w6, #0x0                   	// #0
    40001fa4:	b2410042 	orr	x2, x2, #0x8000000000000000
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40001fa8:	3200e7e7 	mov	w7, #0x33333333            	// #858993459
		fract |= BIT_63;
    40001fac:	f90047e2 	str	x2, [sp, #136]
	while (expo < -2) {
    40001fb0:	3100083f 	cmn	w1, #0x2
    40001fb4:	54000b8b 	b.lt	40002124 <cbvprintf+0xd64>  // b.tstop
    40001fb8:	34000040 	cbz	w0, 40001fc0 <cbvprintf+0xc00>
    40001fbc:	f90047e2 	str	x2, [sp, #136]
    40001fc0:	f94047e0 	ldr	x0, [sp, #136]
		decexp--;
    40001fc4:	52800002 	mov	w2, #0x0                   	// #0
	*v /= 5U;
    40001fc8:	d28000a7 	mov	x7, #0x5                   	// #5
	while (expo > 0) {
    40001fcc:	7100003f 	cmp	w1, #0x0
    40001fd0:	54000bec 	b.gt	4000214c <cbvprintf+0xd8c>
    40001fd4:	34000042 	cbz	w2, 40001fdc <cbvprintf+0xc1c>
    40001fd8:	f90047e0 	str	x0, [sp, #136]
	fract >>= (4 - expo);
    40001fdc:	52800080 	mov	w0, #0x4                   	// #4
    40001fe0:	4b010000 	sub	w0, w0, w1
    40001fe4:	f94047e1 	ldr	x1, [sp, #136]
    40001fe8:	9ac02421 	lsr	x1, x1, x0
	if ((c == 'g') || (c == 'G')) {
    40001fec:	121a78a0 	and	w0, w5, #0xffffffdf
    40001ff0:	12001c00 	and	w0, w0, #0xff
    40001ff4:	71011c1f 	cmp	w0, #0x47
    40001ff8:	54000c81 	b.ne	40002188 <cbvprintf+0xdc8>  // b.any
		if (decexp < (-4 + 1) || decexp > precision) {
    40001ffc:	6b06013f 	cmp	w9, w6
    40002000:	3a43a8c1 	ccmn	w6, #0x3, #0x1, ge  // ge = tcont
    40002004:	54000bca 	b.ge	4000217c <cbvprintf+0xdbc>  // b.tcont
				precision--;
    40002008:	7100013f 	cmp	w9, #0x0
			c += 'e' - 'g';  /* e or E */
    4000200c:	510008a5 	sub	w5, w5, #0x2
				precision--;
    40002010:	1a9fd7e0 	cset	w0, gt
			c += 'e' - 'g';  /* e or E */
    40002014:	12001ca5 	and	w5, w5, #0xff
				precision--;
    40002018:	4b000129 	sub	w9, w9, w0
		if (!conv->flag_hash && (precision > 0)) {
    4000201c:	721b007f 	tst	w3, #0x20
    40002020:	54000b41 	b.ne	40002188 <cbvprintf+0xdc8>  // b.any
    40002024:	7100013f 	cmp	w9, #0x0
    40002028:	1a9fd7e7 	cset	w7, gt
	if (c == 'f') {
    4000202c:	710198bf 	cmp	w5, #0x66
    40002030:	54000b01 	b.ne	40002190 <cbvprintf+0xdd0>  // b.any
		if (decimals < 0) {
    40002034:	2b060120 	adds	w0, w9, w6
    40002038:	54000ae5 	b.pl	40002194 <cbvprintf+0xdd4>  // b.nfrst
			decimals = 0;
    4000203c:	52800000 	mov	w0, #0x0                   	// #0
    40002040:	52800202 	mov	w2, #0x10                  	// #16
	*v /= 5U;
    40002044:	d28000a3 	mov	x3, #0x5                   	// #5
    40002048:	b90087e2 	str	w2, [sp, #132]
			decimals = 0;
    4000204c:	d2e10002 	mov	x2, #0x800000000000000     	// #576460752303423488
	while (decimals--) {
    40002050:	51000400 	sub	w0, w0, #0x1
    40002054:	3100041f 	cmn	w0, #0x1
    40002058:	54000a61 	b.ne	400021a4 <cbvprintf+0xde4>  // b.any
	fract += round;
    4000205c:	8b020021 	add	x1, x1, x2
	if (fract >= BIT64(60)) {
    40002060:	92fe0000 	mov	x0, #0xfffffffffffffff     	// #1152921504606846975
    40002064:	eb00003f 	cmp	x1, x0
    40002068:	54000a48 	b.hi	400021b0 <cbvprintf+0xdf0>  // b.pmore
	fract += round;
    4000206c:	f90047e1 	str	x1, [sp, #136]
	if (c == 'f') {
    40002070:	710198bf 	cmp	w5, #0x66
    40002074:	54000b21 	b.ne	400021d8 <cbvprintf+0xe18>  // b.any
		if (decexp > 0) {
    40002078:	710000df 	cmp	w6, #0x0
    4000207c:	54000a6d 	b.le	400021c8 <cbvprintf+0xe08>
	char *buf = bps;
    40002080:	910243f9 	add	x25, sp, #0x90
				*buf++ = _get_digit(&fract, &digit_count);
    40002084:	910213e1 	add	x1, sp, #0x84
    40002088:	910223e0 	add	x0, sp, #0x88
    4000208c:	97fffc70 	bl	4000124c <_get_digit>
    40002090:	38001720 	strb	w0, [x25], #1
			while (decexp > 0 && digit_count > 0) {
    40002094:	b94087e0 	ldr	w0, [sp, #132]
				decexp--;
    40002098:	510004c6 	sub	w6, w6, #0x1
			while (decexp > 0 && digit_count > 0) {
    4000209c:	7100001f 	cmp	w0, #0x0
    400020a0:	7a40c8c4 	ccmp	w6, #0x0, #0x4, gt
    400020a4:	54ffff0c 	b.gt	40002084 <cbvprintf+0xcc4>
			conv->pad0_value = decexp;
    400020a8:	b900c7e6 	str	w6, [sp, #196]
			decexp = 0;
    400020ac:	52800006 	mov	w6, #0x0                   	// #0
		if (conv->flag_hash || (precision > 0)) {
    400020b0:	794183e0 	ldrh	w0, [sp, #192]
    400020b4:	37280060 	tbnz	w0, #5, 400020c0 <cbvprintf+0xd00>
    400020b8:	7100013f 	cmp	w9, #0x0
    400020bc:	54000c2d 	b.le	40002240 <cbvprintf+0xe80>
			*buf++ = '.';
    400020c0:	aa1903e3 	mov	x3, x25
    400020c4:	528005c0 	mov	w0, #0x2e                  	// #46
		if (decexp < 0 && precision > 0) {
    400020c8:	710000df 	cmp	w6, #0x0
    400020cc:	7a40b924 	ccmp	w9, #0x0, #0x4, lt  // lt = tstop
			*buf++ = '.';
    400020d0:	38001460 	strb	w0, [x3], #1
		if (decexp < 0 && precision > 0) {
    400020d4:	5400016d 	b.le	40002100 <cbvprintf+0xd40>
			conv->pad0_value = -decexp;
    400020d8:	4b0603e1 	neg	w1, w6
			conv->pad_postdp = (conv->pad0_value > 0);
    400020dc:	39430be0 	ldrb	w0, [sp, #194]
			conv->pad0_value = -decexp;
    400020e0:	6b01013f 	cmp	w9, w1
    400020e4:	1a81b121 	csel	w1, w9, w1, lt  // lt = tstop
    400020e8:	b900c7e1 	str	w1, [sp, #196]
			conv->pad_postdp = (conv->pad0_value > 0);
    400020ec:	7100003f 	cmp	w1, #0x0
			precision -= conv->pad0_value;
    400020f0:	4b010129 	sub	w9, w9, w1
			conv->pad_postdp = (conv->pad0_value > 0);
    400020f4:	1a9fd7e1 	cset	w1, gt
    400020f8:	331b0020 	bfi	w0, w1, #5, #1
    400020fc:	39030be0 	strb	w0, [sp, #194]
			*buf++ = '.';
    40002100:	aa0303f9 	mov	x25, x3
    40002104:	1400004a 	b	4000222c <cbvprintf+0xe6c>
				expo--;
    40002108:	51000421 	sub	w1, w1, #0x1
			while (((fract <<= 1) & BIT_63) == 0) {
    4000210c:	d37ff842 	lsl	x2, x2, #1
    40002110:	b6ffffc2 	tbz	x2, #63, 40002108 <cbvprintf+0xd48>
    40002114:	f90047e2 	str	x2, [sp, #136]
    40002118:	17ffff9f 	b	40001f94 <cbvprintf+0xbd4>
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    4000211c:	52800001 	mov	w1, #0x0                   	// #0
    40002120:	17fffffb 	b	4000210c <cbvprintf+0xd4c>
			expo++;
    40002124:	2a0103e8 	mov	w8, w1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40002128:	eb4284ff 	cmp	x7, x2, lsr #33
			expo++;
    4000212c:	11000421 	add	w1, w1, #0x1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40002130:	d341fc42 	lsr	x2, x2, #1
    40002134:	54ffff89 	b.ls	40002124 <cbvprintf+0xd64>  // b.plast
		fract *= 5U;
    40002138:	8b020842 	add	x2, x2, x2, lsl #2
		expo++;
    4000213c:	11000901 	add	w1, w8, #0x2
		decexp--;
    40002140:	510004c6 	sub	w6, w6, #0x1
    40002144:	52800020 	mov	w0, #0x1                   	// #1
    40002148:	17ffff9a 	b	40001fb0 <cbvprintf+0xbf0>
		fract += 2;
    4000214c:	91000800 	add	x0, x0, #0x2
		expo--;
    40002150:	51000421 	sub	w1, w1, #0x1
		decexp++;
    40002154:	110004c6 	add	w6, w6, #0x1
    40002158:	52800022 	mov	w2, #0x1                   	// #1
	*v /= 5U;
    4000215c:	9ac70800 	udiv	x0, x0, x7
			fract <<= 1;
    40002160:	d37ff800 	lsl	x0, x0, #1
			expo--;
    40002164:	51000421 	sub	w1, w1, #0x1
		} while (!(fract & BIT_63));
    40002168:	b6ffffc0 	tbz	x0, #63, 40002160 <cbvprintf+0xda0>
    4000216c:	17ffff98 	b	40001fcc <cbvprintf+0xc0c>
    40002170:	52800006 	mov	w6, #0x0                   	// #0
    40002174:	52800001 	mov	w1, #0x0                   	// #0
    40002178:	17ffff99 	b	40001fdc <cbvprintf+0xc1c>
			precision -= decexp;
    4000217c:	4b060129 	sub	w9, w9, w6
			c = 'f';
    40002180:	52800cc5 	mov	w5, #0x66                  	// #102
    40002184:	17ffffa6 	b	4000201c <cbvprintf+0xc5c>
	bool prune_zero = false;
    40002188:	52800007 	mov	w7, #0x0                   	// #0
    4000218c:	17ffffa8 	b	4000202c <cbvprintf+0xc6c>
		decimals = precision + 1;
    40002190:	11000520 	add	w0, w9, #0x1
	if (decimals > 16) {
    40002194:	7100401f 	cmp	w0, #0x10
    40002198:	52800202 	mov	w2, #0x10                  	// #16
    4000219c:	1a82d000 	csel	w0, w0, w2, le
    400021a0:	17ffffa8 	b	40002040 <cbvprintf+0xc80>
	*v >>= 1;
    400021a4:	d341fc42 	lsr	x2, x2, #1
	*v /= 5U;
    400021a8:	9ac30842 	udiv	x2, x2, x3
}
    400021ac:	17ffffa9 	b	40002050 <cbvprintf+0xc90>
	*v >>= 1;
    400021b0:	d341fc21 	lsr	x1, x1, #1
	*v /= 5U;
    400021b4:	d28000a0 	mov	x0, #0x5                   	// #5
		decexp++;
    400021b8:	110004c6 	add	w6, w6, #0x1
	*v /= 5U;
    400021bc:	9ac00821 	udiv	x1, x1, x0
    400021c0:	f90047e1 	str	x1, [sp, #136]
		decexp++;
    400021c4:	17ffffab 	b	40002070 <cbvprintf+0xcb0>
			*buf++ = '0';
    400021c8:	52800600 	mov	w0, #0x30                  	// #48
    400021cc:	910247f9 	add	x25, sp, #0x91
    400021d0:	390243e0 	strb	w0, [sp, #144]
    400021d4:	17ffffb7 	b	400020b0 <cbvprintf+0xcf0>
		*buf = _get_digit(&fract, &digit_count);
    400021d8:	910213e1 	add	x1, sp, #0x84
    400021dc:	910223e0 	add	x0, sp, #0x88
    400021e0:	97fffc1b 	bl	4000124c <_get_digit>
    400021e4:	12001c01 	and	w1, w0, #0xff
			decexp--;
    400021e8:	7100c03f 	cmp	w1, #0x30
		*buf = _get_digit(&fract, &digit_count);
    400021ec:	390243e0 	strb	w0, [sp, #144]
			decexp--;
    400021f0:	1a9f07e0 	cset	w0, ne  // ne = any
    400021f4:	4b0000c6 	sub	w6, w6, w0
		if (conv->flag_hash || (precision > 0)) {
    400021f8:	794183e0 	ldrh	w0, [sp, #192]
    400021fc:	37280060 	tbnz	w0, #5, 40002208 <cbvprintf+0xe48>
    40002200:	7100013f 	cmp	w9, #0x0
    40002204:	540006cd 	b.le	400022dc <cbvprintf+0xf1c>
			*buf++ = '.';
    40002208:	528005c0 	mov	w0, #0x2e                  	// #46
    4000220c:	91024be3 	add	x3, sp, #0x92
    40002210:	390247e0 	strb	w0, [sp, #145]
    40002214:	17ffffbb 	b	40002100 <cbvprintf+0xd40>
		precision--;
    40002218:	51000529 	sub	w9, w9, #0x1
		*buf++ = _get_digit(&fract, &digit_count);
    4000221c:	910213e1 	add	x1, sp, #0x84
    40002220:	910223e0 	add	x0, sp, #0x88
    40002224:	97fffc0a 	bl	4000124c <_get_digit>
    40002228:	38001720 	strb	w0, [x25], #1
	while (precision > 0 && digit_count > 0) {
    4000222c:	7100013f 	cmp	w9, #0x0
    40002230:	5400008d 	b.le	40002240 <cbvprintf+0xe80>
    40002234:	b94087e0 	ldr	w0, [sp, #132]
    40002238:	7100001f 	cmp	w0, #0x0
    4000223c:	54fffeec 	b.gt	40002218 <cbvprintf+0xe58>
	if (prune_zero) {
    40002240:	35000527 	cbnz	w7, 400022e4 <cbvprintf+0xf24>
	conv->pad0_pre_exp = precision;
    40002244:	b900cbe9 	str	w9, [sp, #200]
	if ((c == 'e') || (c == 'E')) {
    40002248:	121a78a0 	and	w0, w5, #0xffffffdf
    4000224c:	12001c00 	and	w0, w0, #0xff
    40002250:	7101141f 	cmp	w0, #0x45
    40002254:	540002e1 	b.ne	400022b0 <cbvprintf+0xef0>  // b.any
		*buf++ = c;
    40002258:	aa1903e1 	mov	x1, x25
    4000225c:	38002425 	strb	w5, [x1], #2
		if (decexp < 0) {
    40002260:	36f80526 	tbz	w6, #31, 40002304 <cbvprintf+0xf44>
			decexp = -decexp;
    40002264:	4b0603e6 	neg	w6, w6
			*buf++ = '-';
    40002268:	528005a0 	mov	w0, #0x2d                  	// #45
    4000226c:	39000720 	strb	w0, [x25, #1]
		if (decexp >= 100) {
    40002270:	71018cdf 	cmp	w6, #0x63
    40002274:	540000ed 	b.le	40002290 <cbvprintf+0xed0>
			*buf++ = (decexp / 100) + '0';
    40002278:	52800c80 	mov	w0, #0x64                  	// #100
    4000227c:	91000f21 	add	x1, x25, #0x3
    40002280:	1ac00cc2 	sdiv	w2, w6, w0
			decexp %= 100;
    40002284:	1b009846 	msub	w6, w2, w0, w6
			*buf++ = (decexp / 100) + '0';
    40002288:	1100c045 	add	w5, w2, #0x30
    4000228c:	39000b25 	strb	w5, [x25, #2]
		*buf++ = (decexp / 10) + '0';
    40002290:	52800142 	mov	w2, #0xa                   	// #10
    40002294:	aa0103f9 	mov	x25, x1
    40002298:	1ac20cc0 	sdiv	w0, w6, w2
    4000229c:	1100c005 	add	w5, w0, #0x30
		*buf++ = (decexp % 10) + '0';
    400022a0:	1b029800 	msub	w0, w0, w2, w6
		*buf++ = (decexp / 10) + '0';
    400022a4:	38002725 	strb	w5, [x25], #2
		*buf++ = (decexp % 10) + '0';
    400022a8:	1100c000 	add	w0, w0, #0x30
    400022ac:	39000420 	strb	w0, [x1, #1]
		|| (conv->pad0_pre_exp > 0);
    400022b0:	b940c7e0 	ldr	w0, [sp, #196]
    400022b4:	7100001f 	cmp	w0, #0x0
    400022b8:	540002ac 	b.gt	4000230c <cbvprintf+0xf4c>
    400022bc:	b940cbe0 	ldr	w0, [sp, #200]
    400022c0:	7100001f 	cmp	w0, #0x0
    400022c4:	1a9fd7e1 	cset	w1, gt
	conv->pad_fp = (conv->pad0_value > 0)
    400022c8:	39430be0 	ldrb	w0, [sp, #194]
    400022cc:	331a0020 	bfi	w0, w1, #6, #1
    400022d0:	39030be0 	strb	w0, [sp, #194]
	*buf = 0;
    400022d4:	3900033f 	strb	wzr, [x25]
	return bps;
    400022d8:	17fffeb4 	b	40001da8 <cbvprintf+0x9e8>
		if (*buf++ != '0') {
    400022dc:	910247f9 	add	x25, sp, #0x91
    400022e0:	17ffffd8 	b	40002240 <cbvprintf+0xe80>
		conv->pad0_pre_exp = 0;
    400022e4:	b900cbff 	str	wzr, [sp, #200]
		while (*--buf == '0') {
    400022e8:	aa1903e1 	mov	x1, x25
    400022ec:	385fff20 	ldrb	w0, [x25, #-1]!
    400022f0:	7100c01f 	cmp	w0, #0x30
    400022f4:	54ffffa0 	b.eq	400022e8 <cbvprintf+0xf28>  // b.none
		if (*buf != '.') {
    400022f8:	7100b81f 	cmp	w0, #0x2e
    400022fc:	9a810339 	csel	x25, x25, x1, eq  // eq = none
    40002300:	17ffffd2 	b	40002248 <cbvprintf+0xe88>
			*buf++ = '+';
    40002304:	52800560 	mov	w0, #0x2b                  	// #43
    40002308:	17ffffd9 	b	4000226c <cbvprintf+0xeac>
		|| (conv->pad0_pre_exp > 0);
    4000230c:	52800021 	mov	w1, #0x1                   	// #1
    40002310:	17ffffee 	b	400022c8 <cbvprintf+0xf08>
			bpe = bps + 5;
    40002314:	90000023 	adrp	x3, 40006000 <levels.0+0x10>
    40002318:	9102bc79 	add	x25, x3, #0xaf
			bps = "(nil)";
    4000231c:	90000022 	adrp	x2, 40006000 <levels.0+0x10>
    40002320:	9102a85a 	add	x26, x2, #0xaa
		char sign = 0;
    40002324:	52800004 	mov	w4, #0x0                   	// #0
    40002328:	17fffea1 	b	40001dac <cbvprintf+0x9ec>
		} else if (conv->altform_0) {
    4000232c:	361fd4c5 	tbz	w5, #3, 40001dc4 <cbvprintf+0xa04>
			nj_len += 1U;
    40002330:	91000400 	add	x0, x0, #0x1
    40002334:	17fffea4 	b	40001dc4 <cbvprintf+0xa04>
					OUTC(pad);
    40002338:	b90073e5 	str	w5, [sp, #112]
    4000233c:	aa1503e1 	mov	x1, x21
    40002340:	b9007fe4 	str	w4, [sp, #124]
    40002344:	2a0503e0 	mov	w0, w5
    40002348:	d63f0280 	blr	x20
    4000234c:	37f80aa0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40002350:	b94073e5 	ldr	w5, [sp, #112]
    40002354:	9100077b 	add	x27, x27, #0x1
    40002358:	b9407fe4 	ldr	w4, [sp, #124]
				while (width-- > 0) {
    4000235c:	2a1703e0 	mov	w0, w23
    40002360:	510006f7 	sub	w23, w23, #0x1
    40002364:	7100001f 	cmp	w0, #0x0
    40002368:	54fffe8c 	b.gt	40002338 <cbvprintf+0xf78>
		if (sign != 0) {
    4000236c:	340000c4 	cbz	w4, 40002384 <cbvprintf+0xfc4>
			OUTC(sign);
    40002370:	aa1503e1 	mov	x1, x21
    40002374:	2a0403e0 	mov	w0, w4
    40002378:	d63f0280 	blr	x20
    4000237c:	37f80920 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40002380:	9100077b 	add	x27, x27, #0x1
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    40002384:	39430be0 	ldrb	w0, [sp, #194]
    40002388:	36300e00 	tbz	w0, #6, 40002548 <cbvprintf+0x1188>
			if (conv->specifier_a) {
    4000238c:	79c183e0 	ldrsh	w0, [sp, #192]
    40002390:	cb1a037b 	sub	x27, x27, x26
    40002394:	37f80460 	tbnz	w0, #31, 40002420 <cbvprintf+0x1060>
				while (isdigit((int)*cp)) {
    40002398:	39400340 	ldrb	w0, [x26]
    4000239c:	8b1b0344 	add	x4, x26, x27
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    400023a0:	5100c001 	sub	w1, w0, #0x30
    400023a4:	7100243f 	cmp	w1, #0x9
    400023a8:	54000749 	b.ls	40002490 <cbvprintf+0x10d0>  // b.plast
				if (!conv->pad_postdp) {
    400023ac:	f94063e0 	ldr	x0, [sp, #192]
				pad_len = conv->pad0_value;
    400023b0:	b940c7fb 	ldr	w27, [sp, #196]
				if (!conv->pad_postdp) {
    400023b4:	720b001f 	tst	w0, #0x200000
    400023b8:	540000a1 	b.ne	400023cc <cbvprintf+0x100c>  // b.any
					while (pad_len-- > 0) {
    400023bc:	51000765 	sub	w5, w27, #0x1
    400023c0:	7100037f 	cmp	w27, #0x0
    400023c4:	540007cc 	b.gt	400024bc <cbvprintf+0x10fc>
    400023c8:	2a0503fb 	mov	w27, w5
				if (*cp == '.') {
    400023cc:	39400340 	ldrb	w0, [x26]
    400023d0:	7100b81f 	cmp	w0, #0x2e
    400023d4:	54000141 	b.ne	400023fc <cbvprintf+0x103c>  // b.any
    400023d8:	f9003be4 	str	x4, [sp, #112]
					OUTC(*cp++);
    400023dc:	aa1503e1 	mov	x1, x21
    400023e0:	d63f0280 	blr	x20
						OUTC('0');
    400023e4:	37f805e0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    400023e8:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    400023ec:	7100037f 	cmp	w27, #0x0
						OUTC('0');
    400023f0:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    400023f4:	540007ac 	b.gt	400024e8 <cbvprintf+0x1128>
					OUTC(*cp++);
    400023f8:	9100075a 	add	x26, x26, #0x1
    400023fc:	cb1a009b 	sub	x27, x4, x26
    40002400:	14000044 	b	40002510 <cbvprintf+0x1150>
				char pad = ' ';
    40002404:	52800405 	mov	w5, #0x20                  	// #32
					pad = '0';
    40002408:	2a1703e0 	mov	w0, w23
    4000240c:	17ffffd5 	b	40002360 <cbvprintf+0xfa0>
					OUTC(*cp++);
    40002410:	9100075a 	add	x26, x26, #0x1
    40002414:	aa1503e1 	mov	x1, x21
    40002418:	d63f0280 	blr	x20
    4000241c:	37f80420 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
				while (*cp != 'p') {
    40002420:	39400340 	ldrb	w0, [x26]
    40002424:	8b1b0341 	add	x1, x26, x27
    40002428:	7101c01f 	cmp	w0, #0x70
    4000242c:	54ffff21 	b.ne	40002410 <cbvprintf+0x1050>  // b.any
			while (pad_len-- > 0) {
    40002430:	b940cbe4 	ldr	w4, [sp, #200]
    40002434:	aa0103fb 	mov	x27, x1
    40002438:	0b010084 	add	w4, w4, w1
    4000243c:	4b1b0080 	sub	w0, w4, w27
    40002440:	7100001f 	cmp	w0, #0x0
    40002444:	5400072c 	b.gt	40002528 <cbvprintf+0x1168>
			OUTS(bps, bpe);
    40002448:	aa1903e3 	mov	x3, x25
    4000244c:	aa1a03e2 	mov	x2, x26
    40002450:	aa1503e1 	mov	x1, x21
    40002454:	aa1403e0 	mov	x0, x20
    40002458:	97fffbbe 	bl	40001350 <outs>
    4000245c:	37f80220 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40002460:	8b20c360 	add	x0, x27, w0, sxtw
			while (pad_len-- > 0) {
    40002464:	aa0003fb 	mov	x27, x0
    40002468:	0b0002f7 	add	w23, w23, w0
		while (width > 0) {
    4000246c:	4b1b02e0 	sub	w0, w23, w27
    40002470:	7100001f 	cmp	w0, #0x0
    40002474:	54ffb06d 	b.le	40001a80 <cbvprintf+0x6c0>
			OUTC(' ');
    40002478:	aa1503e1 	mov	x1, x21
    4000247c:	52800400 	mov	w0, #0x20                  	// #32
    40002480:	d63f0280 	blr	x20
    40002484:	37f800e0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40002488:	9100077b 	add	x27, x27, #0x1
			--width;
    4000248c:	17fffff8 	b	4000246c <cbvprintf+0x10ac>
					OUTC(*cp++);
    40002490:	9100075a 	add	x26, x26, #0x1
    40002494:	aa1503e1 	mov	x1, x21
    40002498:	d63f0280 	blr	x20
    4000249c:	36fff7e0 	tbz	w0, #31, 40002398 <cbvprintf+0xfd8>
#undef OUTS
#undef OUTC
}
    400024a0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400024a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400024a8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400024ac:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400024b0:	a94573fb 	ldp	x27, x28, [sp, #80]
    400024b4:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    400024b8:	d65f03c0 	ret
    400024bc:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    400024c0:	aa1503e1 	mov	x1, x21
    400024c4:	b9007fe5 	str	w5, [sp, #124]
    400024c8:	52800600 	mov	w0, #0x30                  	// #48
    400024cc:	d63f0280 	blr	x20
    400024d0:	37fffe80 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    400024d4:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    400024d8:	b9407fe5 	ldr	w5, [sp, #124]
						OUTC('0');
    400024dc:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    400024e0:	2a0503fb 	mov	w27, w5
    400024e4:	17ffffb6 	b	400023bc <cbvprintf+0xffc>
    400024e8:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    400024ec:	aa1503e1 	mov	x1, x21
    400024f0:	5100077b 	sub	w27, w27, #0x1
    400024f4:	52800600 	mov	w0, #0x30                  	// #48
    400024f8:	d63f0280 	blr	x20
    400024fc:	17ffffba 	b	400023e4 <cbvprintf+0x1024>
					OUTC(*cp++);
    40002500:	9100075a 	add	x26, x26, #0x1
    40002504:	aa1503e1 	mov	x1, x21
    40002508:	d63f0280 	blr	x20
    4000250c:	37fffca0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
				while (isdigit((int)*cp)) {
    40002510:	39400340 	ldrb	w0, [x26]
    40002514:	8b1b0341 	add	x1, x26, x27
    40002518:	5100c004 	sub	w4, w0, #0x30
    4000251c:	7100249f 	cmp	w4, #0x9
    40002520:	54ffff09 	b.ls	40002500 <cbvprintf+0x1140>  // b.plast
    40002524:	17ffffc3 	b	40002430 <cbvprintf+0x1070>
    40002528:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    4000252c:	aa1503e1 	mov	x1, x21
    40002530:	52800600 	mov	w0, #0x30                  	// #48
    40002534:	d63f0280 	blr	x20
    40002538:	37fffb40 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    4000253c:	b94073e4 	ldr	w4, [sp, #112]
    40002540:	9100077b 	add	x27, x27, #0x1
    40002544:	17ffffbe 	b	4000243c <cbvprintf+0x107c>
			if (conv->altform_0c | conv->altform_0) {
    40002548:	f94063e0 	ldr	x0, [sp, #192]
    4000254c:	d3545001 	ubfx	x1, x0, #20, #1
    40002550:	d3534c00 	ubfx	x0, x0, #19, #1
    40002554:	2a000020 	orr	w0, w1, w0
    40002558:	360000c0 	tbz	w0, #0, 40002570 <cbvprintf+0x11b0>
				OUTC('0');
    4000255c:	aa1503e1 	mov	x1, x21
    40002560:	52800600 	mov	w0, #0x30                  	// #48
    40002564:	d63f0280 	blr	x20
    40002568:	37fff9c0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    4000256c:	9100077b 	add	x27, x27, #0x1
			if (conv->altform_0c) {
    40002570:	39430be0 	ldrb	w0, [sp, #194]
    40002574:	362000c0 	tbz	w0, #4, 4000258c <cbvprintf+0x11cc>
				OUTC(conv->specifier);
    40002578:	39430fe0 	ldrb	w0, [sp, #195]
    4000257c:	aa1503e1 	mov	x1, x21
    40002580:	d63f0280 	blr	x20
    40002584:	37fff8e0 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    40002588:	9100077b 	add	x27, x27, #0x1
			while (pad_len-- > 0) {
    4000258c:	b940c7e4 	ldr	w4, [sp, #196]
    40002590:	0b1b0084 	add	w4, w4, w27
    40002594:	4b1b0080 	sub	w0, w4, w27
    40002598:	7100001f 	cmp	w0, #0x0
    4000259c:	54fff56d 	b.le	40002448 <cbvprintf+0x1088>
    400025a0:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    400025a4:	aa1503e1 	mov	x1, x21
    400025a8:	52800600 	mov	w0, #0x30                  	// #48
    400025ac:	d63f0280 	blr	x20
    400025b0:	37fff780 	tbnz	w0, #31, 400024a0 <cbvprintf+0x10e0>
    400025b4:	b94073e4 	ldr	w4, [sp, #112]
    400025b8:	9100077b 	add	x27, x27, #0x1
    400025bc:	17fffff6 	b	40002594 <cbvprintf+0x11d4>

00000000400025c0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    400025c0:	d65f03c0 	ret

00000000400025c4 <z_arm64_el3_plat_init>:
	uint64_t reg = 0;

	reg = (ICC_SRE_ELx_DFB_BIT | ICC_SRE_ELx_DIB_BIT |
	       ICC_SRE_ELx_SRE_BIT | ICC_SRE_EL3_EN_BIT);

	write_sysreg(reg, ICC_SRE_EL3);
    400025c4:	d28001e0 	mov	x0, #0xf                   	// #15
    400025c8:	d51ecca0 	msr	s3_6_c12_c12_5, x0
}
    400025cc:	d65f03c0 	ret

00000000400025d0 <arch_cpu_idle>:
#ifdef CONFIG_TRACING
	stp	xzr, x30, [sp, #-16]!
	bl	sys_trace_idle
	ldp	xzr, x30, [sp], #16
#endif
	dsb	sy
    400025d0:	d5033f9f 	dsb	sy
	wfi
    400025d4:	d503207f 	wfi
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    400025d8:	d50342ff 	msr	daifclr, #0x2
	ret
    400025dc:	d65f03c0 	ret

00000000400025e0 <z_arm64_fatal_error>:

	return false;
}

void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf)
{
    400025e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	uint64_t esr = 0;
	uint64_t elr = 0;
	uint64_t far = 0;
	uint64_t el;

	if (reason != K_ERR_SPURIOUS_IRQ) {
    400025e4:	7100041f 	cmp	w0, #0x1
{
    400025e8:	910003fd 	mov	x29, sp
	if (reason != K_ERR_SPURIOUS_IRQ) {
    400025ec:	540000e0 	b.eq	40002608 <z_arm64_fatal_error+0x28>  // b.none
MAKE_REG_HELPER(cnthp_ctl_el2);
MAKE_REG_HELPER(cntv_ctl_el0)
MAKE_REG_HELPER(cntv_cval_el0)
MAKE_REG_HELPER(cntvct_el0);
MAKE_REG_HELPER(cntvoff_el2);
MAKE_REG_HELPER(currentel);
    400025f0:	d5384242 	mrs	x2, currentel
		el = read_currentel();

		switch (GET_EL(el)) {
    400025f4:	d3420c42 	ubfx	x2, x2, #2, #2
    400025f8:	f100045f 	cmp	x2, #0x1
    400025fc:	54000080 	b.eq	4000260c <z_arm64_fatal_error+0x2c>  // b.none
    40002600:	f1000c5f 	cmp	x2, #0x3
    40002604:	540000c0 	b.eq	4000261c <z_arm64_fatal_error+0x3c>  // b.none
	if (esf != NULL) {
		esf_dump(esf);
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

	z_fatal_error(reason, esf);
    40002608:	9400057a 	bl	40003bf0 <z_fatal_error>

MAKE_REG_HELPER_EL123(actlr)
MAKE_REG_HELPER_EL123(cpacr)
MAKE_REG_HELPER_EL123(cptr)
MAKE_REG_HELPER_EL123(elr)
MAKE_REG_HELPER_EL123(esr)
    4000260c:	d5385202 	mrs	x2, esr_el1
MAKE_REG_HELPER_EL123(far)
    40002610:	d5386002 	mrs	x2, far_el1
MAKE_REG_HELPER_EL123(elr)
    40002614:	d5384022 	mrs	x2, elr_el1
			break;
    40002618:	17fffffc 	b	40002608 <z_arm64_fatal_error+0x28>
MAKE_REG_HELPER_EL123(esr)
    4000261c:	d53e5202 	mrs	x2, esr_el3
MAKE_REG_HELPER_EL123(far)
    40002620:	d53e6002 	mrs	x2, far_el3
MAKE_REG_HELPER_EL123(elr)
    40002624:	d53e4022 	mrs	x2, elr_el3
			break;
    40002628:	17fffff8 	b	40002608 <z_arm64_fatal_error+0x28>

000000004000262c <z_arm64_do_kernel_oops>:
 * (e.g. kernel oops, panic, etc.).
 *
 * @param esf exception frame
 */
void z_arm64_do_kernel_oops(z_arch_esf_t *esf)
{
    4000262c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40002630:	aa0003e1 	mov	x1, x0
    40002634:	910003fd 	mov	x29, sp
		reason != K_ERR_STACK_CHK_FAIL) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_arm64_fatal_error(reason, esf);
    40002638:	b9404000 	ldr	w0, [x0, #64]
    4000263c:	97ffffe9 	bl	400025e0 <z_arm64_fatal_error>

0000000040002640 <z_arm64_interrupt_init>:
{
#ifdef CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER
	/* Invoke SoC-specific interrupt controller initialisation */
	z_soc_irq_init();
#endif
}
    40002640:	d65f03c0 	ret

0000000040002644 <arch_irq_enable>:
 * `include/arch/arm64/irq.h`.
 */

void arch_irq_enable(unsigned int irq)
{
	arm_gic_irq_enable(irq);
    40002644:	140003a3 	b	400034d0 <arm_gic_irq_enable>

0000000040002648 <z_arm64_irq_priority_set>:
	return arm_gic_irq_is_enabled(irq);
}

void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	arm_gic_irq_set_priority(irq, prio, flags);
    40002648:	14000373 	b	40003414 <arm_gic_irq_set_priority>

000000004000264c <z_irq_spurious>:

void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm64_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    4000264c:	d2800001 	mov	x1, #0x0                   	// #0
    40002650:	52800020 	mov	w0, #0x1                   	// #1
    40002654:	17ffffe3 	b	400025e0 <z_arm64_fatal_error>

0000000040002658 <z_arm64_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm64_prep_c(void)
{
    40002658:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(tpidrro_el0);
    4000265c:	b0000060 	adrp	x0, 4000f000 <z_idle_threads>
    40002660:	91188000 	add	x0, x0, #0x620
    40002664:	910003fd 	mov	x29, sp
    40002668:	d51bd060 	msr	tpidrro_el0, x0
	uint64_t *p = (uint64_t *)__bss_start;
    4000266c:	b0000020 	adrp	x0, 40007000 <xlat_tables>
    40002670:	91000000 	add	x0, x0, #0x0
	while (p < end) {
    40002674:	b00002a1 	adrp	x1, 40057000 <z_page_frames+0x47953>
    40002678:	911ac021 	add	x1, x1, #0x6b0
    4000267c:	eb01001f 	cmp	x0, x1
    40002680:	540000a3 	b.cc	40002694 <z_arm64_prep_c+0x3c>  // b.lo, b.ul, b.last

	z_arm64_bss_zero();
#ifdef CONFIG_XIP
	z_data_copy();
#endif
	z_arm64_mm_init(true);
    40002684:	52800020 	mov	w0, #0x1                   	// #1
    40002688:	94000223 	bl	40002f14 <z_arm64_mm_init>
	z_arm64_interrupt_init();
    4000268c:	97ffffed 	bl	40002640 <z_arm64_interrupt_init>
	z_cstart();
    40002690:	940005a5 	bl	40003d24 <z_cstart>
		*p++ = 0U;
    40002694:	f800841f 	str	xzr, [x0], #8
    40002698:	17fffff9 	b	4000267c <z_arm64_prep_c+0x24>

000000004000269c <z_arm64_el3_plat_prep_c>:
	ret
    4000269c:	d65f03c0 	ret

00000000400026a0 <z_arm64_el2_plat_prep_c>:
	ret
    400026a0:	d65f03c0 	ret

00000000400026a4 <z_arm64_el1_plat_prep_c>:
	ret
    400026a4:	d65f03c0 	ret

00000000400026a8 <el3_get_next_el>:
MAKE_REG_HELPER(id_aa64pfr0_el1);
    400026a8:	d5380400 	mrs	x0, id_aa64pfr0_el1
	EL3_TO_EL1_SKIP_EL2
};

static inline enum el3_next_el el3_get_next_el(void)
{
	if (!is_el_implemented(2)) {
    400026ac:	f2780c1f 	tst	x0, #0xf00
    400026b0:	540000c0 	b.eq	400026c8 <el3_get_next_el+0x20>  // b.none
    400026b4:	d5380400 	mrs	x0, id_aa64pfr0_el1
		 * implemented and the value of the SCR_EL3.NS bit is 0 if
		 * ARMv8.4-SecEL2 is not implemented" (D1.11.2 from ARM DDI 0487E.a)
		 */
		return EL3_TO_EL1_SKIP_EL2;
	} else {
		return EL3_TO_EL2;
    400026b8:	f25c0c1f 	tst	x0, #0xf000000000
    400026bc:	1a9f17e0 	cset	w0, eq  // eq = none
    400026c0:	531f7800 	lsl	w0, w0, #1
	}
}
    400026c4:	d65f03c0 	ret
		return EL3_TO_EL1_NO_EL2;
    400026c8:	52800020 	mov	w0, #0x1                   	// #1
    400026cc:	17fffffe 	b	400026c4 <el3_get_next_el+0x1c>

00000000400026d0 <z_arm64_el_highest_plat_init>:
}
    400026d0:	d65f03c0 	ret

00000000400026d4 <z_arm64_el2_plat_init>:
    400026d4:	d65f03c0 	ret

00000000400026d8 <z_arm64_el1_plat_init>:
    400026d8:	d65f03c0 	ret

00000000400026dc <z_arm64_el_highest_init>:
{
    400026dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400026e0:	910003fd 	mov	x29, sp
    400026e4:	d5380400 	mrs	x0, id_aa64pfr0_el1
static inline bool is_el_highest_implemented(void)
{
	uint32_t el_highest;
	uint32_t curr_el;

	el_highest = read_id_aa64pfr0_el1() & 0xFFFF;
    400026e8:	12003c00 	and	w0, w0, #0xffff
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    400026ec:	5ac01000 	clz	w0, w0
MAKE_REG_HELPER(currentel);
    400026f0:	d5384241 	mrs	x1, currentel
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    400026f4:	528003e2 	mov	w2, #0x1f                  	// #31
    400026f8:	4b000040 	sub	w0, w2, w0

	curr_el = GET_EL(read_currentel());
    400026fc:	53020c21 	ubfx	w1, w1, #2, #2

	if (curr_el < el_highest)
    40002700:	6b40083f 	cmp	w1, w0, lsr #2
    40002704:	54000083 	b.cc	40002714 <z_arm64_el_highest_init+0x38>  // b.lo, b.ul, b.last
MAKE_REG_HELPER(cntfrq_el0);
    40002708:	d2959400 	mov	x0, #0xaca0                	// #44192
    4000270c:	f2a07720 	movk	x0, #0x3b9, lsl #16
    40002710:	d51be000 	msr	cntfrq_el0, x0
	z_arm64_el_highest_plat_init();
    40002714:	97ffffef 	bl	400026d0 <z_arm64_el_highest_plat_init>
	isb();
    40002718:	d5033fdf 	isb
}
    4000271c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40002720:	d65f03c0 	ret

0000000040002724 <z_arm64_el2_init>:
		z_arm64_el2_init();
	}
}

void z_arm64_el2_init(void)
{
    40002724:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40002728:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(sctlr)
    4000272c:	d53c1000 	mrs	x0, sctlr_el2
	uint64_t reg;

	reg = read_sctlr_el2();
	reg |= (SCTLR_EL2_RES1 |	/* RES1 */
    40002730:	d2830701 	mov	x1, #0x1838                	// #6200
    40002734:	f2a618a1 	movk	x1, #0x30c5, lsl #16
    40002738:	aa010000 	orr	x0, x0, x1
    4000273c:	d51c1000 	msr	sctlr_el2, x0
MAKE_REG_HELPER(hcr_el2);
    40002740:	d53c1100 	mrs	x0, hcr_el2
		SCTLR_I_BIT |		/* Enable i-cache */
		SCTLR_SA_BIT);		/* Enable SP alignment check */
	write_sctlr_el2(reg);

	reg = read_hcr_el2();
	reg |= HCR_RW_BIT;		/* EL1 Execution state is AArch64 */
    40002744:	b2610000 	orr	x0, x0, #0x80000000
    40002748:	d51c1100 	msr	hcr_el2, x0
MAKE_REG_HELPER_EL123(cptr)
    4000274c:	d2865fe0 	mov	x0, #0x32ff                	// #13055
    40002750:	d51c1140 	msr	cptr_el2, x0
MAKE_REG_HELPER(cntvoff_el2);
    40002754:	d51ce07f 	msr	cntvoff_el2, xzr
MAKE_REG_HELPER(cnthctl_el2);
    40002758:	d51ce11f 	msr	cnthctl_el2, xzr
MAKE_REG_HELPER(cnthp_ctl_el2);
    4000275c:	d51ce23f 	msr	cnthp_ctl_el2, xzr
	/*
	 * Enable this if/when we use the hypervisor timer.
	 * write_cnthp_cval_el2(~(uint64_t)0);
	 */

	z_arm64_el2_plat_init();
    40002760:	97ffffdd 	bl	400026d4 <z_arm64_el2_plat_init>

	isb();
    40002764:	d5033fdf 	isb
}
    40002768:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000276c:	d65f03c0 	ret

0000000040002770 <z_arm64_el3_init>:
{
    40002770:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    40002774:	d0ffffe0 	adrp	x0, 40000000 <__text_region_start>
    40002778:	91200000 	add	x0, x0, #0x800
    4000277c:	910003fd 	mov	x29, sp
    40002780:	d51ec000 	msr	vbar_el3, x0
	isb();
    40002784:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cptr)
    40002788:	d2800000 	mov	x0, #0x0                   	// #0
    4000278c:	d51e1140 	msr	cptr_el3, x0
MAKE_REG_HELPER(scr_el3);
    40002790:	d281b600 	mov	x0, #0xdb0                 	// #3504
    40002794:	d51e1100 	msr	scr_el3, x0
	reg = read_sysreg(ICC_SRE_EL3);
    40002798:	d53ecca0 	mrs	x0, s3_6_c12_c12_5
	write_sysreg(reg, ICC_SRE_EL3);
    4000279c:	d2800120 	mov	x0, #0x9                   	// #9
    400027a0:	d51ecca0 	msr	s3_6_c12_c12_5, x0
	z_arm64_el3_plat_init();
    400027a4:	97ffff88 	bl	400025c4 <z_arm64_el3_plat_init>
	isb();
    400027a8:	d5033fdf 	isb
	if (el3_get_next_el() == EL3_TO_EL1_SKIP_EL2) {
    400027ac:	97ffffbf 	bl	400026a8 <el3_get_next_el>
    400027b0:	7100081f 	cmp	w0, #0x2
    400027b4:	54000061 	b.ne	400027c0 <z_arm64_el3_init+0x50>  // b.any
}
    400027b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_arm64_el2_init();
    400027bc:	17ffffda 	b	40002724 <z_arm64_el2_init>
}
    400027c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400027c4:	d65f03c0 	ret

00000000400027c8 <z_arm64_el1_init>:

void z_arm64_el1_init(void)
{
    400027c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    400027cc:	d0ffffe0 	adrp	x0, 40000000 <__text_region_start>
    400027d0:	91200000 	add	x0, x0, #0x800
    400027d4:	910003fd 	mov	x29, sp
    400027d8:	d518c000 	msr	vbar_el1, x0
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el1((uint64_t)_vector_table);
	isb();
    400027dc:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cpacr)
    400027e0:	d2a00600 	mov	x0, #0x300000              	// #3145728
    400027e4:	d5181040 	msr	cpacr_el1, x0
MAKE_REG_HELPER_EL123(sctlr)
    400027e8:	d5381000 	mrs	x0, sctlr_el1
	reg |= CPACR_EL1_FPEN_NOTRAP;	/* Do not trap NEON/SIMD/FP initially */
					/* TODO: CONFIG_FLOAT_*_FORBIDDEN */
	write_cpacr_el1(reg);

	reg = read_sctlr_el1();
	reg |= (SCTLR_EL1_RES1 |	/* RES1 */
    400027ec:	d2830101 	mov	x1, #0x1808                	// #6152
    400027f0:	f2a61a01 	movk	x1, #0x30d0, lsl #16
    400027f4:	aa010000 	orr	x0, x0, x1
    400027f8:	d5181000 	msr	sctlr_el1, x0
MAKE_REG_HELPER(cntv_cval_el0)
    400027fc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    40002800:	d51be340 	msr	cntv_cval_el0, x0
	 * Enable these if/when we use the corresponding timers.
	 * write_cntp_cval_el0(~(uint64_t)0);
	 * write_cntps_cval_el1(~(uint64_t)0);
	 */

	z_arm64_el1_plat_init();
    40002804:	97ffffb5 	bl	400026d8 <z_arm64_el1_plat_init>

	isb();
    40002808:	d5033fdf 	isb
}
    4000280c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40002810:	d65f03c0 	ret

0000000040002814 <z_arm64_el3_get_next_el>:

void z_arm64_el3_get_next_el(uint64_t switch_addr)
{
    40002814:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40002818:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(elr)
    4000281c:	d51e4020 	msr	elr_el3, x0
	write_elr_el3(switch_addr);

	/* Mask the DAIF */
	spsr = SPSR_DAIF_MASK;

	if (el3_get_next_el() == EL3_TO_EL2) {
    40002820:	97ffffa2 	bl	400026a8 <el3_get_next_el>
		/* Dropping into EL2 */
		spsr |= SPSR_MODE_EL2T;
	} else {
		/* Dropping into EL1 */
		spsr |= SPSR_MODE_EL1T;
    40002824:	7100001f 	cmp	w0, #0x0
    40002828:	d2807881 	mov	x1, #0x3c4                 	// #964
    4000282c:	d2807900 	mov	x0, #0x3c8                 	// #968
    40002830:	9a810000 	csel	x0, x0, x1, eq  // eq = none
MAKE_REG_HELPER_EL123(spsr)
    40002834:	d51e4000 	msr	spsr_el3, x0
	}

	write_spsr_el3(spsr);
}
    40002838:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000283c:	d65f03c0 	ret

0000000040002840 <z_arm64_context_switch>:

GTEXT(z_arm64_context_switch)
SECTION_FUNC(TEXT, z_arm64_context_switch)

	/* Save the current SP_EL0 */
	mrs	x4, sp_el0
    40002840:	d5384104 	mrs	x4, sp_el0

	stp	x19, x20, [x1, #_thread_offset_to_callee_saved_x19_x20]
    40002844:	a904d033 	stp	x19, x20, [x1, #72]
	stp	x21, x22, [x1, #_thread_offset_to_callee_saved_x21_x22]
    40002848:	a905d835 	stp	x21, x22, [x1, #88]
	stp	x23, x24, [x1, #_thread_offset_to_callee_saved_x23_x24]
    4000284c:	a906e037 	stp	x23, x24, [x1, #104]
	stp	x25, x26, [x1, #_thread_offset_to_callee_saved_x25_x26]
    40002850:	a907e839 	stp	x25, x26, [x1, #120]
	stp	x27, x28, [x1, #_thread_offset_to_callee_saved_x27_x28]
    40002854:	a908f03b 	stp	x27, x28, [x1, #136]
	stp	x29, x4,  [x1, #_thread_offset_to_callee_saved_x29_sp_el0]
    40002858:	a909903d 	stp	x29, x4, [x1, #152]

	/* Save the current SP_ELx */
	mov	x4, sp
    4000285c:	910003e4 	mov	x4, sp
	str	x4, [x1, #_thread_offset_to_callee_saved_sp_elx]
    40002860:	f9005424 	str	x4, [x1, #168]

	/* save current thread's exception depth */
	mrs	x4, tpidrro_el0
    40002864:	d53bd064 	mrs	x4, tpidrro_el0
	lsr	x2, x4, #TPIDRROEL0_EXC_SHIFT
    40002868:	d378fc82 	lsr	x2, x4, #56
	strb	w2, [x1, #_thread_offset_to_exception_depth]
    4000286c:	390bc022 	strb	w2, [x1, #752]

	/* retrieve next thread's exception depth */
	ldrb	w2, [x0, #_thread_offset_to_exception_depth]
    40002870:	394bc002 	ldrb	w2, [x0, #752]
	bic	x4, x4, #TPIDRROEL0_EXC_DEPTH
    40002874:	9240dc84 	and	x4, x4, #0xffffffffffffff
	orr	x4, x4, x2, lsl #TPIDRROEL0_EXC_SHIFT
    40002878:	aa02e084 	orr	x4, x4, x2, lsl #56
	msr	tpidrro_el0, x4
    4000287c:	d51bd064 	msr	tpidrro_el0, x4
	 * thread variables with offsets added by toolchain.
	 */
	msr	tpidr_el0, x2
#endif

	ldp	x19, x20, [x0, #_thread_offset_to_callee_saved_x19_x20]
    40002880:	a944d013 	ldp	x19, x20, [x0, #72]
	ldp	x21, x22, [x0, #_thread_offset_to_callee_saved_x21_x22]
    40002884:	a945d815 	ldp	x21, x22, [x0, #88]
	ldp	x23, x24, [x0, #_thread_offset_to_callee_saved_x23_x24]
    40002888:	a946e017 	ldp	x23, x24, [x0, #104]
	ldp	x25, x26, [x0, #_thread_offset_to_callee_saved_x25_x26]
    4000288c:	a947e819 	ldp	x25, x26, [x0, #120]
	ldp	x27, x28, [x0, #_thread_offset_to_callee_saved_x27_x28]
    40002890:	a948f01b 	ldp	x27, x28, [x0, #136]
	ldp	x29, x4,  [x0, #_thread_offset_to_callee_saved_x29_sp_el0]
    40002894:	a949901d 	ldp	x29, x4, [x0, #152]

	/* Restore SP_EL0 */
	msr	sp_el0, x4
    40002898:	d5184104 	msr	sp_el0, x4

	/* Restore SP_EL1 */
	ldr	x4, [x0, #_thread_offset_to_callee_saved_sp_elx]
    4000289c:	f9405404 	ldr	x4, [x0, #168]
	mov	sp, x4
    400028a0:	9100009f 	mov	sp, x4
	bl	z_thread_mark_switched_in
	ldp	xzr, x30, [sp], #16
#endif

	/* Return to z_arm64_sync_exc() or _isr_wrapper() */
	ret
    400028a4:	d65f03c0 	ret

00000000400028a8 <z_arm64_sync_exc>:
 */

GTEXT(z_arm64_sync_exc)
SECTION_FUNC(TEXT, z_arm64_sync_exc)

	mrs	x0, esr_el1
    400028a8:	d5385200 	mrs	x0, esr_el1
	lsr	x1, x0, #26
    400028ac:	d35afc01 	lsr	x1, x0, #26

#ifdef CONFIG_FPU_SHARING
	cmp	x1, #0x07 /*Access to SIMD or floating-point */
    400028b0:	f1001c3f 	cmp	x1, #0x7
	bne	1f
    400028b4:	54000081 	b.ne	400028c4 <z_arm64_sync_exc+0x1c>  // b.any
	mov	x0, sp
    400028b8:	910003e0 	mov	x0, sp
	bl	z_arm64_fpu_trap
    400028bc:	94000048 	bl	400029dc <z_arm64_fpu_trap>
	b	z_arm64_exit_exc_fpu_done
    400028c0:	1400002c 	b	40002970 <z_arm64_exit_exc_fpu_done>
1:
#endif

	cmp	x1, #0x15 /* 0x15 = SVC */
    400028c4:	f100543f 	cmp	x1, #0x15
	bne	inv
    400028c8:	540001a1 	b.ne	400028fc <inv>  // b.any

	/* Demux the SVC call */
	and	x1, x0, #0xff
    400028cc:	92401c01 	and	x1, x0, #0xff

	cmp	x1, #_SVC_CALL_CONTEXT_SWITCH
    400028d0:	f100003f 	cmp	x1, #0x0
	beq	context_switch
    400028d4:	540000c0 	b.eq	400028ec <context_switch>  // b.none

	cmp	x1, #_SVC_CALL_RUNTIME_EXCEPT
    400028d8:	f100083f 	cmp	x1, #0x2
	beq	oops
    400028dc:	54000040 	b.eq	400028e4 <oops>  // b.none

	/* --(_kernel->nested) */
	dec_nest_counter x0, x1
	b	z_arm64_exit_exc
#endif
	b	inv
    400028e0:	14000007 	b	400028fc <inv>

00000000400028e4 <oops>:

oops:
	mov	x0, sp
    400028e4:	910003e0 	mov	x0, sp
	b	z_arm64_do_kernel_oops
    400028e8:	17ffff51 	b	4000262c <z_arm64_do_kernel_oops>

00000000400028ec <context_switch>:
	 * Retrieve x0 and x1 from the stack:
	 *
	 *  - x0 = new_thread->switch_handle = switch_to thread
	 *  - x1 = &old_thread->switch_handle = current thread
	 */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    400028ec:	a94007e0 	ldp	x0, x1, [sp]

	/* Get old thread from x1 */
	sub	x1, x1, ___thread_t_switch_handle_OFFSET
    400028f0:	d1034021 	sub	x1, x1, #0xd0

	/* Switch thread */
	bl	z_arm64_context_switch
    400028f4:	97ffffd3 	bl	40002840 <z_arm64_context_switch>
	b	z_arm64_exit_exc
    400028f8:	1400001d 	b	4000296c <z_arm64_exit_exc>

00000000400028fc <inv>:

inv:
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    400028fc:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
    40002900:	910003e1 	mov	x1, sp
	bl	z_arm64_fatal_error
    40002904:	97ffff37 	bl	400025e0 <z_arm64_fatal_error>

	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    40002908:	14000019 	b	4000296c <z_arm64_exit_exc>

000000004000290c <z_arm64_call_svc>:

GTEXT(z_arm64_call_svc)
SECTION_FUNC(TEXT, z_arm64_call_svc)
	svc	#_SVC_CALL_CONTEXT_SWITCH
    4000290c:	d4000001 	svc	#0x0
	ret
    40002910:	d65f03c0 	ret

0000000040002914 <arch_new_thread>:
	 * dropping into EL0.
	 */

	pInitCtx = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	pInitCtx->x0 = (uint64_t)entry;
    40002914:	d102c041 	sub	x1, x2, #0xb0
	pInitCtx->x1 = (uint64_t)p1;
    40002918:	a9351043 	stp	x3, x4, [x2, #-176]
	pInitCtx->x2 = (uint64_t)p2;
	pInitCtx->x3 = (uint64_t)p3;
    4000291c:	a9361845 	stp	x5, x6, [x2, #-160]
		pInitCtx->elr = (uint64_t)arch_user_mode_enter;
	} else {
		pInitCtx->elr = (uint64_t)z_thread_entry;
	}
#else
	pInitCtx->elr = (uint64_t)z_thread_entry;
    40002920:	f0ffffe2 	adrp	x2, 40001000 <__reset+0x4>
    40002924:	9108a042 	add	x2, x2, #0x228
    40002928:	f9005422 	str	x2, [x1, #168]
#endif
	/* Keep using SP_EL1 */
	pInitCtx->spsr = SPSR_MODE_EL1H | DAIF_FIQ_BIT;
    4000292c:	d28008a2 	mov	x2, #0x45                  	// #69
    40002930:	f9005022 	str	x2, [x1, #160]

	/* thread birth happens through the exception return path */
	thread->arch.exception_depth = 1;
    40002934:	52800022 	mov	w2, #0x1                   	// #1
	 * We are saving SP_EL1 to pop out entry and parameters when going
	 * through z_arm64_exit_exc(). For user threads the definitive location
	 * of SP_EL1 will be set implicitly when going through
	 * z_arm64_userspace_enter() (see comments there)
	 */
	thread->callee_saved.sp_elx = (uint64_t)pInitCtx;
    40002938:	f9005401 	str	x1, [x0, #168]

	thread->switch_handle = thread;
    4000293c:	f9006800 	str	x0, [x0, #208]
	thread->arch.exception_depth = 1;
    40002940:	390bc002 	strb	w2, [x0, #752]
}
    40002944:	d65f03c0 	ret

0000000040002948 <z_arch_get_next_switch_handle>:

void *z_arch_get_next_switch_handle(struct k_thread **old_thread)
{
    40002948:	aa0003e1 	mov	x1, x0
	*old_thread =  _current;
    4000294c:	b0000060 	adrp	x0, 4000f000 <z_idle_threads>
    40002950:	f9431800 	ldr	x0, [x0, #1584]
    40002954:	f9000020 	str	x0, [x1]

	return z_get_next_switch_handle(*old_thread);
    40002958:	14000636 	b	40004230 <z_get_next_switch_handle>

000000004000295c <z_arm64_serror>:

GTEXT(z_arm64_serror)
SECTION_FUNC(TEXT, z_arm64_serror)

	mov	x1, sp
    4000295c:	910003e1 	mov	x1, sp
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    40002960:	d2800000 	mov	x0, #0x0                   	// #0

	bl	z_arm64_fatal_error
    40002964:	97ffff1f 	bl	400025e0 <z_arm64_fatal_error>
	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    40002968:	14000001 	b	4000296c <z_arm64_exit_exc>

000000004000296c <z_arm64_exit_exc>:

GTEXT(z_arm64_exit_exc)
SECTION_FUNC(TEXT, z_arm64_exit_exc)

#ifdef CONFIG_FPU_SHARING
	bl	z_arm64_fpu_exit_exc
    4000296c:	94000055 	bl	40002ac0 <z_arm64_fpu_exit_exc>

0000000040002970 <z_arm64_exit_exc_fpu_done>:

 GTEXT(z_arm64_exit_exc_fpu_done)
 z_arm64_exit_exc_fpu_done:
#endif

	ldp	x0, x1, [sp, ___esf_t_spsr_elr_OFFSET]
    40002970:	a94a07e0 	ldp	x0, x1, [sp, #160]
	msr	spsr_el1, x0
    40002974:	d5184000 	msr	spsr_el1, x0
	msr	elr_el1, x1
    40002978:	d5184021 	msr	elr_el1, x1

	/* Restore the kernel/user mode flag and decrement exception depth */
	tst	x0, #SPSR_MODE_MASK	/* EL0 == 0 */
    4000297c:	f2400c1f 	tst	x0, #0xf
	mrs	x0, tpidrro_el0
    40002980:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    40002984:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	orr	x2, x0, #TPIDRROEL0_IN_EL0
    40002988:	b2400002 	orr	x2, x0, #0x1
	csel	x0, x2, x0, eq
    4000298c:	9a800040 	csel	x0, x2, x0, eq  // eq = none
	sub	x0, x0, x1
    40002990:	cb010000 	sub	x0, x0, x1
	msr	tpidrro_el0, x0
    40002994:	d51bd060 	msr	tpidrro_el0, x0

	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    40002998:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    4000299c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    400029a0:	a94217e4 	ldp	x4, x5, [sp, #32]
	ldp	x6, x7, [sp, ___esf_t_x6_x7_OFFSET]
    400029a4:	a9431fe6 	ldp	x6, x7, [sp, #48]
	ldp	x8, x9, [sp, ___esf_t_x8_x9_OFFSET]
    400029a8:	a94427e8 	ldp	x8, x9, [sp, #64]
	ldp	x10, x11, [sp, ___esf_t_x10_x11_OFFSET]
    400029ac:	a9452fea 	ldp	x10, x11, [sp, #80]
	ldp	x12, x13, [sp, ___esf_t_x12_x13_OFFSET]
    400029b0:	a94637ec 	ldp	x12, x13, [sp, #96]
	ldp	x14, x15, [sp, ___esf_t_x14_x15_OFFSET]
    400029b4:	a9473fee 	ldp	x14, x15, [sp, #112]
	ldp	x16, x17, [sp, ___esf_t_x16_x17_OFFSET]
    400029b8:	a94847f0 	ldp	x16, x17, [sp, #128]
	ldp	x18, x30, [sp, ___esf_t_x18_x30_OFFSET]
    400029bc:	a9497bf2 	ldp	x18, x30, [sp, #144]

	add	sp, sp, ___esf_t_SIZEOF
    400029c0:	9102c3ff 	add	sp, sp, #0xb0
	 * - The address of ret in z_arm64_call_svc()
	 * - The address of the next instruction at the time of the IRQ when the
	 *   thread was switched out.
	 * - The address of z_thread_entry() for new threads (see thread.c).
	 */
	eret
    400029c4:	d69f03e0 	eret

00000000400029c8 <z_arm64_fpu_enter_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    400029c8:	d5381040 	mrs	x0, cpacr_el1
void z_arm64_fpu_enter_exc(void)
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	/* always deny FPU access whenever an exception is entered */
	write_cpacr_el1(read_cpacr_el1() & ~CPACR_EL1_FPEN_NOTRAP);
    400029cc:	926af400 	and	x0, x0, #0xffffffffffcfffff
    400029d0:	d5181040 	msr	cpacr_el1, x0
	isb();
    400029d4:	d5033fdf 	isb
}
    400029d8:	d65f03c0 	ret

00000000400029dc <z_arm64_fpu_trap>:
 * there is nothing to save/restore for that context... as long as we
 * don't get interrupted that is. To ensure that we mask interrupts to
 * the triggering exception context.
 */
void z_arm64_fpu_trap(z_arch_esf_t *esf)
{
    400029dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400029e0:	910003fd 	mov	x29, sp
    400029e4:	a90153f3 	stp	x19, x20, [sp, #16]
    400029e8:	aa0003f3 	mov	x19, x0
MAKE_REG_HELPER(tpidrro_el0);
    400029ec:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
}

static ALWAYS_INLINE int arch_exception_depth(void)
{
	return (read_tpidrro_el0() & TPIDRROEL0_EXC_DEPTH) / TPIDRROEL0_EXC_UNIT;
    400029f0:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() <= 1) {
    400029f4:	f100041f 	cmp	x0, #0x1
    400029f8:	54000309 	b.ls	40002a58 <z_arm64_fpu_trap+0x7c>  // b.plast
	uint32_t *pc = (uint32_t *)esf->elr;
    400029fc:	f9405662 	ldr	x2, [x19, #168]
	uintptr_t sp = (uintptr_t)esf + sizeof(*esf);
    40002a00:	9102c263 	add	x3, x19, #0xb0
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    40002a04:	52807f04 	mov	w4, #0x3f8                 	// #1016
    40002a08:	72bff804 	movk	w4, #0xffc0, lsl #16
	uint32_t *pc = (uint32_t *)esf->elr;
    40002a0c:	aa0203e0 	mov	x0, x2
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    40002a10:	52807c05 	mov	w5, #0x3e0                 	// #992
    40002a14:	72a7b005 	movk	w5, #0x3d80, lsl #16
		uint32_t insn = *pc;
    40002a18:	b9400001 	ldr	w1, [x0]
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    40002a1c:	0a040026 	and	w6, w1, w4
    40002a20:	6b0500df 	cmp	w6, w5
    40002a24:	540000e1 	b.ne	40002a40 <z_arm64_fpu_trap+0x64>  // b.any
		uint32_t pimm = (insn >> 10) & 0xfff;
    40002a28:	d34a5421 	ubfx	x1, x1, #10, #12
		pc++;
    40002a2c:	91001000 	add	x0, x0, #0x4
		*(__int128 *)(sp + pimm * 16) = 0;
    40002a30:	d37c2c21 	ubfiz	x1, x1, #4, #12
    40002a34:	8b030021 	add	x1, x1, x3
    40002a38:	a9007c3f 	stp	xzr, xzr, [x1]
	for (;;) {
    40002a3c:	17fffff7 	b	40002a18 <z_arm64_fpu_trap+0x3c>
	if (pc != (uint32_t *)esf->elr) {
    40002a40:	eb00005f 	cmp	x2, x0
    40002a44:	540000a0 	b.eq	40002a58 <z_arm64_fpu_trap+0x7c>  // b.none
		esf->elr = (uintptr_t)pc;
    40002a48:	f9005660 	str	x0, [x19, #168]
	_current_cpu->arch.fpu_owner = _current;

	/* restore our content */
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
	DBG("restore", _current);
}
    40002a4c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002a50:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40002a54:	d65f03c0 	ret
MAKE_REG_HELPER_EL123(cpacr)
    40002a58:	d5381040 	mrs	x0, cpacr_el1
	write_cpacr_el1(read_cpacr_el1() | CPACR_EL1_FPEN_NOTRAP);
    40002a5c:	b26c0400 	orr	x0, x0, #0x300000
    40002a60:	d5181040 	msr	cpacr_el1, x0
	isb();
    40002a64:	d5033fdf 	isb
	struct k_thread *owner = _current_cpu->arch.fpu_owner;
    40002a68:	b0000074 	adrp	x20, 4000f000 <z_idle_threads>
    40002a6c:	91188294 	add	x20, x20, #0x620
    40002a70:	f9401680 	ldr	x0, [x20, #40]
	if (owner) {
    40002a74:	b40000a0 	cbz	x0, 40002a88 <z_arm64_fpu_trap+0xac>
		z_arm64_fpu_save(&owner->arch.saved_fp_context);
    40002a78:	91038000 	add	x0, x0, #0xe0
    40002a7c:	94000021 	bl	40002b00 <z_arm64_fpu_save>
		dsb();
    40002a80:	d5033f9f 	dsb	sy
		_current_cpu->arch.fpu_owner = NULL;
    40002a84:	f900169f 	str	xzr, [x20, #40]
MAKE_REG_HELPER(tpidrro_el0);
    40002a88:	d53bd060 	mrs	x0, tpidrro_el0
    40002a8c:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() > 1) {
    40002a90:	f100041f 	cmp	x0, #0x1
    40002a94:	540000a9 	b.ls	40002aa8 <z_arm64_fpu_trap+0xcc>  // b.plast
		esf->spsr |= DAIF_IRQ_BIT;
    40002a98:	f9405260 	ldr	x0, [x19, #160]
    40002a9c:	b2790000 	orr	x0, x0, #0x80
    40002aa0:	f9005260 	str	x0, [x19, #160]
		return;
    40002aa4:	17ffffea 	b	40002a4c <z_arm64_fpu_trap+0x70>
	_current_cpu->arch.fpu_owner = _current;
    40002aa8:	f9400a80 	ldr	x0, [x20, #16]
    40002aac:	f9001680 	str	x0, [x20, #40]
}
    40002ab0:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    40002ab4:	91038000 	add	x0, x0, #0xe0
}
    40002ab8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    40002abc:	14000026 	b	40002b54 <z_arm64_fpu_restore>

0000000040002ac0 <z_arm64_fpu_exit_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    40002ac0:	d5381040 	mrs	x0, cpacr_el1
MAKE_REG_HELPER(tpidrro_el0);
    40002ac4:	d53bd061 	mrs	x1, tpidrro_el0
    40002ac8:	d378fc21 	lsr	x1, x1, #56
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	uint64_t cpacr = read_cpacr_el1();

	if (arch_exception_depth() == 1) {
    40002acc:	f100043f 	cmp	x1, #0x1
    40002ad0:	54000141 	b.ne	40002af8 <z_arm64_fpu_exit_exc+0x38>  // b.any
		/* We're about to leave exception mode */
		if (_current_cpu->arch.fpu_owner == _current) {
    40002ad4:	b0000061 	adrp	x1, 4000f000 <z_idle_threads>
    40002ad8:	91188021 	add	x1, x1, #0x620
    40002adc:	f9401422 	ldr	x2, [x1, #40]
    40002ae0:	f9400821 	ldr	x1, [x1, #16]
    40002ae4:	eb01005f 	cmp	x2, x1
    40002ae8:	54000081 	b.ne	40002af8 <z_arm64_fpu_exit_exc+0x38>  // b.any
			/* turn on FPU access */
			write_cpacr_el1(cpacr | CPACR_EL1_FPEN_NOTRAP);
    40002aec:	b26c0400 	orr	x0, x0, #0x300000
MAKE_REG_HELPER_EL123(cpacr)
    40002af0:	d5181040 	msr	cpacr_el1, x0
		 * access as we want to make sure IRQs are disabled before
		 * granting them access.
		 */
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
	}
}
    40002af4:	d65f03c0 	ret
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
    40002af8:	926af400 	and	x0, x0, #0xffffffffffcfffff
    40002afc:	17fffffd 	b	40002af0 <z_arm64_fpu_exit_exc+0x30>

0000000040002b00 <z_arm64_fpu_save>:
_ASM_FILE_PROLOGUE

GTEXT(z_arm64_fpu_save)
SECTION_FUNC(TEXT, z_arm64_fpu_save)

	stp	q0,  q1,  [x0, #(16 *  0)]
    40002b00:	ad000400 	stp	q0, q1, [x0]
	stp	q2,  q3,  [x0, #(16 *  2)]
    40002b04:	ad010c02 	stp	q2, q3, [x0, #32]
	stp	q4,  q5,  [x0, #(16 *  4)]
    40002b08:	ad021404 	stp	q4, q5, [x0, #64]
	stp	q6,  q7,  [x0, #(16 *  6)]
    40002b0c:	ad031c06 	stp	q6, q7, [x0, #96]
	stp	q8,  q9,  [x0, #(16 *  8)]
    40002b10:	ad042408 	stp	q8, q9, [x0, #128]
	stp	q10, q11, [x0, #(16 * 10)]
    40002b14:	ad052c0a 	stp	q10, q11, [x0, #160]
	stp	q12, q13, [x0, #(16 * 12)]
    40002b18:	ad06340c 	stp	q12, q13, [x0, #192]
	stp	q14, q15, [x0, #(16 * 14)]
    40002b1c:	ad073c0e 	stp	q14, q15, [x0, #224]
	stp	q16, q17, [x0, #(16 * 16)]
    40002b20:	ad084410 	stp	q16, q17, [x0, #256]
	stp	q18, q19, [x0, #(16 * 18)]
    40002b24:	ad094c12 	stp	q18, q19, [x0, #288]
	stp	q20, q21, [x0, #(16 * 20)]
    40002b28:	ad0a5414 	stp	q20, q21, [x0, #320]
	stp	q22, q23, [x0, #(16 * 22)]
    40002b2c:	ad0b5c16 	stp	q22, q23, [x0, #352]
	stp	q24, q25, [x0, #(16 * 24)]
    40002b30:	ad0c6418 	stp	q24, q25, [x0, #384]
	stp	q26, q27, [x0, #(16 * 26)]
    40002b34:	ad0d6c1a 	stp	q26, q27, [x0, #416]
	stp	q28, q29, [x0, #(16 * 28)]
    40002b38:	ad0e741c 	stp	q28, q29, [x0, #448]
	stp	q30, q31, [x0, #(16 * 30)]
    40002b3c:	ad0f7c1e 	stp	q30, q31, [x0, #480]

	mrs	x1, fpsr
    40002b40:	d53b4421 	mrs	x1, fpsr
	mrs	x2, fpcr
    40002b44:	d53b4402 	mrs	x2, fpcr
	str	w1, [x0, #(16 * 32 + 0)]
    40002b48:	b9020001 	str	w1, [x0, #512]
	str	w2, [x0, #(16 * 32 + 4)]
    40002b4c:	b9020402 	str	w2, [x0, #516]

	ret
    40002b50:	d65f03c0 	ret

0000000040002b54 <z_arm64_fpu_restore>:

GTEXT(z_arm64_fpu_restore)
SECTION_FUNC(TEXT, z_arm64_fpu_restore)

	ldp	q0,  q1,  [x0, #(16 *  0)]
    40002b54:	ad400400 	ldp	q0, q1, [x0]
	ldp	q2,  q3,  [x0, #(16 *  2)]
    40002b58:	ad410c02 	ldp	q2, q3, [x0, #32]
	ldp	q4,  q5,  [x0, #(16 *  4)]
    40002b5c:	ad421404 	ldp	q4, q5, [x0, #64]
	ldp	q6,  q7,  [x0, #(16 *  6)]
    40002b60:	ad431c06 	ldp	q6, q7, [x0, #96]
	ldp	q8,  q9,  [x0, #(16 *  8)]
    40002b64:	ad442408 	ldp	q8, q9, [x0, #128]
	ldp	q10, q11, [x0, #(16 * 10)]
    40002b68:	ad452c0a 	ldp	q10, q11, [x0, #160]
	ldp	q12, q13, [x0, #(16 * 12)]
    40002b6c:	ad46340c 	ldp	q12, q13, [x0, #192]
	ldp	q14, q15, [x0, #(16 * 14)]
    40002b70:	ad473c0e 	ldp	q14, q15, [x0, #224]
	ldp	q16, q17, [x0, #(16 * 16)]
    40002b74:	ad484410 	ldp	q16, q17, [x0, #256]
	ldp	q18, q19, [x0, #(16 * 18)]
    40002b78:	ad494c12 	ldp	q18, q19, [x0, #288]
	ldp	q20, q21, [x0, #(16 * 20)]
    40002b7c:	ad4a5414 	ldp	q20, q21, [x0, #320]
	ldp	q22, q23, [x0, #(16 * 22)]
    40002b80:	ad4b5c16 	ldp	q22, q23, [x0, #352]
	ldp	q24, q25, [x0, #(16 * 24)]
    40002b84:	ad4c6418 	ldp	q24, q25, [x0, #384]
	ldp	q26, q27, [x0, #(16 * 26)]
    40002b88:	ad4d6c1a 	ldp	q26, q27, [x0, #416]
	ldp	q28, q29, [x0, #(16 * 28)]
    40002b8c:	ad4e741c 	ldp	q28, q29, [x0, #448]
	ldp	q30, q31, [x0, #(16 * 30)]
    40002b90:	ad4f7c1e 	ldp	q30, q31, [x0, #480]

	ldr	w1, [x0, #(16 * 32 + 0)]
    40002b94:	b9420001 	ldr	w1, [x0, #512]
	ldr	w2, [x0, #(16 * 32 + 4)]
    40002b98:	b9420402 	ldr	w2, [x0, #516]
	msr	fpsr, x1
    40002b9c:	d51b4421 	msr	fpsr, x1
	msr	fpcr, x2
    40002ba0:	d51b4402 	msr	fpcr, x2

	ret
    40002ba4:	d65f03c0 	ret

0000000040002ba8 <new_table>:
{
	unsigned int i;

	/* Look for a free table. */
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
		if (xlat_use_count[i] == 0U) {
    40002ba8:	b0000062 	adrp	x2, 4000f000 <z_idle_threads>
    40002bac:	911a7042 	add	x2, x2, #0x69c
{
    40002bb0:	d2800001 	mov	x1, #0x0                   	// #0
		if (xlat_use_count[i] == 0U) {
    40002bb4:	78617843 	ldrh	w3, [x2, x1, lsl #1]
    40002bb8:	2a0103e0 	mov	w0, w1
    40002bbc:	35000103 	cbnz	w3, 40002bdc <new_table+0x34>
			xlat_use_count[i] = 1U;
    40002bc0:	52800021 	mov	w1, #0x1                   	// #1
    40002bc4:	78205841 	strh	w1, [x2, w0, uxtw #1]
			return &xlat_tables[i * Ln_XLAT_NUM_ENTRIES];
    40002bc8:	d3745800 	ubfiz	x0, x0, #12, #23
    40002bcc:	b0000021 	adrp	x1, 40007000 <xlat_tables>
    40002bd0:	91000021 	add	x1, x1, #0x0
    40002bd4:	8b010000 	add	x0, x0, x1
		}
	}

	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
	return NULL;
}
    40002bd8:	d65f03c0 	ret
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    40002bdc:	91000421 	add	x1, x1, #0x1
    40002be0:	f100203f 	cmp	x1, #0x8
    40002be4:	54fffe81 	b.ne	40002bb4 <new_table+0xc>  // b.any
	return NULL;
    40002be8:	d2800000 	mov	x0, #0x0                   	// #0
    40002bec:	17fffffb 	b	40002bd8 <new_table+0x30>

0000000040002bf0 <table_usage>:

static inline unsigned int table_index(uint64_t *pte)
{
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40002bf0:	b0000022 	adrp	x2, 40007000 <xlat_tables>
    40002bf4:	91000042 	add	x2, x2, #0x0
    40002bf8:	cb020002 	sub	x2, x0, x2
    40002bfc:	d2804000 	mov	x0, #0x200                 	// #512
/* Adjusts usage count and returns current count. */
static int table_usage(uint64_t *table, int adjustment)
{
	unsigned int i = table_index(table);

	xlat_use_count[i] += adjustment;
    40002c00:	b0000063 	adrp	x3, 4000f000 <z_idle_threads>
    40002c04:	911a7063 	add	x3, x3, #0x69c
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40002c08:	9343fc42 	asr	x2, x2, #3
    40002c0c:	9ac00c42 	sdiv	x2, x2, x0
	xlat_use_count[i] += adjustment;
    40002c10:	2a0203e2 	mov	w2, w2
    40002c14:	78627860 	ldrh	w0, [x3, x2, lsl #1]
    40002c18:	0b000020 	add	w0, w1, w0
    40002c1c:	12003c00 	and	w0, w0, #0xffff
    40002c20:	78227860 	strh	w0, [x3, x2, lsl #1]
	__ASSERT(xlat_use_count[i] > 0, "usage count underflow");
	return xlat_use_count[i];
}
    40002c24:	d65f03c0 	ret

0000000040002c28 <set_mapping.constprop.0>:
}

static inline bool is_desc_superset(uint64_t desc1, uint64_t desc2,
				    unsigned int level)
{
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    40002c28:	1281ff8d 	mov	w13, #0xfffff003            	// #-4093
    40002c2c:	d281ff8e 	mov	x14, #0xffc                 	// #4092
		       uintptr_t virt, size_t size,
		       uint64_t desc, bool may_overwrite)
{
	uint64_t *pte, *ptes[XLAT_LAST_LEVEL + 1];
	uint64_t level_size;
	uint64_t *table = ptables->base_xlat_table;
    40002c30:	b000006a 	adrp	x10, 4000f000 <z_idle_threads>
    40002c34:	f9430145 	ldr	x5, [x10, #1536]
	xlat_use_count[i] = 0U;
    40002c38:	b000006b 	adrp	x11, 4000f000 <z_idle_threads>
    40002c3c:	911a716b 	add	x11, x11, #0x69c
static int set_mapping(struct arm_mmu_ptables *ptables,
    40002c40:	aa0003e8 	mov	x8, x0
    40002c44:	aa0103e7 	mov	x7, x1
    40002c48:	aa0203e6 	mov	x6, x2
    40002c4c:	12001c6c 	and	w12, w3, #0xff
	unsigned int level = BASE_XLAT_LEVEL;
    40002c50:	5280002f 	mov	w15, #0x1                   	// #1
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    40002c54:	f2dfffed 	movk	x13, #0xffff, lsl #32
    40002c58:	f2ffff0e 	movk	x14, #0xfff8, lsl #48
	int ret = 0;

	while (size) {
    40002c5c:	b5000d21 	cbnz	x1, 40002e00 <set_mapping.constprop.0+0x1d8>
	int ret = 0;
    40002c60:	52800000 	mov	w0, #0x0                   	// #0
		table = ptables->base_xlat_table;
		level = BASE_XLAT_LEVEL;
	}

	return ret;
}
    40002c64:	d65f03c0 	ret
		if (!may_overwrite && !is_free_desc(*pte)) {
    40002c68:	3500006c 	cbnz	w12, 40002c74 <set_mapping.constprop.0+0x4c>
    40002c6c:	f24004bf 	tst	x5, #0x3
    40002c70:	54000b61 	b.ne	40002ddc <set_mapping.constprop.0+0x1b4>  // b.any
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    40002c74:	d2800021 	mov	x1, #0x1                   	// #1
	return (desc1 & mask) == (desc2 & mask);
    40002c78:	ca0600a2 	eor	x2, x5, x6
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    40002c7c:	9ac02033 	lsl	x19, x1, x0
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    40002c80:	cb1303e0 	neg	x0, x19
    40002c84:	8a0d0000 	and	x0, x0, x13
    40002c88:	aa0e0000 	orr	x0, x0, x14
		if (is_desc_superset(*pte, desc, level)) {
    40002c8c:	ea02001f 	tst	x0, x2
    40002c90:	540001c1 	b.ne	40002cc8 <set_mapping.constprop.0+0xa0>  // b.any
			level_size -= (virt & (level_size - 1));
    40002c94:	d1000660 	sub	x0, x19, #0x1
    40002c98:	8a080000 	and	x0, x0, x8
    40002c9c:	cb000260 	sub	x0, x19, x0
			if (level_size > size) {
    40002ca0:	eb07001f 	cmp	x0, x7
    40002ca4:	9a879013 	csel	x19, x0, x7, ls  // ls = plast
		desc += desc ? level_size : 0;
    40002ca8:	f10000df 	cmp	x6, #0x0
		virt += level_size;
    40002cac:	8b130108 	add	x8, x8, x19
		desc += desc ? level_size : 0;
    40002cb0:	9a9f1260 	csel	x0, x19, xzr, ne  // ne = any
		size -= level_size;
    40002cb4:	cb1300e7 	sub	x7, x7, x19
		table = ptables->base_xlat_table;
    40002cb8:	f9430145 	ldr	x5, [x10, #1536]
		desc += desc ? level_size : 0;
    40002cbc:	8b0000c6 	add	x6, x6, x0
		level = BASE_XLAT_LEVEL;
    40002cc0:	5280002f 	mov	w15, #0x1                   	// #1
    40002cc4:	14000062 	b	40002e4c <set_mapping.constprop.0+0x224>
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40002cc8:	eb07027f 	cmp	x19, x7
    40002ccc:	54000108 	b.hi	40002cec <set_mapping.constprop.0+0xc4>  // b.pmore
	bool aligned = !((desc & mask) & (level_size - 1));
    40002cd0:	51000660 	sub	w0, w19, #0x1
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40002cd4:	d1000662 	sub	x2, x19, #0x1
	bool aligned = !((desc & mask) & (level_size - 1));
    40002cd8:	8a060000 	and	x0, x0, x6
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40002cdc:	8a080042 	and	x2, x2, x8
	bool aligned = !((desc & mask) & (level_size - 1));
    40002ce0:	92748c00 	and	x0, x0, #0xfffffffff000
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40002ce4:	aa020000 	orr	x0, x0, x2
    40002ce8:	b40003c0 	cbz	x0, 40002d60 <set_mapping.constprop.0+0x138>
	table = new_table();
    40002cec:	97ffffaf 	bl	40002ba8 <new_table>
    40002cf0:	aa0003e5 	mov	x5, x0
	if (!table) {
    40002cf4:	b4000780 	cbz	x0, 40002de4 <set_mapping.constprop.0+0x1bc>
	if (!is_free_desc(*pte)) {
    40002cf8:	f9400080 	ldr	x0, [x4]
    40002cfc:	f240041f 	tst	x0, #0x3
    40002d00:	540002a0 	b.eq	40002d54 <set_mapping.constprop.0+0x12c>  // b.none
		if (level + 1 == XLAT_LAST_LEVEL) {
    40002d04:	710009ff 	cmp	w15, #0x2
    40002d08:	54000041 	b.ne	40002d10 <set_mapping.constprop.0+0xe8>  // b.any
			desc |= PTE_PAGE_DESC;
    40002d0c:	b2400400 	orr	x0, x0, #0x3
		stride_shift = LEVEL_TO_VA_SIZE_SHIFT(level + 1);
    40002d10:	11007929 	add	w9, w9, #0x1e
    40002d14:	d2800001 	mov	x1, #0x0                   	// #0
			table[i] = desc | (i << stride_shift);
    40002d18:	1ac92022 	lsl	w2, w1, w9
    40002d1c:	aa000042 	orr	x2, x2, x0
    40002d20:	f82178a2 	str	x2, [x5, x1, lsl #3]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    40002d24:	91000421 	add	x1, x1, #0x1
    40002d28:	f108003f 	cmp	x1, #0x200
    40002d2c:	54ffff61 	b.ne	40002d18 <set_mapping.constprop.0+0xf0>  // b.any
		table_usage(table, Ln_XLAT_NUM_ENTRIES);
    40002d30:	aa0503e0 	mov	x0, x5
		table_usage(pte, 1);
    40002d34:	97ffffaf 	bl	40002bf0 <table_usage>
	table_usage(table, 1);
    40002d38:	52800021 	mov	w1, #0x1                   	// #1
	*pte = PTE_TABLE_DESC | (uint64_t)table;
    40002d3c:	b24004a0 	orr	x0, x5, #0x3
    40002d40:	f9000080 	str	x0, [x4]
			level++;
    40002d44:	0b0101ef 	add	w15, w15, w1
	table_usage(table, 1);
    40002d48:	aa0503e0 	mov	x0, x5
    40002d4c:	97ffffa9 	bl	40002bf0 <table_usage>
			continue;
    40002d50:	1400003f 	b	40002e4c <set_mapping.constprop.0+0x224>
		table_usage(pte, 1);
    40002d54:	aa0403e0 	mov	x0, x4
    40002d58:	52800021 	mov	w1, #0x1                   	// #1
    40002d5c:	17fffff6 	b	40002d34 <set_mapping.constprop.0+0x10c>
		if (is_free_desc(*pte)) {
    40002d60:	f24004bf 	tst	x5, #0x3
    40002d64:	54000061 	b.ne	40002d70 <set_mapping.constprop.0+0x148>  // b.any
			table_usage(pte, 1);
    40002d68:	aa0403e0 	mov	x0, x4
    40002d6c:	97ffffa1 	bl	40002bf0 <table_usage>
		if (!desc) {
    40002d70:	b50003e6 	cbnz	x6, 40002dec <set_mapping.constprop.0+0x1c4>
			table_usage(pte, -1);
    40002d74:	aa0403e0 	mov	x0, x4
    40002d78:	12800001 	mov	w1, #0xffffffff            	// #-1
    40002d7c:	97ffff9d 	bl	40002bf0 <table_usage>
    40002d80:	d2800000 	mov	x0, #0x0                   	// #0
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40002d84:	b0000025 	adrp	x5, 40007000 <xlat_tables>
    40002d88:	910000a5 	add	x5, x5, #0x0
    40002d8c:	d2804009 	mov	x9, #0x200                 	// #512
	*pte = desc;
    40002d90:	f9000080 	str	x0, [x4]
		while (level != BASE_XLAT_LEVEL &&
    40002d94:	710005ff 	cmp	w15, #0x1
    40002d98:	54fff880 	b.eq	40002ca8 <set_mapping.constprop.0+0x80>  // b.none
	return table_usage(table, 0) == 1;
    40002d9c:	aa0403e0 	mov	x0, x4
    40002da0:	52800001 	mov	w1, #0x0                   	// #0
    40002da4:	97ffff93 	bl	40002bf0 <table_usage>
		while (level != BASE_XLAT_LEVEL &&
    40002da8:	7100041f 	cmp	w0, #0x1
    40002dac:	54fff7e1 	b.ne	40002ca8 <set_mapping.constprop.0+0x80>  // b.any
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40002db0:	cb050084 	sub	x4, x4, x5
			pte = ptes[--level];
    40002db4:	510005ef 	sub	w15, w15, #0x1
			table_usage(pte, -1);
    40002db8:	12800001 	mov	w1, #0xffffffff            	// #-1
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40002dbc:	9343fc84 	asr	x4, x4, #3
    40002dc0:	9ac90c84 	sdiv	x4, x4, x9
	xlat_use_count[i] = 0U;
    40002dc4:	7824597f 	strh	wzr, [x11, w4, uxtw #1]
			pte = ptes[--level];
    40002dc8:	f86f5a44 	ldr	x4, [x18, w15, uxtw #3]
			table_usage(pte, -1);
    40002dcc:	aa0403e0 	mov	x0, x4
	*pte = desc;
    40002dd0:	f900009f 	str	xzr, [x4]
			table_usage(pte, -1);
    40002dd4:	97ffff87 	bl	40002bf0 <table_usage>
    40002dd8:	17ffffef 	b	40002d94 <set_mapping.constprop.0+0x16c>
			ret = -EBUSY;
    40002ddc:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    40002de0:	1400001d 	b	40002e54 <set_mapping.constprop.0+0x22c>
				ret = -ENOMEM;
    40002de4:	12800160 	mov	w0, #0xfffffff4            	// #-12
	return ret;
    40002de8:	1400001b 	b	40002e54 <set_mapping.constprop.0+0x22c>
		desc |= (level == XLAT_LAST_LEVEL) ? PTE_PAGE_DESC : PTE_BLOCK_DESC;
    40002dec:	71000dff 	cmp	w15, #0x3
    40002df0:	d2800060 	mov	x0, #0x3                   	// #3
    40002df4:	9a9f0400 	csinc	x0, x0, xzr, eq  // eq = none
    40002df8:	aa0000c0 	orr	x0, x6, x0
    40002dfc:	17ffffe2 	b	40002d84 <set_mapping.constprop.0+0x15c>
static int set_mapping(struct arm_mmu_ptables *ptables,
    40002e00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40002e04:	910003fd 	mov	x29, sp
    40002e08:	f9000bf3 	str	x19, [sp, #16]
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    40002e0c:	12800109 	mov	w9, #0xfffffff7            	// #-9
		ptes[level] = pte;
    40002e10:	910083f2 	add	x18, sp, #0x20
	return level != XLAT_LAST_LEVEL &&
    40002e14:	71000dff 	cmp	w15, #0x3
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    40002e18:	1b097de9 	mul	w9, w15, w9
    40002e1c:	11009d20 	add	w0, w9, #0x27
    40002e20:	9ac02501 	lsr	x1, x8, x0
    40002e24:	d37d2021 	ubfiz	x1, x1, #3, #9
    40002e28:	8b0100a4 	add	x4, x5, x1
		ptes[level] = pte;
    40002e2c:	f82f5a44 	str	x4, [x18, w15, uxtw #3]
		if (is_table_desc(*pte, level)) {
    40002e30:	f86168a5 	ldr	x5, [x5, x1]
	return level != XLAT_LAST_LEVEL &&
    40002e34:	54fff1a0 	b.eq	40002c68 <set_mapping.constprop.0+0x40>  // b.none
	       (desc & PTE_DESC_TYPE_MASK) == PTE_TABLE_DESC;
    40002e38:	924004a1 	and	x1, x5, #0x3
		if (is_table_desc(*pte, level)) {
    40002e3c:	f1000c3f 	cmp	x1, #0x3
    40002e40:	54fff141 	b.ne	40002c68 <set_mapping.constprop.0+0x40>  // b.any
			level++;
    40002e44:	110005ef 	add	w15, w15, #0x1
	uint64_t address = desc & GENMASK(47, PAGE_SIZE_SHIFT);
    40002e48:	92748ca5 	and	x5, x5, #0xfffffffff000
	while (size) {
    40002e4c:	b5fffe07 	cbnz	x7, 40002e0c <set_mapping.constprop.0+0x1e4>
	int ret = 0;
    40002e50:	52800000 	mov	w0, #0x0                   	// #0
}
    40002e54:	f9400bf3 	ldr	x19, [sp, #16]
    40002e58:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002e5c:	d65f03c0 	ret

0000000040002e60 <__add_map.constprop.0>:
{
	unsigned int mem_type;
	uint64_t desc = 0U;

	/* NS bit for security memory access from secure state */
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    40002e60:	d37f7c65 	ubfiz	x5, x3, #1, #32
	 *     10      RO   NA
	 *     11      RO   RO
	 */

	/* AP bits for Data access permission */
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    40002e64:	f27d007f 	tst	x3, #0x8
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    40002e68:	927b00a7 	and	x7, x5, #0x20

	/* Mirror permissions to EL0 */
	desc |= (attrs & MT_RW_AP_ELx) ?
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    40002e6c:	53017c65 	lsr	w5, w3, #1
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    40002e70:	9a9f17e4 	cset	x4, eq  // eq = none
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    40002e74:	927a00a5 	and	x5, x5, #0x40
    40002e78:	aa0700a5 	orr	x5, x5, x7
	/* the access flag */
	desc |= PTE_BLOCK_DESC_AF;

	/* memory attribute index field */
	mem_type = MT_TYPE(attrs);
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    40002e7c:	d37e0867 	ubfiz	x7, x3, #2, #3
    40002e80:	aa041ce4 	orr	x4, x7, x4, lsl #7
	}

	return desc;
}

static int __add_map(struct arm_mmu_ptables *ptables, const char *name,
    40002e84:	aa0003e6 	mov	x6, x0
    40002e88:	aa0400a5 	orr	x5, x5, x4
    40002e8c:	aa0103e0 	mov	x0, x1
    40002e90:	aa0203e1 	mov	x1, x2
	mem_type = MT_TYPE(attrs);
    40002e94:	12000862 	and	w2, w3, #0x7
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    40002e98:	b27600a4 	orr	x4, x5, #0x400
	switch (mem_type) {
    40002e9c:	7100085f 	cmp	w2, #0x2
    40002ea0:	54000109 	b.ls	40002ec0 <__add_map.constprop.0+0x60>  // b.plast
    40002ea4:	51000c47 	sub	w7, w2, #0x3
    40002ea8:	710004ff 	cmp	w7, #0x1
    40002eac:	54000129 	b.ls	40002ed0 <__add_map.constprop.0+0x70>  // b.plast
		     uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
	uint64_t desc = get_region_desc(attrs);
	bool may_overwrite = !(attrs & MT_NO_OVERWRITE);
    40002eb0:	d2780063 	eor	x3, x3, #0x100
	MMU_DEBUG("mmap [%s]: virt %lx phys %lx size %lx attr %llx\n",
		  name, virt, phys, size, desc);
	__ASSERT(((virt | phys | size) & (CONFIG_MMU_PAGE_SIZE - 1)) == 0,
		 "address/size are not page aligned\n");
	desc |= phys;
	return set_mapping(ptables, virt, size, desc, may_overwrite);
    40002eb4:	aa0400c2 	orr	x2, x6, x4
    40002eb8:	53082063 	ubfx	w3, w3, #8, #1
    40002ebc:	17ffff5b 	b	40002c28 <set_mapping.constprop.0>
		desc |= PTE_BLOCK_DESC_UXN;
    40002ec0:	d280c004 	mov	x4, #0x600                 	// #1536
    40002ec4:	f2e00c04 	movk	x4, #0x60, lsl #48
    40002ec8:	aa0400a4 	orr	x4, x5, x4
		break;
    40002ecc:	17fffff9 	b	40002eb0 <__add_map.constprop.0+0x50>
		if ((attrs & MT_RW) || (attrs & MT_P_EXECUTE_NEVER))
    40002ed0:	52800507 	mov	w7, #0x28                  	// #40
    40002ed4:	6a07007f 	tst	w3, w7
    40002ed8:	54000080 	b.eq	40002ee8 <__add_map.constprop.0+0x88>  // b.none
			desc |= PTE_BLOCK_DESC_PXN;
    40002edc:	d2808004 	mov	x4, #0x400                 	// #1024
    40002ee0:	f2e00404 	movk	x4, #0x20, lsl #48
    40002ee4:	aa0400a4 	orr	x4, x5, x4
		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    40002ee8:	52801105 	mov	w5, #0x88                  	// #136
    40002eec:	0a050065 	and	w5, w3, w5
    40002ef0:	710220bf 	cmp	w5, #0x88
    40002ef4:	54000040 	b.eq	40002efc <__add_map.constprop.0+0x9c>  // b.none
    40002ef8:	36300043 	tbz	w3, #6, 40002f00 <__add_map.constprop.0+0xa0>
			desc |= PTE_BLOCK_DESC_UXN;
    40002efc:	b24a0084 	orr	x4, x4, #0x40000000000000
			desc |= PTE_BLOCK_DESC_INNER_SHARE;
    40002f00:	b2780485 	orr	x5, x4, #0x300
    40002f04:	7100105f 	cmp	w2, #0x4
    40002f08:	b2770084 	orr	x4, x4, #0x200
    40002f0c:	9a851084 	csel	x4, x4, x5, ne  // ne = any
    40002f10:	17ffffe8 	b	40002eb0 <__add_map.constprop.0+0x50>

0000000040002f14 <z_arm64_mm_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Management Unit (MMU).
 */
void z_arm64_mm_init(bool is_primary_core)
{
    40002f14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	__ASSERT((read_sctlr_el1() & SCTLR_M_BIT) == 0, "MMU is already enabled\n");

	/*
	 * Only booting core setup up the page tables.
	 */
	if (is_primary_core) {
    40002f18:	72001c1f 	tst	w0, #0xff
{
    40002f1c:	910003fd 	mov	x29, sp
    40002f20:	a90153f3 	stp	x19, x20, [sp, #16]
    40002f24:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002f28:	b0000075 	adrp	x21, 4000f000 <z_idle_threads>
    40002f2c:	f9001bf7 	str	x23, [sp, #48]
	if (is_primary_core) {
    40002f30:	54000360 	b.eq	40002f9c <z_arm64_mm_init+0x88>  // b.none
		kernel_ptables.base_xlat_table = new_table();
    40002f34:	97ffff1d 	bl	40002ba8 <new_table>
    40002f38:	f90302a0 	str	x0, [x21, #1536]
	for (index = 0U; index < mmu_config.num_regions; index++) {
    40002f3c:	f0000000 	adrp	x0, 40005000 <__rodata_region_start>
    40002f40:	b94e7001 	ldr	w1, [x0, #3696]
    40002f44:	f0000013 	adrp	x19, 40005000 <__rodata_region_start>
    40002f48:	913be273 	add	x19, x19, #0xef8
    40002f4c:	2a0103f7 	mov	w23, w1
    40002f50:	aa0003f4 	mov	x20, x0
    40002f54:	52800076 	mov	w22, #0x3                   	// #3
	size_t size = (uintptr_t)range->end - address;
    40002f58:	a9408a61 	ldp	x1, x2, [x19, #8]
	if (size) {
    40002f5c:	eb010042 	subs	x2, x2, x1
    40002f60:	54000080 	b.eq	40002f70 <z_arm64_mm_init+0x5c>  // b.none
		__add_map(ptables, range->name, address, address,
    40002f64:	b9401a63 	ldr	w3, [x19, #24]
    40002f68:	aa0103e0 	mov	x0, x1
    40002f6c:	97ffffbd 	bl	40002e60 <__add_map.constprop.0>
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    40002f70:	91008273 	add	x19, x19, #0x20
    40002f74:	710006d6 	subs	w22, w22, #0x1
    40002f78:	54ffff01 	b.ne	40002f58 <z_arm64_mm_init+0x44>  // b.any
		region = &mmu_config.mmu_regions[index];
    40002f7c:	9139c294 	add	x20, x20, #0xe70
    40002f80:	d2800013 	mov	x19, #0x0                   	// #0
    40002f84:	d2800516 	mov	x22, #0x28                  	// #40
	for (index = 0U; index < mmu_config.num_regions; index++) {
    40002f88:	6b1302ff 	cmp	w23, w19
    40002f8c:	54000348 	b.hi	40002ff4 <z_arm64_mm_init+0xe0>  // b.pmore
	__asm__ volatile (
    40002f90:	d508871f 	tlbi	vmalle1
    40002f94:	d5033f9f 	dsb	sy
    40002f98:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(mair)
    40002f9c:	d2808000 	mov	x0, #0x400                 	// #1024
    40002fa0:	f2a88180 	movk	x0, #0x440c, lsl #16
    40002fa4:	f2d77fe0 	movk	x0, #0xbbff, lsl #32
    40002fa8:	d518a200 	msr	mair_el1, x0
MAKE_REG_HELPER_EL123(tcr)
    40002fac:	d286a400 	mov	x0, #0x3520                	// #13600
    40002fb0:	f2a01000 	movk	x0, #0x80, lsl #16
    40002fb4:	d5182040 	msr	tcr_el1, x0
MAKE_REG_HELPER_EL123(ttbr0)
    40002fb8:	f94302a0 	ldr	x0, [x21, #1536]
    40002fbc:	d5182000 	msr	ttbr0_el1, x0
	isb();
    40002fc0:	d5033fdf 	isb

__syscall int sys_cache_data_all(int op);
static inline int z_impl_sys_cache_data_all(int op)
{
#if defined(CONFIG_CACHE_MANAGEMENT)
	return cache_data_all(op);
    40002fc4:	52800040 	mov	w0, #0x2                   	// #2
    40002fc8:	94000018 	bl	40003028 <arch_dcache_all>
MAKE_REG_HELPER_EL123(sctlr)
    40002fcc:	d5381000 	mrs	x0, sctlr_el1
	write_sctlr_el1(val | SCTLR_M_BIT | SCTLR_C_BIT);
    40002fd0:	d28000a1 	mov	x1, #0x5                   	// #5
    40002fd4:	aa010000 	orr	x0, x0, x1
    40002fd8:	d5181000 	msr	sctlr_el1, x0
	isb();
    40002fdc:	d5033fdf 	isb
		setup_page_tables(&kernel_ptables);
	}

	/* currently only EL1 is supported */
	enable_mmu_el1(&kernel_ptables, flags);
}
    40002fe0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002fe4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002fe8:	f9401bf7 	ldr	x23, [sp, #48]
    40002fec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002ff0:	d65f03c0 	ret
		region = &mmu_config.mmu_regions[index];
    40002ff4:	f9400685 	ldr	x5, [x20, #8]
    40002ff8:	9b167e64 	mul	x4, x19, x22
    40002ffc:	8b0400a0 	add	x0, x5, x4
	if (region->size || region->attrs) {
    40003000:	f9400802 	ldr	x2, [x0, #16]
    40003004:	b9402003 	ldr	w3, [x0, #32]
    40003008:	b5000042 	cbnz	x2, 40003010 <z_arm64_mm_init+0xfc>
    4000300c:	340000a3 	cbz	w3, 40003020 <z_arm64_mm_init+0x10c>
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    40003010:	f9400401 	ldr	x1, [x0, #8]
    40003014:	32180063 	orr	w3, w3, #0x100
    40003018:	f86468a0 	ldr	x0, [x5, x4]
    4000301c:	97ffff91 	bl	40002e60 <__add_map.constprop.0>
	for (index = 0U; index < mmu_config.num_regions; index++) {
    40003020:	91000673 	add	x19, x19, #0x1
    40003024:	17ffffd9 	b	40002f88 <z_arm64_mm_init+0x74>

0000000040003028 <arch_dcache_all>:
{
	uint32_t clidr_el1, csselr_el1, ccsidr_el1;
	uint8_t loc, ctype, cache_level, line_size, way_pos;
	uint32_t max_ways, max_sets, dc_val, set, way;

	if (op != K_CACHE_INVD && op != K_CACHE_WB && op != K_CACHE_WB_INVD)
    40003028:	51000401 	sub	w1, w0, #0x1
    4000302c:	7100083f 	cmp	w1, #0x2
    40003030:	540006a8 	b.hi	40003104 <arch_dcache_all+0xdc>  // b.pmore
		return -ENOTSUP;

	/* Data barrier before start */
	dsb();
    40003034:	d5033f9f 	dsb	sy
MAKE_REG_HELPER(clidr_el1);
    40003038:	d5390021 	mrs	x1, clidr_el1

	clidr_el1 = read_clidr_el1();
    4000303c:	2a0103ea 	mov	w10, w1

	loc = (clidr_el1 >> CLIDR_EL1_LOC_SHIFT) & CLIDR_EL1_LOC_MASK;
    40003040:	53186829 	ubfx	w9, w1, #24, #3
	if (!loc)
    40003044:	7208083f 	tst	w1, #0x7000000
    40003048:	54000620 	b.eq	4000310c <arch_dcache_all+0xe4>  // b.none
    4000304c:	d2800001 	mov	x1, #0x0                   	// #0
		return 0;

	for (cache_level = 0; cache_level < loc; cache_level++) {
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    40003050:	0b010422 	add	w2, w1, w1, lsl #1
    40003054:	531f782b 	lsl	w11, w1, #1
    40003058:	1ac22542 	lsr	w2, w10, w2
				& CLIDR_EL1_CTYPE_MASK;
		/* No data cache, continue */
		if (ctype < 2)
    4000305c:	721f045f 	tst	w2, #0x6
    40003060:	54000320 	b.eq	400030c4 <arch_dcache_all+0x9c>  // b.none
MAKE_REG_HELPER(csselr_el1);
    40003064:	d37ff822 	lsl	x2, x1, #1
    40003068:	d51a0002 	msr	csselr_el1, x2
			continue;

		/* select cache level */
		csselr_el1 = cache_level << 1;
		write_csselr_el1(csselr_el1);
		isb();
    4000306c:	d5033fdf 	isb
MAKE_REG_HELPER(ccsidr_el1);
    40003070:	d5390002 	mrs	x2, ccsidr_el1

		ccsidr_el1 = read_ccsidr_el1();
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
				& CCSIDR_EL1_LN_SZ_MASK) + 4;
    40003074:	12000847 	and	w7, w2, #0x7
		max_ways = (ccsidr_el1 >> CCSIDR_EL1_WAYS_SHIFT)
    40003078:	53033048 	ubfx	w8, w2, #3, #10
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
    4000307c:	110010e7 	add	w7, w7, #0x4
				& CCSIDR_EL1_WAYS_MASK;
		max_sets = (ccsidr_el1 >> CCSIDR_EL1_SETS_SHIFT)
    40003080:	530d6c42 	ubfx	w2, w2, #13, #15
				& CCSIDR_EL1_SETS_MASK;
		/* 32-log2(ways), bit position of way in DC operand */
		way_pos = __builtin_clz(max_ways);
    40003084:	5ac0110c 	clz	w12, w8

		for (set = 0; set <= max_sets; set++) {
    40003088:	52800005 	mov	w5, #0x0                   	// #0
				/* way number, aligned to pos in DC operand */
				dc_val = way << way_pos;
				/* cache level, aligned to pos in DC operand */
				dc_val |= csselr_el1;
				/* set number, aligned to pos in DC operand */
				dc_val |= set << line_size;
    4000308c:	1ac720a6 	lsl	w6, w5, w7
    40003090:	2a0b00c6 	orr	w6, w6, w11
			for (way = 0; way <= max_ways; way++) {
    40003094:	52800004 	mov	w4, #0x0                   	// #0
				dc_val = way << way_pos;
    40003098:	1acc2083 	lsl	w3, w4, w12

				if (op == K_CACHE_INVD) {
    4000309c:	7100081f 	cmp	w0, #0x2
				dc_val |= set << line_size;
    400030a0:	2a060063 	orr	w3, w3, w6
				if (op == K_CACHE_INVD) {
    400030a4:	54000201 	b.ne	400030e4 <arch_dcache_all+0xbc>  // b.any
					dc_ops("isw", dc_val);
    400030a8:	d5087643 	dc	isw, x3
			for (way = 0; way <= max_ways; way++) {
    400030ac:	11000484 	add	w4, w4, #0x1
    400030b0:	6b04011f 	cmp	w8, w4
    400030b4:	54ffff22 	b.cs	40003098 <arch_dcache_all+0x70>  // b.hs, b.nlast
		for (set = 0; set <= max_sets; set++) {
    400030b8:	110004a5 	add	w5, w5, #0x1
    400030bc:	6b05005f 	cmp	w2, w5
    400030c0:	54fffe62 	b.cs	4000308c <arch_dcache_all+0x64>  // b.hs, b.nlast
	for (cache_level = 0; cache_level < loc; cache_level++) {
    400030c4:	91000421 	add	x1, x1, #0x1
    400030c8:	6b21013f 	cmp	w9, w1, uxtb
    400030cc:	54fffc28 	b.hi	40003050 <arch_dcache_all+0x28>  // b.pmore
MAKE_REG_HELPER(csselr_el1);
    400030d0:	d2800000 	mov	x0, #0x0                   	// #0
    400030d4:	d51a0000 	msr	csselr_el1, x0
		}
	}

	/* Restore csselr_el1 to level 0 */
	write_csselr_el1(0);
	dsb();
    400030d8:	d5033f9f 	dsb	sy
	isb();
    400030dc:	d5033fdf 	isb

	return 0;
}
    400030e0:	d65f03c0 	ret
				} else if (op == K_CACHE_WB_INVD) {
    400030e4:	71000c1f 	cmp	w0, #0x3
    400030e8:	54000061 	b.ne	400030f4 <arch_dcache_all+0xcc>  // b.any
					dc_ops("cisw", dc_val);
    400030ec:	d5087e43 	dc	cisw, x3
    400030f0:	17ffffef 	b	400030ac <arch_dcache_all+0x84>
				} else if (op == K_CACHE_WB) {
    400030f4:	7100041f 	cmp	w0, #0x1
    400030f8:	54fffda1 	b.ne	400030ac <arch_dcache_all+0x84>  // b.any
					dc_ops("csw", dc_val);
    400030fc:	d5087a43 	dc	csw, x3
    40003100:	17ffffeb 	b	400030ac <arch_dcache_all+0x84>
		return -ENOTSUP;
    40003104:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    40003108:	17fffff6 	b	400030e0 <arch_dcache_all+0xb8>
		return 0;
    4000310c:	52800000 	mov	w0, #0x0                   	// #0
    40003110:	17fffff4 	b	400030e0 <arch_dcache_all+0xb8>

0000000040003114 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    40003114:	aa0003e1 	mov	x1, x0
	size_t n = 0;
    40003118:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0') {
    4000311c:	38606822 	ldrb	w2, [x1, x0]
    40003120:	35000042 	cbnz	w2, 40003128 <strlen+0x14>
		s++;
		n++;
	}

	return n;
}
    40003124:	d65f03c0 	ret
		n++;
    40003128:	91000400 	add	x0, x0, #0x1
    4000312c:	17fffffc 	b	4000311c <strlen+0x8>

0000000040003130 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    40003130:	aa0003e2 	mov	x2, x0
	size_t n = 0;
    40003134:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0' && n < maxlen) {
    40003138:	38606843 	ldrb	w3, [x2, x0]
    4000313c:	34000063 	cbz	w3, 40003148 <strnlen+0x18>
    40003140:	eb01001f 	cmp	x0, x1
    40003144:	54000041 	b.ne	4000314c <strnlen+0x1c>  // b.any
		s++;
		n++;
	}

	return n;
}
    40003148:	d65f03c0 	ret
		n++;
    4000314c:	91000400 	add	x0, x0, #0x1
    40003150:	17fffffa 	b	40003138 <strnlen+0x8>

0000000040003154 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    40003154:	12800000 	mov	w0, #0xffffffff            	// #-1
    40003158:	d65f03c0 	ret

000000004000315c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    4000315c:	f00002a1 	adrp	x1, 4005a000 <z_interrupt_stacks+0x950>
    40003160:	f9035c20 	str	x0, [x1, #1720]
}
    40003164:	d65f03c0 	ret

0000000040003168 <gic_get_rdist>:
MAKE_REG_HELPER(tpidrro_el0);
    40003168:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
    4000316c:	927db000 	and	x0, x0, #0xfffffffffff8
atomic_t nlpi_intid = ATOMIC_INIT(8192);
#endif

static inline mem_addr_t gic_get_rdist(void)
{
	return gic_rdists[arch_curr_cpu()->id];
    40003170:	39409001 	ldrb	w1, [x0, #36]
}
    40003174:	90000060 	adrp	x0, 4000f000 <z_idle_threads>
    40003178:	91182000 	add	x0, x0, #0x608
    4000317c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    40003180:	d65f03c0 	ret

0000000040003184 <gic_wait_rwp.isra.0>:
static int gic_wait_rwp(uint32_t intid)
{
	uint32_t rwp_mask;
	mem_addr_t base;

	if (intid < GIC_SPI_INT_BASE) {
    40003184:	71007c1f 	cmp	w0, #0x1f
    40003188:	54000168 	b.hi	400031b4 <gic_wait_rwp.isra.0+0x30>  // b.pmore
static int gic_wait_rwp(uint32_t intid)
    4000318c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003190:	910003fd 	mov	x29, sp
		base = (gic_get_rdist() + GICR_CTLR);
    40003194:	97fffff5 	bl	40003168 <gic_get_rdist>
		rwp_mask = BIT(GICR_CTLR_RWP);
    40003198:	52800101 	mov	w1, #0x8                   	// #8

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	uint32_t val;

	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000319c:	b9400002 	ldr	w2, [x0]

	__DMB();
    400031a0:	d5033fbf 	dmb	sy
	} else {
		base = GICD_CTLR;
		rwp_mask = BIT(GICD_CTLR_RWP);
	}

	while (sys_read32(base) & rwp_mask)
    400031a4:	6a01005f 	tst	w2, w1
    400031a8:	54ffffa1 	b.ne	4000319c <gic_wait_rwp.isra.0+0x18>  // b.any
		;

	return 0;
}
    400031ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400031b0:	d65f03c0 	ret
		base = GICD_CTLR;
    400031b4:	d2a10000 	mov	x0, #0x8000000             	// #134217728
		rwp_mask = BIT(GICD_CTLR_RWP);
    400031b8:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    400031bc:	b9400002 	ldr	w2, [x0]
	__DMB();
    400031c0:	d5033fbf 	dmb	sy
	while (sys_read32(base) & rwp_mask)
    400031c4:	6a01005f 	tst	w2, w1
    400031c8:	54ffffa1 	b.ne	400031bc <gic_wait_rwp.isra.0+0x38>  // b.any
    400031cc:	d65f03c0 	ret

00000000400031d0 <arm_gic_init>:

	gicv3_cpuif_init();
}

int arm_gic_init(const struct device *unused)
{
    400031d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    400031d4:	d2800083 	mov	x3, #0x4                   	// #4
    400031d8:	f2a10003 	movk	x3, #0x800, lsl #16
    400031dc:	910003fd 	mov	x29, sp
    400031e0:	b9400063 	ldr	w3, [x3]
	__DMB();
    400031e4:	d5033fbf 	dmb	sy
	num_ints = (num_ints + 1) << 5;
    400031e8:	531b1063 	ubfiz	w3, w3, #5, #5
    400031ec:	11008063 	add	w3, w3, #0x20
	return val;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	__DMB();
    400031f0:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400031f4:	52800000 	mov	w0, #0x0                   	// #0
    400031f8:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    400031fc:	b9000020 	str	w0, [x1]
	gic_wait_rwp(GIC_SPI_INT_BASE);
    40003200:	52800400 	mov	w0, #0x20                  	// #32
    40003204:	97ffffe0 	bl	40003184 <gic_wait_rwp.isra.0>
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40003208:	52803005 	mov	w5, #0x180                 	// #384
    4000320c:	72a10005 	movk	w5, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40003210:	52805006 	mov	w6, #0x280                 	// #640
    40003214:	72a10006 	movk	w6, #0x800, lsl #16
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    40003218:	52801008 	mov	w8, #0x80                  	// #128
    4000321c:	72a10008 	movk	w8, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40003220:	5281a009 	mov	w9, #0xd00                 	// #3328
    40003224:	72a10009 	movk	w9, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40003228:	52800401 	mov	w1, #0x20                  	// #32
    4000322c:	12800002 	mov	w2, #0xffffffff            	// #-1
    40003230:	52800007 	mov	w7, #0x0                   	// #0
    40003234:	6b01007f 	cmp	w3, w1
    40003238:	54000ba8 	b.hi	400033ac <arm_gic_init+0x1dc>  // b.pmore
	gic_wait_rwp(GIC_SPI_INT_BASE);
    4000323c:	52800400 	mov	w0, #0x20                  	// #32
    40003240:	97ffffd1 	bl	40003184 <gic_wait_rwp.isra.0>
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40003244:	d2808400 	mov	x0, #0x420                 	// #1056
    40003248:	f2a10000 	movk	x0, #0x800, lsl #16
    4000324c:	529f8002 	mov	w2, #0xfc00                	// #64512
    40003250:	72beffe2 	movk	w2, #0xf7ff, lsl #16
    40003254:	52941404 	mov	w4, #0xa0a0                	// #41120
    40003258:	72b41404 	movk	w4, #0xa0a0, lsl #16
    4000325c:	0b020001 	add	w1, w0, w2
    40003260:	6b01007f 	cmp	w3, w1
    40003264:	54000c48 	b.hi	400033ec <arm_gic_init+0x21c>  // b.pmore
		sys_write32(0, ICFGR(base, idx));
    40003268:	52818004 	mov	w4, #0xc00                 	// #3072
    4000326c:	72a10004 	movk	w4, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40003270:	52800401 	mov	w1, #0x20                  	// #32
    40003274:	52800002 	mov	w2, #0x0                   	// #0
    40003278:	6b01007f 	cmp	w3, w1
    4000327c:	54000c08 	b.hi	400033fc <arm_gic_init+0x22c>  // b.pmore
extern "C" {
#endif

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    40003280:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    40003284:	b9400020 	ldr	w0, [x1]

	*(volatile uint32_t *)addr = temp | (1 << bit);
    40003288:	321e0000 	orr	w0, w0, #0x4
    4000328c:	b9000020 	str	w0, [x1]
    40003290:	d53bd060 	mrs	x0, tpidrro_el0
    40003294:	927db000 	and	x0, x0, #0xfffffffffff8
	cpu = arch_curr_cpu()->id;
    40003298:	39409002 	ldrb	w2, [x0, #36]
	gic_rdists[cpu] = GIC_RDIST_BASE + MPIDR_TO_CORE(GET_MPIDR()) * 0x20000;
    4000329c:	d53800a0 	mrs	x0, mpidr_el1
    400032a0:	92401c00 	and	x0, x0, #0xff
    400032a4:	90000061 	adrp	x1, 4000f000 <z_idle_threads>
    400032a8:	91182021 	add	x1, x1, #0x608
    400032ac:	91101400 	add	x0, x0, #0x405
    400032b0:	d36fb800 	lsl	x0, x0, #17
    400032b4:	f822d820 	str	x0, [x1, w2, sxtw #3]
	gicv3_rdist_enable(gic_get_rdist());
    400032b8:	97ffffac 	bl	40003168 <gic_get_rdist>
	if (!(sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA)))
    400032bc:	91005002 	add	x2, x0, #0x14
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    400032c0:	b9400041 	ldr	w1, [x2]
	__DMB();
    400032c4:	d5033fbf 	dmb	sy
    400032c8:	361000e1 	tbz	w1, #2, 400032e4 <arm_gic_init+0x114>
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    400032cc:	b9401401 	ldr	w1, [x0, #20]

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    400032d0:	121e7821 	and	w1, w1, #0xfffffffd
    400032d4:	b9001401 	str	w1, [x0, #20]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    400032d8:	b9400040 	ldr	w0, [x2]
	__DMB();
    400032dc:	d5033fbf 	dmb	sy
	while (sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA))
    400032e0:	3717ffc0 	tbnz	w0, #2, 400032d8 <arm_gic_init+0x108>
	mem_addr_t base = gic_get_rdist() + GICR_SGI_BASE_OFF;
    400032e4:	97ffffa1 	bl	40003168 <gic_get_rdist>
    400032e8:	aa0003e3 	mov	x3, x0
	__DMB();
    400032ec:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICENABLER(base, 0));
    400032f0:	91404000 	add	x0, x0, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400032f4:	12800004 	mov	w4, #0xffffffff            	// #-1
    400032f8:	91060000 	add	x0, x0, #0x180
    400032fc:	b9000004 	str	w4, [x0]
	gic_wait_rwp(0);
    40003300:	52800000 	mov	w0, #0x0                   	// #0
    40003304:	97ffffa0 	bl	40003184 <gic_wait_rwp.isra.0>
	__DMB();
    40003308:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICPENDR(base, 0));
    4000330c:	91404060 	add	x0, x3, #0x10, lsl #12
    40003310:	910a0000 	add	x0, x0, #0x280
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003314:	b9000004 	str	w4, [x0]
	__DMB();
    40003318:	d5033fbf 	dmb	sy
	sys_write32(IGROUPR_VAL, IGROUPR(base, 0));
    4000331c:	91404061 	add	x1, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003320:	52800000 	mov	w0, #0x0                   	// #0
    40003324:	91020021 	add	x1, x1, #0x80
    40003328:	b9000020 	str	w0, [x1]
	__DMB();
    4000332c:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), IGROUPMODR(base, 0));
    40003330:	91404060 	add	x0, x3, #0x10, lsl #12
    40003334:	91340000 	add	x0, x0, #0xd00
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003338:	b9000004 	str	w4, [x0]
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    4000333c:	91404060 	add	x0, x3, #0x10, lsl #12
    40003340:	91404061 	add	x1, x3, #0x10, lsl #12
    40003344:	91100000 	add	x0, x0, #0x400
    40003348:	91108021 	add	x1, x1, #0x420
    4000334c:	52941402 	mov	w2, #0xa0a0                	// #41120
    40003350:	72b41402 	movk	w2, #0xa0a0, lsl #16
	__DMB();
    40003354:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003358:	b9000002 	str	w2, [x0]
    4000335c:	91001000 	add	x0, x0, #0x4
    40003360:	eb01001f 	cmp	x0, x1
    40003364:	54ffff81 	b.ne	40003354 <arm_gic_init+0x184>  // b.any
	__DMB();
    40003368:	d5033fbf 	dmb	sy
	sys_write32(0, ICFGR(base, 1));
    4000336c:	91404063 	add	x3, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003370:	52800000 	mov	w0, #0x0                   	// #0
    40003374:	91301063 	add	x3, x3, #0xc04
    40003378:	b9000060 	str	w0, [x3]
	icc_sre = read_sysreg(ICC_SRE_EL1);
    4000337c:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	if (!(icc_sre & ICC_SRE_ELx_SRE_BIT)) {
    40003380:	37000080 	tbnz	w0, #0, 40003390 <arm_gic_init+0x1c0>
		icc_sre = (icc_sre | ICC_SRE_ELx_SRE_BIT |
    40003384:	32000800 	orr	w0, w0, #0x7
		write_sysreg(icc_sre, ICC_SRE_EL1);
    40003388:	d518cca0 	msr	s3_0_c12_c12_5, x0
		icc_sre = read_sysreg(ICC_SRE_EL1);
    4000338c:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	write_sysreg(GIC_IDLE_PRIO, ICC_PMR_EL1);
    40003390:	52801fe0 	mov	w0, #0xff                  	// #255
    40003394:	d5184600 	msr	s3_0_c4_c6_0, x0
	write_sysreg(1, ICC_IGRPEN1_EL1);
    40003398:	52800020 	mov	w0, #0x1                   	// #1
    4000339c:	d518cce0 	msr	s3_0_c12_c12_7, x0
	gicv3_dist_init();

	__arm_gic_init();

	return 0;
}
    400033a0:	52800000 	mov	w0, #0x0                   	// #0
    400033a4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400033a8:	d65f03c0 	ret
		idx = intid / GIC_NUM_INTR_PER_REG;
    400033ac:	53057c20 	lsr	w0, w1, #5
			    ICENABLER(base, idx));
    400033b0:	531e7400 	lsl	w0, w0, #2
	__DMB();
    400033b4:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400033b8:	0b050004 	add	w4, w0, w5
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400033bc:	b9000082 	str	w2, [x4]
	__DMB();
    400033c0:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400033c4:	0b060004 	add	w4, w0, w6
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400033c8:	b9000082 	str	w2, [x4]
	__DMB();
    400033cc:	d5033fbf 	dmb	sy
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    400033d0:	0b080004 	add	w4, w0, w8
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400033d4:	b9000087 	str	w7, [x4]
	__DMB();
    400033d8:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400033dc:	0b090000 	add	w0, w0, w9
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400033e0:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_INTR_PER_REG) {
    400033e4:	11008021 	add	w1, w1, #0x20
    400033e8:	17ffff93 	b	40003234 <arm_gic_init+0x64>
	__DMB();
    400033ec:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400033f0:	b9000004 	str	w4, [x0]
	     intid += GIC_NUM_PRI_PER_REG) {
    400033f4:	91001000 	add	x0, x0, #0x4
    400033f8:	17ffff99 	b	4000325c <arm_gic_init+0x8c>
	__DMB();
    400033fc:	d5033fbf 	dmb	sy
		idx = intid / GIC_NUM_CFG_PER_REG;
    40003400:	53047c20 	lsr	w0, w1, #4
		sys_write32(0, ICFGR(base, idx));
    40003404:	0b000880 	add	w0, w4, w0, lsl #2
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003408:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_CFG_PER_REG) {
    4000340c:	11004021 	add	w1, w1, #0x10
    40003410:	17ffff9a 	b	40003278 <arm_gic_init+0xa8>

0000000040003414 <arm_gic_irq_set_priority>:
{
    40003414:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003418:	2a0003e3 	mov	w3, w0
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000341c:	12001000 	and	w0, w0, #0x1f
{
    40003420:	910003fd 	mov	x29, sp
    40003424:	2a0203e6 	mov	w6, w2
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    40003428:	d2800022 	mov	x2, #0x1                   	// #1
{
    4000342c:	2a0103e7 	mov	w7, w1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    40003430:	53057c64 	lsr	w4, w3, #5
	mem_addr_t base = GET_DIST_BASE(intid);
    40003434:	71007c7f 	cmp	w3, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    40003438:	9ac02042 	lsl	x2, x2, x0
	mem_addr_t base = GET_DIST_BASE(intid);
    4000343c:	54000468 	b.hi	400034c8 <arm_gic_irq_set_priority+0xb4>  // b.pmore
    40003440:	97ffff4a 	bl	40003168 <gic_get_rdist>
    40003444:	91404005 	add	x5, x0, #0x10, lsl #12
	__DMB();
    40003448:	d5033fbf 	dmb	sy
	sys_write32(mask, ICENABLER(base, idx));
    4000344c:	531e7484 	lsl	w4, w4, #2
    40003450:	11060084 	add	w4, w4, #0x180
    40003454:	8b2440a4 	add	x4, x5, w4, uxtw
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003458:	b9000082 	str	w2, [x4]
	gic_wait_rwp(intid);
    4000345c:	2a0303e0 	mov	w0, w3
    40003460:	97ffff49 	bl	40003184 <gic_wait_rwp.isra.0>
	__DMB();
    40003464:	d5033fbf 	dmb	sy
	sys_write8(prio & GIC_PRI_MASK, IPRIORITYR(base, intid));
    40003468:	2a0303e0 	mov	w0, w3
    4000346c:	91100000 	add	x0, x0, #0x400
    40003470:	8b050000 	add	x0, x0, x5
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    40003474:	39000007 	strb	w7, [x0]
	if (!GIC_IS_SGI(intid)) {
    40003478:	71003c7f 	cmp	w3, #0xf
    4000347c:	54000229 	b.ls	400034c0 <arm_gic_irq_set_priority+0xac>  // b.plast
		idx = intid / GIC_NUM_CFG_PER_REG;
    40003480:	53047c60 	lsr	w0, w3, #4
		shift = (intid & (GIC_NUM_CFG_PER_REG - 1)) * 2;
    40003484:	531f0c64 	ubfiz	w4, w3, #1, #4
		val = sys_read32(ICFGR(base, idx));
    40003488:	531e7400 	lsl	w0, w0, #2
    4000348c:	11300000 	add	w0, w0, #0xc00
    40003490:	8b2040a0 	add	x0, x5, w0, uxtw
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40003494:	b9400002 	ldr	w2, [x0]
	__DMB();
    40003498:	d5033fbf 	dmb	sy
		val &= ~(GICD_ICFGR_MASK << shift);
    4000349c:	d2800061 	mov	x1, #0x3                   	// #3
    400034a0:	9ac42021 	lsl	x1, x1, x4
    400034a4:	0a210041 	bic	w1, w2, w1
		if (flags & IRQ_TYPE_EDGE) {
    400034a8:	36100086 	tbz	w6, #2, 400034b8 <arm_gic_irq_set_priority+0xa4>
			val |= (GICD_ICFGR_TYPE << shift);
    400034ac:	d2800042 	mov	x2, #0x2                   	// #2
    400034b0:	9ac42042 	lsl	x2, x2, x4
    400034b4:	2a020021 	orr	w1, w1, w2
	__DMB();
    400034b8:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400034bc:	b9000001 	str	w1, [x0]
}
    400034c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400034c4:	d65f03c0 	ret
	mem_addr_t base = GET_DIST_BASE(intid);
    400034c8:	d2a10005 	mov	x5, #0x8000000             	// #134217728
    400034cc:	17ffffdf 	b	40003448 <arm_gic_irq_set_priority+0x34>

00000000400034d0 <arm_gic_irq_enable>:
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    400034d0:	12001001 	and	w1, w0, #0x1f
    400034d4:	d2800023 	mov	x3, #0x1                   	// #1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    400034d8:	53057c02 	lsr	w2, w0, #5
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    400034dc:	71007c1f 	cmp	w0, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    400034e0:	9ac12063 	lsl	x3, x3, x1
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    400034e4:	54000188 	b.hi	40003514 <arm_gic_irq_enable+0x44>  // b.pmore
{
    400034e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400034ec:	910003fd 	mov	x29, sp
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    400034f0:	97ffff1e 	bl	40003168 <gic_get_rdist>
    400034f4:	91404000 	add	x0, x0, #0x10, lsl #12
    400034f8:	91040000 	add	x0, x0, #0x100
	__DMB();
    400034fc:	d5033fbf 	dmb	sy
    40003500:	d37e6842 	ubfiz	x2, x2, #2, #27
    40003504:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003508:	b9000043 	str	w3, [x2]
}
    4000350c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003510:	d65f03c0 	ret
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    40003514:	d2802000 	mov	x0, #0x100                 	// #256
    40003518:	f2a10000 	movk	x0, #0x800, lsl #16
	__DMB();
    4000351c:	d5033fbf 	dmb	sy
    40003520:	d37e6842 	ubfiz	x2, x2, #2, #27
    40003524:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003528:	b9000043 	str	w3, [x2]
    4000352c:	d65f03c0 	ret

0000000040003530 <arm_gic_get_active>:
	intid = read_sysreg(ICC_IAR1_EL1);
    40003530:	d538cc00 	mrs	x0, s3_0_c12_c12_0
}
    40003534:	d65f03c0 	ret

0000000040003538 <arm_gic_eoi>:
	__DSB();
    40003538:	d5033f9f 	dsb	sy
	write_sysreg(intid, ICC_EOIR1_EL1);
    4000353c:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    40003540:	d65f03c0 	ret

0000000040003544 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    40003544:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    40003548:	90000061 	adrp	x1, 4000f000 <z_idle_threads>
    4000354c:	d0000000 	adrp	x0, 40005000 <__rodata_region_start>
    40003550:	91010000 	add	x0, x0, #0x40
{
    40003554:	910003fd 	mov	x29, sp
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    40003558:	f9030820 	str	x0, [x1, #1552]
{
    4000355c:	f9000bf3 	str	x19, [sp, #16]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    40003560:	94000195 	bl	40003bb4 <z_device_ready>
    40003564:	72001c1f 	tst	w0, #0xff
    40003568:	54000160 	b.eq	40003594 <uart_console_init+0x50>  // b.none
	__stdout_hook_install(console_out);
    4000356c:	90000013 	adrp	x19, 40003000 <z_arm64_mm_init+0xec>
    40003570:	91167273 	add	x19, x19, #0x59c
    40003574:	aa1303e0 	mov	x0, x19
    40003578:	97fffef9 	bl	4000315c <__stdout_hook_install>
	__printk_hook_install(console_out);
    4000357c:	aa1303e0 	mov	x0, x19
    40003580:	97fff6fa 	bl	40001168 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    40003584:	52800000 	mov	w0, #0x0                   	// #0
}
    40003588:	f9400bf3 	ldr	x19, [sp, #16]
    4000358c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003590:	d65f03c0 	ret
		return -ENODEV;
    40003594:	12800240 	mov	w0, #0xffffffed            	// #-19
    40003598:	17fffffc 	b	40003588 <uart_console_init+0x44>

000000004000359c <console_out>:
{
    4000359c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if ('\n' == c) {
    400035a0:	7100281f 	cmp	w0, #0xa
{
    400035a4:	910003fd 	mov	x29, sp
    400035a8:	a90153f3 	stp	x19, x20, [sp, #16]
    400035ac:	2a0003f3 	mov	w19, w0
    400035b0:	90000074 	adrp	x20, 4000f000 <z_idle_threads>
	if ('\n' == c) {
    400035b4:	540000c1 	b.ne	400035cc <console_out+0x30>  // b.any
		uart_poll_out(uart_console_dev, '\r');
    400035b8:	f9430a80 	ldr	x0, [x20, #1552]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    400035bc:	f9400801 	ldr	x1, [x0, #16]
    400035c0:	f9400422 	ldr	x2, [x1, #8]
    400035c4:	528001a1 	mov	w1, #0xd                   	// #13
    400035c8:	d63f0040 	blr	x2
	uart_poll_out(uart_console_dev, c);
    400035cc:	f9430a80 	ldr	x0, [x20, #1552]
    400035d0:	f9400801 	ldr	x1, [x0, #16]
    400035d4:	f9400422 	ldr	x2, [x1, #8]
    400035d8:	2a1303e1 	mov	w1, w19
    400035dc:	d63f0040 	blr	x2
}
    400035e0:	2a1303e0 	mov	w0, w19
    400035e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400035e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400035ec:	d65f03c0 	ret

00000000400035f0 <pl011_poll_in>:
	return 0;
}

static bool pl011_is_readable(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa &&
    400035f0:	f9401003 	ldr	x3, [x0, #32]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    400035f4:	f9400402 	ldr	x2, [x0, #8]
	if (!DEV_DATA(dev)->sbsa &&
    400035f8:	39401063 	ldrb	w3, [x3, #4]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    400035fc:	f9400042 	ldr	x2, [x2]
	if (!DEV_DATA(dev)->sbsa &&
    40003600:	350000a3 	cbnz	w3, 40003614 <pl011_poll_in+0x24>
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    40003604:	b9403043 	ldr	w3, [x2, #48]
	if (!DEV_DATA(dev)->sbsa &&
    40003608:	36000183 	tbz	w3, #0, 40003638 <pl011_poll_in+0x48>
	     !(PL011_REGS(dev)->cr & PL011_CR_RXE)))
    4000360c:	b9403043 	ldr	w3, [x2, #48]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    40003610:	36480143 	tbz	w3, #9, 40003638 <pl011_poll_in+0x48>
		return false;

	return (PL011_REGS(dev)->fr & PL011_FR_RXFE) == 0U;
    40003614:	b9401843 	ldr	w3, [x2, #24]
}

static int pl011_poll_in(const struct device *dev, unsigned char *c)
{
	if (!pl011_is_readable(dev)) {
    40003618:	37200103 	tbnz	w3, #4, 40003638 <pl011_poll_in+0x48>
		return -1;
	}

	/* got a character */
	*c = (unsigned char)PL011_REGS(dev)->dr;
    4000361c:	b9400042 	ldr	w2, [x2]
    40003620:	39000022 	strb	w2, [x1]

	return PL011_REGS(dev)->rsr & PL011_RSR_ERROR_MASK;
    40003624:	f9400400 	ldr	x0, [x0, #8]
    40003628:	f9400000 	ldr	x0, [x0]
    4000362c:	b9400400 	ldr	w0, [x0, #4]
    40003630:	12000c00 	and	w0, w0, #0xf
}
    40003634:	d65f03c0 	ret
		return -1;
    40003638:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000363c:	17fffffe 	b	40003634 <pl011_poll_in+0x44>

0000000040003640 <pl011_poll_out>:

static void pl011_poll_out(const struct device *dev,
					     unsigned char c)
{
	/* Wait for space in FIFO */
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    40003640:	f9400400 	ldr	x0, [x0, #8]
{
    40003644:	12001c21 	and	w1, w1, #0xff
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    40003648:	f9400000 	ldr	x0, [x0]
    4000364c:	b9401802 	ldr	w2, [x0, #24]
    40003650:	372fffe2 	tbnz	w2, #5, 4000364c <pl011_poll_out+0xc>
		; /* Wait */
	}

	/* Send a character */
	PL011_REGS(dev)->dr = (uint32_t)c;
    40003654:	b9000001 	str	w1, [x0]
}
    40003658:	d65f03c0 	ret

000000004000365c <pl011_fifo_fill>:
static int pl011_fifo_fill(const struct device *dev,
				    const uint8_t *tx_data, int len)
{
	uint8_t num_tx = 0U;

	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000365c:	f9400400 	ldr	x0, [x0, #8]
    40003660:	f9400003 	ldr	x3, [x0]
	uint8_t num_tx = 0U;
    40003664:	52800000 	mov	w0, #0x0                   	// #0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    40003668:	b9401864 	ldr	w4, [x3, #24]
    4000366c:	37280084 	tbnz	w4, #5, 4000367c <pl011_fifo_fill+0x20>
	       (len - num_tx > 0)) {
    40003670:	4b000044 	sub	w4, w2, w0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    40003674:	7100009f 	cmp	w4, #0x0
    40003678:	5400004c 	b.gt	40003680 <pl011_fifo_fill+0x24>
		PL011_REGS(dev)->dr = tx_data[num_tx++];
	}
	return num_tx;
}
    4000367c:	d65f03c0 	ret
		PL011_REGS(dev)->dr = tx_data[num_tx++];
    40003680:	11000404 	add	w4, w0, #0x1
    40003684:	92401c00 	and	x0, x0, #0xff
    40003688:	38606820 	ldrb	w0, [x1, x0]
    4000368c:	b9000060 	str	w0, [x3]
    40003690:	12001c80 	and	w0, w4, #0xff
    40003694:	17fffff5 	b	40003668 <pl011_fifo_fill+0xc>

0000000040003698 <pl011_fifo_read>:

static int pl011_fifo_read(const struct device *dev,
				    uint8_t *rx_data, const int len)
{
    40003698:	aa0003e4 	mov	x4, x0
	uint8_t num_rx = 0U;
    4000369c:	52800000 	mov	w0, #0x0                   	// #0

	while ((len - num_rx > 0) &&
    400036a0:	4b000043 	sub	w3, w2, w0
    400036a4:	7100007f 	cmp	w3, #0x0
    400036a8:	540000ad 	b.le	400036bc <pl011_fifo_read+0x24>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
    400036ac:	f9400483 	ldr	x3, [x4, #8]
    400036b0:	f9400063 	ldr	x3, [x3]
    400036b4:	b9401865 	ldr	w5, [x3, #24]
	while ((len - num_rx > 0) &&
    400036b8:	36200045 	tbz	w5, #4, 400036c0 <pl011_fifo_read+0x28>
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
	}

	return num_rx;
}
    400036bc:	d65f03c0 	ret
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
    400036c0:	b9400066 	ldr	w6, [x3]
    400036c4:	92401c03 	and	x3, x0, #0xff
    400036c8:	11000405 	add	w5, w0, #0x1
    400036cc:	12001ca0 	and	w0, w5, #0xff
    400036d0:	38236826 	strb	w6, [x1, x3]
    400036d4:	17fffff3 	b	400036a0 <pl011_fifo_read+0x8>

00000000400036d8 <pl011_irq_tx_enable>:

static void pl011_irq_tx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_TXIM;
    400036d8:	f9400400 	ldr	x0, [x0, #8]
    400036dc:	f9400001 	ldr	x1, [x0]
    400036e0:	b9403820 	ldr	w0, [x1, #56]
    400036e4:	321b0000 	orr	w0, w0, #0x20
    400036e8:	b9003820 	str	w0, [x1, #56]
}
    400036ec:	d65f03c0 	ret

00000000400036f0 <pl011_irq_tx_disable>:

static void pl011_irq_tx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_TXIM;
    400036f0:	f9400400 	ldr	x0, [x0, #8]
    400036f4:	f9400001 	ldr	x1, [x0]
    400036f8:	b9403820 	ldr	w0, [x1, #56]
    400036fc:	121a7800 	and	w0, w0, #0xffffffdf
    40003700:	b9003820 	str	w0, [x1, #56]
}
    40003704:	d65f03c0 	ret

0000000040003708 <pl011_irq_tx_complete>:

static int pl011_irq_tx_complete(const struct device *dev)
{
	/* check for TX FIFO empty */
	return PL011_REGS(dev)->fr & PL011_FR_TXFE;
    40003708:	f9400400 	ldr	x0, [x0, #8]
    4000370c:	f9400000 	ldr	x0, [x0]
    40003710:	b9401800 	ldr	w0, [x0, #24]
}
    40003714:	12190000 	and	w0, w0, #0x80
    40003718:	d65f03c0 	ret

000000004000371c <pl011_irq_rx_enable>:
		pl011_irq_tx_complete(dev));
}

static void pl011_irq_rx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_RXIM |
    4000371c:	f9400400 	ldr	x0, [x0, #8]
    40003720:	52800a02 	mov	w2, #0x50                  	// #80
    40003724:	f9400001 	ldr	x1, [x0]
    40003728:	b9403820 	ldr	w0, [x1, #56]
    4000372c:	2a020000 	orr	w0, w0, w2
    40003730:	b9003820 	str	w0, [x1, #56]
				 PL011_IMSC_RTIM;
}
    40003734:	d65f03c0 	ret

0000000040003738 <pl011_irq_rx_disable>:

static void pl011_irq_rx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~(PL011_IMSC_RXIM |
    40003738:	f9400400 	ldr	x0, [x0, #8]
    4000373c:	12800a02 	mov	w2, #0xffffffaf            	// #-81
    40003740:	f9400001 	ldr	x1, [x0]
    40003744:	b9403820 	ldr	w0, [x1, #56]
    40003748:	0a020000 	and	w0, w0, w2
    4000374c:	b9003820 	str	w0, [x1, #56]
				   PL011_IMSC_RTIM);
}
    40003750:	d65f03c0 	ret

0000000040003754 <pl011_irq_rx_ready>:

static int pl011_irq_rx_ready(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_RXE))
    40003754:	f9400401 	ldr	x1, [x0, #8]
    40003758:	f9401000 	ldr	x0, [x0, #32]
    4000375c:	f9400021 	ldr	x1, [x1]
    40003760:	39401000 	ldrb	w0, [x0, #4]
    40003764:	35000060 	cbnz	w0, 40003770 <pl011_irq_rx_ready+0x1c>
    40003768:	b9403020 	ldr	w0, [x1, #48]
    4000376c:	364800e0 	tbz	w0, #9, 40003788 <pl011_irq_rx_ready+0x34>
		return false;

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    40003770:	b9403820 	ldr	w0, [x1, #56]
    40003774:	362000a0 	tbz	w0, #4, 40003788 <pl011_irq_rx_ready+0x34>
		(!(PL011_REGS(dev)->fr & PL011_FR_RXFE)));
    40003778:	b9401820 	ldr	w0, [x1, #24]
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000377c:	d27c0000 	eor	x0, x0, #0x10
    40003780:	d3441000 	ubfx	x0, x0, #4, #1
}
    40003784:	d65f03c0 	ret
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    40003788:	52800000 	mov	w0, #0x0                   	// #0
    4000378c:	17fffffe 	b	40003784 <pl011_irq_rx_ready+0x30>

0000000040003790 <pl011_irq_err_enable>:

static void pl011_irq_err_enable(const struct device *dev)
{
	/* enable framing, parity, break, and overrun */
	PL011_REGS(dev)->imsc |= PL011_IMSC_ERROR_MASK;
    40003790:	f9400400 	ldr	x0, [x0, #8]
    40003794:	f9400001 	ldr	x1, [x0]
    40003798:	b9403820 	ldr	w0, [x1, #56]
    4000379c:	32190c00 	orr	w0, w0, #0x780
    400037a0:	b9003820 	str	w0, [x1, #56]
}
    400037a4:	d65f03c0 	ret

00000000400037a8 <pl011_irq_err_disable>:

static void pl011_irq_err_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_ERROR_MASK;
    400037a8:	f9400400 	ldr	x0, [x0, #8]
    400037ac:	f9400001 	ldr	x1, [x0]
    400037b0:	b9403820 	ldr	w0, [x1, #56]
    400037b4:	12156c00 	and	w0, w0, #0xfffff87f
    400037b8:	b9003820 	str	w0, [x1, #56]
}
    400037bc:	d65f03c0 	ret

00000000400037c0 <pl011_irq_update>:
}

static int pl011_irq_update(const struct device *dev)
{
	return 1;
}
    400037c0:	52800020 	mov	w0, #0x1                   	// #1
    400037c4:	d65f03c0 	ret

00000000400037c8 <pl011_irq_callback_set>:

static void pl011_irq_callback_set(const struct device *dev,
					    uart_irq_callback_user_data_t cb,
					    void *cb_data)
{
	DEV_DATA(dev)->irq_cb = cb;
    400037c8:	f9401000 	ldr	x0, [x0, #32]
	DEV_DATA(dev)->irq_cb_data = cb_data;
    400037cc:	a9008801 	stp	x1, x2, [x0, #8]
}
    400037d0:	d65f03c0 	ret

00000000400037d4 <pl011_isr>:
}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
void pl011_isr(const struct device *dev)
{
	struct pl011_data *data = DEV_DATA(dev);
    400037d4:	f9401001 	ldr	x1, [x0, #32]

	/* Verify if the callback has been registered */
	if (data->irq_cb) {
    400037d8:	f9400422 	ldr	x2, [x1, #8]
    400037dc:	b4000082 	cbz	x2, 400037ec <pl011_isr+0x18>
		data->irq_cb(dev, data->irq_cb_data);
    400037e0:	f9400821 	ldr	x1, [x1, #16]
    400037e4:	aa0203f0 	mov	x16, x2
    400037e8:	d61f0200 	br	x16
	}
}
    400037ec:	d65f03c0 	ret

00000000400037f0 <pl011_irq_config_func_0>:
		    CONFIG_SERIAL_INIT_PRIORITY,
		    &pl011_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void pl011_irq_config_func_0(const struct device *dev)
{
    400037f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#if DT_NUM_IRQS(DT_INST(0, arm_pl011)) == 1
	IRQ_CONNECT(DT_INST_IRQN(0),
    400037f4:	52800002 	mov	w2, #0x0                   	// #0
    400037f8:	52800001 	mov	w1, #0x0                   	// #0
{
    400037fc:	910003fd 	mov	x29, sp
	IRQ_CONNECT(DT_INST_IRQN(0),
    40003800:	52800420 	mov	w0, #0x21                  	// #33
    40003804:	97fffb91 	bl	40002648 <z_arm64_irq_priority_set>
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQ_BY_NAME(0, rxtim, irq));
#endif
}
    40003808:	a8c17bfd 	ldp	x29, x30, [sp], #16
	irq_enable(DT_INST_IRQN(0));
    4000380c:	52800420 	mov	w0, #0x21                  	// #33
    40003810:	17fffb8d 	b	40002644 <arch_irq_enable>

0000000040003814 <pl011_irq_tx_ready>:
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_TXE))
    40003814:	f9401002 	ldr	x2, [x0, #32]
    40003818:	f9400401 	ldr	x1, [x0, #8]
    4000381c:	39401042 	ldrb	w2, [x2, #4]
    40003820:	f9400021 	ldr	x1, [x1]
    40003824:	35000062 	cbnz	w2, 40003830 <pl011_irq_tx_ready+0x1c>
    40003828:	b9403022 	ldr	w2, [x1, #48]
    4000382c:	36400142 	tbz	w2, #8, 40003854 <pl011_irq_tx_ready+0x40>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    40003830:	b9403821 	ldr	w1, [x1, #56]
    40003834:	36280101 	tbz	w1, #5, 40003854 <pl011_irq_tx_ready+0x40>
{
    40003838:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000383c:	910003fd 	mov	x29, sp
		pl011_irq_tx_complete(dev));
    40003840:	97ffffb2 	bl	40003708 <pl011_irq_tx_complete>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    40003844:	7100001f 	cmp	w0, #0x0
    40003848:	1a9f07e0 	cset	w0, ne  // ne = any
}
    4000384c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003850:	d65f03c0 	ret
		return false;
    40003854:	52800000 	mov	w0, #0x0                   	// #0
}
    40003858:	d65f03c0 	ret

000000004000385c <pl011_irq_is_pending>:
{
    4000385c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003860:	aa0003e2 	mov	x2, x0
    40003864:	910003fd 	mov	x29, sp
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    40003868:	97ffffbb 	bl	40003754 <pl011_irq_rx_ready>
    4000386c:	350000e0 	cbnz	w0, 40003888 <pl011_irq_is_pending+0x2c>
    40003870:	aa0203e0 	mov	x0, x2
    40003874:	97ffffe8 	bl	40003814 <pl011_irq_tx_ready>
    40003878:	7100001f 	cmp	w0, #0x0
    4000387c:	1a9f07e0 	cset	w0, ne  // ne = any
}
    40003880:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003884:	d65f03c0 	ret
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    40003888:	52800020 	mov	w0, #0x1                   	// #1
    4000388c:	17fffffd 	b	40003880 <pl011_irq_is_pending+0x24>

0000000040003890 <pl011_init>:
{
    40003890:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003894:	910003fd 	mov	x29, sp
	if (!DEV_DATA(dev)->sbsa) {
    40003898:	f9401002 	ldr	x2, [x0, #32]
{
    4000389c:	f9000bf3 	str	x19, [sp, #16]
    400038a0:	aa0003f3 	mov	x19, x0
	if (!DEV_DATA(dev)->sbsa) {
    400038a4:	39401040 	ldrb	w0, [x2, #4]
    400038a8:	35000460 	cbnz	w0, 40003934 <pl011_init+0xa4>
    400038ac:	f9400663 	ldr	x3, [x19, #8]
				/ (baudrate * 16U);
    400038b0:	b9400042 	ldr	w2, [x2]
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    400038b4:	f9400061 	ldr	x1, [x3]
				/ (baudrate * 16U);
    400038b8:	531c6c42 	lsl	w2, w2, #4
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    400038bc:	b9403020 	ldr	w0, [x1, #48]
    400038c0:	121f7800 	and	w0, w0, #0xfffffffe
    400038c4:	b9003020 	str	w0, [x1, #48]
	PL011_REGS(dev)->lcr_h &= ~PL011_LCRH_FEN;
    400038c8:	b9402c20 	ldr	w0, [x1, #44]
    400038cc:	121b7800 	and	w0, w0, #0xffffffef
    400038d0:	b9002c20 	str	w0, [x1, #44]
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    400038d4:	b9400860 	ldr	w0, [x3, #8]
    400038d8:	d37ae400 	lsl	x0, x0, #6
    400038dc:	9ac20800 	udiv	x0, x0, x2
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    400038e0:	b2793be2 	mov	x2, #0x3fff80              	// #4194176
		|| (bauddiv > (65535u << PL011_FBRD_WIDTH))) {
    400038e4:	d1010003 	sub	x3, x0, #0x40
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    400038e8:	eb02007f 	cmp	x3, x2
    400038ec:	54000688 	b.hi	400039bc <pl011_init+0x12c>  // b.pmore
	PL011_REGS(dev)->ibrd = bauddiv >> PL011_FBRD_WIDTH;
    400038f0:	d346fc02 	lsr	x2, x0, #6
    400038f4:	b9002422 	str	w2, [x1, #36]
	PL011_REGS(dev)->fbrd = bauddiv & ((1u << PL011_FBRD_WIDTH) - 1u);
    400038f8:	12001400 	and	w0, w0, #0x3f
    400038fc:	b9002820 	str	w0, [x1, #40]
	__DMB();
    40003900:	d5033fbf 	dmb	sy
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    40003904:	f9400660 	ldr	x0, [x19, #8]
		lcrh &= ~(BIT(0) | BIT(7));
    40003908:	12801ce2 	mov	w2, #0xffffff18            	// #-232
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000390c:	f9400000 	ldr	x0, [x0]
    40003910:	b9402c01 	ldr	w1, [x0, #44]
    40003914:	b9002c01 	str	w1, [x0, #44]
		lcrh = PL011_REGS(dev)->lcr_h & ~(PL011_LCRH_FORMAT_MASK);
    40003918:	b9402c01 	ldr	w1, [x0, #44]
		lcrh &= ~(BIT(0) | BIT(7));
    4000391c:	0a020021 	and	w1, w1, w2
		lcrh |= PL011_LCRH_WLEN_SIZE(8) << PL011_LCRH_WLEN_SHIFT;
    40003920:	321b0421 	orr	w1, w1, #0x60
		PL011_REGS(dev)->lcr_h = lcrh;
    40003924:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->lcr_h |= PL011_LCRH_FEN;
    40003928:	b9402c01 	ldr	w1, [x0, #44]
    4000392c:	321c0021 	orr	w1, w1, #0x10
    40003930:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->imsc = 0U;
    40003934:	f9400660 	ldr	x0, [x19, #8]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    40003938:	5280ffe1 	mov	w1, #0x7ff                 	// #2047
	PL011_REGS(dev)->imsc = 0U;
    4000393c:	f9400000 	ldr	x0, [x0]
    40003940:	b900381f 	str	wzr, [x0, #56]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    40003944:	b9004401 	str	w1, [x0, #68]
	if (!DEV_DATA(dev)->sbsa) {
    40003948:	f9401261 	ldr	x1, [x19, #32]
    4000394c:	39401021 	ldrb	w1, [x1, #4]
    40003950:	350001a1 	cbnz	w1, 40003984 <pl011_init+0xf4>
		PL011_REGS(dev)->dmacr = 0U;
    40003954:	b900481f 	str	wzr, [x0, #72]
		__ISB();
    40003958:	d5033fdf 	isb
		PL011_REGS(dev)->cr &= ~(BIT(14) | BIT(15) | BIT(1));
    4000395c:	f9400660 	ldr	x0, [x19, #8]
    40003960:	12980042 	mov	w2, #0xffff3ffd            	// #-49155
    40003964:	f9400000 	ldr	x0, [x0]
    40003968:	b9403001 	ldr	w1, [x0, #48]
    4000396c:	0a020021 	and	w1, w1, w2
    40003970:	b9003001 	str	w1, [x0, #48]
		PL011_REGS(dev)->cr |= PL011_CR_RXE | PL011_CR_TXE;
    40003974:	b9403001 	ldr	w1, [x0, #48]
    40003978:	32180421 	orr	w1, w1, #0x300
    4000397c:	b9003001 	str	w1, [x0, #48]
		__ISB();
    40003980:	d5033fdf 	isb
	DEV_CFG(dev)->irq_config_func(dev);
    40003984:	f9400660 	ldr	x0, [x19, #8]
    40003988:	f9400801 	ldr	x1, [x0, #16]
    4000398c:	aa1303e0 	mov	x0, x19
    40003990:	d63f0020 	blr	x1
	if (!DEV_DATA(dev)->sbsa)
    40003994:	f9401260 	ldr	x0, [x19, #32]
    40003998:	39401000 	ldrb	w0, [x0, #4]
    4000399c:	350000c0 	cbnz	w0, 400039b4 <pl011_init+0x124>
	PL011_REGS(dev)->cr |=  PL011_CR_UARTEN;
    400039a0:	f9400660 	ldr	x0, [x19, #8]
    400039a4:	f9400001 	ldr	x1, [x0]
    400039a8:	b9403020 	ldr	w0, [x1, #48]
    400039ac:	32000000 	orr	w0, w0, #0x1
    400039b0:	b9003020 	str	w0, [x1, #48]
	return 0;
    400039b4:	52800000 	mov	w0, #0x0                   	// #0
    400039b8:	14000002 	b	400039c0 <pl011_init+0x130>
		return -EINVAL;
    400039bc:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    400039c0:	f9400bf3 	ldr	x19, [sp, #16]
    400039c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400039c8:	d65f03c0 	ret

00000000400039cc <arm_arch_timer_compare_isr>:
MAKE_REG_HELPER(daif)
    400039cc:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400039d0:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    400039d4:	d53be040 	mrs	x0, cntvct_el0
		return;
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	uint64_t curr_cycle = arm_arch_timer_count();
	uint32_t delta_ticks = (uint32_t)((curr_cycle - last_cycle) / CYC_PER_TICK);
    400039d8:	90000063 	adrp	x3, 4000f000 <z_idle_threads>
    400039dc:	f9430c64 	ldr	x4, [x3, #1560]
    400039e0:	d2912d05 	mov	x5, #0x8968                	// #35176
    400039e4:	f2a00125 	movk	x5, #0x9, lsl #16
    400039e8:	cb040000 	sub	x0, x0, x4
    400039ec:	9ac50800 	udiv	x0, x0, x5

	last_cycle += delta_ticks * CYC_PER_TICK;
    400039f0:	92407c02 	and	x2, x0, #0xffffffff
    400039f4:	9b051042 	madd	x2, x2, x5, x4
    400039f8:	f9030c62 	str	x2, [x3, #1560]
MAKE_REG_HELPER(cntv_ctl_el0)
    400039fc:	d53be322 	mrs	x2, cntv_ctl_el0
	uint64_t cntv_ctl;

	cntv_ctl = read_cntv_ctl_el0();

	if (mask) {
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    40003a00:	b27f0042 	orr	x2, x2, #0x2
    40003a04:	d51be322 	msr	cntv_ctl_el0, x2
MAKE_REG_HELPER(daif)
    40003a08:	92407c21 	and	x1, x1, #0xffffffff
    40003a0c:	d51b4221 	msr	daif, x1
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	k_spin_unlock(&lock, key);

	sys_clock_announce(delta_ticks);
    40003a10:	140003e1 	b	40004994 <sys_clock_announce>

0000000040003a14 <sys_clock_driver_init>:
}

int sys_clock_driver_init(const struct device *dev)
{
    40003a14:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);

	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    40003a18:	52800042 	mov	w2, #0x2                   	// #2
    40003a1c:	52801401 	mov	w1, #0xa0                  	// #160
{
    40003a20:	910003fd 	mov	x29, sp
	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    40003a24:	52800360 	mov	w0, #0x1b                  	// #27
    40003a28:	97fffb08 	bl	40002648 <z_arm64_irq_priority_set>
MAKE_REG_HELPER(cntvct_el0);
    40003a2c:	d53be040 	mrs	x0, cntvct_el0
		    arm_arch_timer_compare_isr, NULL, ARM_ARCH_TIMER_FLAGS);
	arm_arch_timer_init();
	arm_arch_timer_set_compare(arm_arch_timer_count() + CYC_PER_TICK);
    40003a30:	91426000 	add	x0, x0, #0x98, lsl #12
    40003a34:	9125a000 	add	x0, x0, #0x968
MAKE_REG_HELPER(cntv_cval_el0)
    40003a38:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    40003a3c:	d53be320 	mrs	x0, cntv_ctl_el0
		cntv_ctl |= CNTV_CTL_ENABLE_BIT;
    40003a40:	b2400000 	orr	x0, x0, #0x1
    40003a44:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_enable(true);
	irq_enable(ARM_ARCH_TIMER_IRQ);
    40003a48:	52800360 	mov	w0, #0x1b                  	// #27
    40003a4c:	97fffafe 	bl	40002644 <arch_irq_enable>
    40003a50:	d53be320 	mrs	x0, cntv_ctl_el0
	} else {
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    40003a54:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    40003a58:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_set_irq_mask(false);

	return 0;
}
    40003a5c:	52800000 	mov	w0, #0x0                   	// #0
    40003a60:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003a64:	d65f03c0 	ret

0000000040003a68 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
#if defined(CONFIG_TICKLESS_KERNEL)

	if (ticks == K_TICKS_FOREVER && idle) {
    40003a68:	72001c3f 	tst	w1, #0xff
    40003a6c:	3a411800 	ccmn	w0, #0x1, #0x0, ne  // ne = any
    40003a70:	54000420 	b.eq	40003af4 <sys_clock_set_timeout+0x8c>  // b.none
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    40003a74:	3100041f 	cmn	w0, #0x1
    40003a78:	54000400 	b.eq	40003af8 <sys_clock_set_timeout+0x90>  // b.none
    40003a7c:	71000400 	subs	w0, w0, #0x1
    40003a80:	1a9f5000 	csel	w0, w0, wzr, pl  // pl = nfrst
MAKE_REG_HELPER(daif)
    40003a84:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003a88:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    40003a8c:	d53be042 	mrs	x2, cntvct_el0
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t curr_cycle = arm_arch_timer_count();
	uint64_t req_cycle = ticks * CYC_PER_TICK;

	/* Round up to next tick boundary */
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    40003a90:	90000061 	adrp	x1, 4000f000 <z_idle_threads>
    40003a94:	f9430c23 	ldr	x3, [x1, #1560]
    40003a98:	52912d05 	mov	w5, #0x8968                	// #35176
    40003a9c:	72a00125 	movk	w5, #0x9, lsl #16
    40003aa0:	d2912ce1 	mov	x1, #0x8967                	// #35175
    40003aa4:	f2a00121 	movk	x1, #0x9, lsl #16
    40003aa8:	cb030021 	sub	x1, x1, x3
    40003aac:	9b250800 	smaddl	x0, w0, w5, x2

	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;

	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    40003ab0:	cb020062 	sub	x2, x3, x2
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    40003ab4:	8b000020 	add	x0, x1, x0
	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;
    40003ab8:	d2912d01 	mov	x1, #0x8968                	// #35176
    40003abc:	f2a00121 	movk	x1, #0x9, lsl #16
    40003ac0:	9ac10800 	udiv	x0, x0, x1
    40003ac4:	9b017c00 	mul	x0, x0, x1
	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    40003ac8:	8b000042 	add	x2, x2, x0
    40003acc:	f10f9c5f 	cmp	x2, #0x3e7
    40003ad0:	54000048 	b.hi	40003ad8 <sys_clock_set_timeout+0x70>  // b.pmore
		req_cycle += CYC_PER_TICK;
    40003ad4:	8b010000 	add	x0, x0, x1
	}

	arm_arch_timer_set_compare(req_cycle + last_cycle);
    40003ad8:	8b000060 	add	x0, x3, x0
MAKE_REG_HELPER(cntv_cval_el0)
    40003adc:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    40003ae0:	d53be320 	mrs	x0, cntv_ctl_el0
    40003ae4:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    40003ae8:	d51be320 	msr	cntv_ctl_el0, x0
MAKE_REG_HELPER(daif)
    40003aec:	92407c80 	and	x0, x4, #0xffffffff
    40003af0:	d51b4220 	msr	daif, x0

#else  /* CONFIG_TICKLESS_KERNEL */
	ARG_UNUSED(ticks);
	ARG_UNUSED(idle);
#endif
}
    40003af4:	d65f03c0 	ret
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    40003af8:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    40003afc:	17ffffe2 	b	40003a84 <sys_clock_set_timeout+0x1c>

0000000040003b00 <sys_clock_elapsed>:
    40003b00:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003b04:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    40003b08:	d53be040 	mrs	x0, cntvct_el0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    40003b0c:	90000062 	adrp	x2, 4000f000 <z_idle_threads>
    40003b10:	f9430c42 	ldr	x2, [x2, #1560]
MAKE_REG_HELPER(daif)
    40003b14:	92407c21 	and	x1, x1, #0xffffffff
    40003b18:	cb020000 	sub	x0, x0, x2
		    / CYC_PER_TICK);
    40003b1c:	d2912d02 	mov	x2, #0x8968                	// #35176
    40003b20:	f2a00122 	movk	x2, #0x9, lsl #16
    40003b24:	9ac20800 	udiv	x0, x0, x2
    40003b28:	d51b4221 	msr	daif, x1

	k_spin_unlock(&lock, key);
	return ret;
}
    40003b2c:	d65f03c0 	ret

0000000040003b30 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
    40003b30:	d65f03c0 	ret

0000000040003b34 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    40003b34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40003b38:	d0000001 	adrp	x1, 40005000 <__rodata_region_start>
    40003b3c:	913fc021 	add	x1, x1, #0xff0
{
    40003b40:	910003fd 	mov	x29, sp
    40003b44:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40003b48:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
    40003b4c:	11000400 	add	w0, w0, #0x1
{
    40003b50:	a9025bf5 	stp	x21, x22, [sp, #32]
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    40003b54:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40003b58:	f860d835 	ldr	x21, [x1, w0, sxtw #3]
    40003b5c:	eb1302bf 	cmp	x21, x19
    40003b60:	540000a8 	b.hi	40003b74 <z_sys_init_run_level+0x40>  // b.pmore
			}
			dev->state->initialized = true;
		}
	}
}
    40003b64:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003b68:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003b6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003b70:	d65f03c0 	ret
		const struct device *dev = entry->dev;
    40003b74:	a9405261 	ldp	x1, x20, [x19]
		int rc = entry->init(dev);
    40003b78:	aa1403e0 	mov	x0, x20
    40003b7c:	d63f0020 	blr	x1
		if (dev != NULL) {
    40003b80:	b4000174 	cbz	x20, 40003bac <z_sys_init_run_level+0x78>
			if (rc != 0) {
    40003b84:	7100001f 	cmp	w0, #0x0
				dev->state->init_res = rc;
    40003b88:	f9400e81 	ldr	x1, [x20, #24]
			if (rc != 0) {
    40003b8c:	340000a0 	cbz	w0, 40003ba0 <z_sys_init_run_level+0x6c>
				if (rc < 0) {
    40003b90:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
				dev->state->init_res = rc;
    40003b94:	7103fc1f 	cmp	w0, #0xff
    40003b98:	1a96d000 	csel	w0, w0, w22, le
    40003b9c:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
    40003ba0:	79400020 	ldrh	w0, [x1]
    40003ba4:	32180000 	orr	w0, w0, #0x100
    40003ba8:	79000020 	strh	w0, [x1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40003bac:	91004273 	add	x19, x19, #0x10
    40003bb0:	17ffffeb 	b	40003b5c <z_sys_init_run_level+0x28>

0000000040003bb4 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    40003bb4:	b40000e0 	cbz	x0, 40003bd0 <z_device_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    40003bb8:	f9400c00 	ldr	x0, [x0, #24]
    40003bbc:	b9400000 	ldr	w0, [x0]
    40003bc0:	12002000 	and	w0, w0, #0x1ff
    40003bc4:	7104001f 	cmp	w0, #0x100
    40003bc8:	1a9f17e0 	cset	w0, eq  // eq = none
}
    40003bcc:	d65f03c0 	ret
		return false;
    40003bd0:	52800000 	mov	w0, #0x0                   	// #0
    40003bd4:	17fffffe 	b	40003bcc <z_device_ready+0x18>

0000000040003bd8 <arch_system_halt>:
    40003bd8:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003bdc:	d50342df 	msr	daifset, #0x2
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    40003be0:	14000000 	b	40003be0 <arch_system_halt+0x8>

0000000040003be4 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    40003be4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003be8:	910003fd 	mov	x29, sp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    40003bec:	97fffffb 	bl	40003bd8 <arch_system_halt>

0000000040003bf0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    40003bf0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003bf4:	910003fd 	mov	x29, sp
    40003bf8:	a90153f3 	stp	x19, x20, [sp, #16]
    40003bfc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003c00:	2a0003f5 	mov	w21, w0
    40003c04:	aa0103f6 	mov	x22, x1
MAKE_REG_HELPER(daif)
    40003c08:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003c0c:	d50342df 	msr	daifset, #0x2
	return z_impl_z_current_get();
    40003c10:	94000281 	bl	40004614 <z_impl_z_current_get>
MAKE_REG_HELPER(daif)
    40003c14:	92407e94 	and	x20, x20, #0xffffffff
    40003c18:	aa0003f3 	mov	x19, x0
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    40003c1c:	aa1603e1 	mov	x1, x22
    40003c20:	2a1503e0 	mov	w0, w21
    40003c24:	97fffff0 	bl	40003be4 <k_sys_fatal_error_handler>
    40003c28:	d51b4234 	msr	daif, x20
	z_impl_k_thread_abort(thread);
    40003c2c:	aa1303e0 	mov	x0, x19
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    40003c30:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c34:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003c38:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003c3c:	140002b4 	b	4000470c <z_impl_k_thread_abort>

0000000040003c40 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    40003c40:	d100c3ff 	sub	sp, sp, #0x30
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    40003c44:	52800021 	mov	w1, #0x1                   	// #1
	k_thread_stack_t *stack = z_idle_stacks[i];
    40003c48:	93747c08 	sbfiz	x8, x0, #12, #32
	z_setup_new_thread(thread, stack,
    40003c4c:	90000062 	adrp	x2, 4000f000 <z_idle_threads>
    40003c50:	91188042 	add	x2, x2, #0x620
    40003c54:	52800604 	mov	w4, #0x30                  	// #48
{
    40003c58:	a9017bfd 	stp	x29, x30, [sp, #16]
    40003c5c:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
    40003c60:	528001e7 	mov	w7, #0xf                   	// #15
    40003c64:	9b240804 	smaddl	x4, w0, w4, x2
    40003c68:	b90003e1 	str	w1, [sp]
    40003c6c:	b00002a1 	adrp	x1, 40058000 <z_main_stack+0x950>
    40003c70:	911ac021 	add	x1, x1, #0x6b0
{
    40003c74:	a90253f3 	stp	x19, x20, [sp, #32]
	struct k_thread *thread = &z_idle_threads[i];
    40003c78:	90000074 	adrp	x20, 4000f000 <z_idle_threads>
    40003c7c:	91000294 	add	x20, x20, #0x0
	z_setup_new_thread(thread, stack,
    40003c80:	8b080021 	add	x1, x1, x8
    40003c84:	52806008 	mov	w8, #0x300                 	// #768
	k_thread_stack_t *stack = z_idle_stacks[i];
    40003c88:	93407c13 	sxtw	x19, w0
	z_setup_new_thread(thread, stack,
    40003c8c:	f90007ff 	str	xzr, [sp, #8]
    40003c90:	d2800006 	mov	x6, #0x0                   	// #0
    40003c94:	9b285000 	smaddl	x0, w0, w8, x20
    40003c98:	d2800005 	mov	x5, #0x0                   	// #0
    40003c9c:	d2820002 	mov	x2, #0x1000                	// #4096
    40003ca0:	90000003 	adrp	x3, 40003000 <z_arm64_mm_init+0xec>
    40003ca4:	913e0063 	add	x3, x3, #0xf80
    40003ca8:	94000063 	bl	40003e34 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    40003cac:	d2806000 	mov	x0, #0x300                 	// #768
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    40003cb0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40003cb4:	9b005260 	madd	x0, x19, x0, x20
    40003cb8:	a94253f3 	ldp	x19, x20, [sp, #32]
    40003cbc:	9100c3ff 	add	sp, sp, #0x30
    40003cc0:	39406401 	ldrb	w1, [x0, #25]
    40003cc4:	121d7821 	and	w1, w1, #0xfffffffb
    40003cc8:	39006401 	strb	w1, [x0, #25]
    40003ccc:	d65f03c0 	ret

0000000040003cd0 <bg_thread_main>:
{
    40003cd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003cd4:	910003fd 	mov	x29, sp
	z_mem_manage_init();
    40003cd8:	94000373 	bl	40004aa4 <z_mem_manage_init>
	z_sys_post_kernel = true;
    40003cdc:	90000060 	adrp	x0, 4000f000 <z_idle_threads>
    40003ce0:	52800021 	mov	w1, #0x1                   	// #1
    40003ce4:	391ab001 	strb	w1, [x0, #1708]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    40003ce8:	52800040 	mov	w0, #0x2                   	// #2
    40003cec:	97ffff92 	bl	40003b34 <z_sys_init_run_level>
	boot_banner();
    40003cf0:	940003a2 	bl	40004b78 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    40003cf4:	52800060 	mov	w0, #0x3                   	// #3
    40003cf8:	97ffff8f 	bl	40003b34 <z_sys_init_run_level>
	z_init_static_threads();
    40003cfc:	9400006a 	bl	40003ea4 <z_init_static_threads>
	z_mem_manage_boot_finish();
    40003d00:	9400039d 	bl	40004b74 <z_mem_manage_boot_finish>
	main();
    40003d04:	97fff508 	bl	40001124 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    40003d08:	90000060 	adrp	x0, 4000f000 <z_idle_threads>
    40003d0c:	910c0000 	add	x0, x0, #0x300
    40003d10:	39406001 	ldrb	w1, [x0, #24]
    40003d14:	121f7821 	and	w1, w1, #0xfffffffe
    40003d18:	39006001 	strb	w1, [x0, #24]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    40003d1c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003d20:	d65f03c0 	ret

0000000040003d24 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    40003d24:	d10d03ff 	sub	sp, sp, #0x340
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    40003d28:	52802020 	mov	w0, #0x101                 	// #257
    40003d2c:	a9017bfd 	stp	x29, x30, [sp, #16]
    40003d30:	910043fd 	add	x29, sp, #0x10
    40003d34:	a90253f3 	stp	x19, x20, [sp, #32]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    40003d38:	90000073 	adrp	x19, 4000f000 <z_idle_threads>
    40003d3c:	91188273 	add	x19, x19, #0x620
	dummy_thread->base.user_options = K_ESSENTIAL;
    40003d40:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
    40003d44:	910103e0 	add	x0, sp, #0x40
    40003d48:	a9035bf5 	stp	x21, x22, [sp, #48]
	_kernel.ready_q.cache = &z_main_thread;
    40003d4c:	90000074 	adrp	x20, 4000f000 <z_idle_threads>
    40003d50:	910c0294 	add	x20, x20, #0x300
    40003d54:	f9000a60 	str	x0, [x19, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    40003d58:	97ffff76 	bl	40003b30 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    40003d5c:	52800000 	mov	w0, #0x0                   	// #0
    40003d60:	97ffff75 	bl	40003b34 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    40003d64:	52800020 	mov	w0, #0x1                   	// #1
    40003d68:	97ffff73 	bl	40003b34 <z_sys_init_run_level>
	z_sched_init();
    40003d6c:	94000222 	bl	400045f4 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    40003d70:	f9001a74 	str	x20, [x19, #48]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    40003d74:	f0000000 	adrp	x0, 40006000 <levels.0+0x10>
    40003d78:	9103c000 	add	x0, x0, #0xf0
    40003d7c:	f90007e0 	str	x0, [sp, #8]
    40003d80:	52800020 	mov	w0, #0x1                   	// #1
    40003d84:	b90003e0 	str	w0, [sp]
    40003d88:	52800007 	mov	w7, #0x0                   	// #0
    40003d8c:	d2800006 	mov	x6, #0x0                   	// #0
    40003d90:	d2800005 	mov	x5, #0x0                   	// #0
    40003d94:	d2800004 	mov	x4, #0x0                   	// #0
    40003d98:	d2820002 	mov	x2, #0x1000                	// #4096
    40003d9c:	aa1403e0 	mov	x0, x20
    40003da0:	90000003 	adrp	x3, 40003000 <z_arm64_mm_init+0xec>
    40003da4:	91334063 	add	x3, x3, #0xcd0
    40003da8:	900002a1 	adrp	x1, 40057000 <z_page_frames+0x47953>
    40003dac:	911ac021 	add	x1, x1, #0x6b0
    40003db0:	94000021 	bl	40003e34 <z_setup_new_thread>
    40003db4:	39406680 	ldrb	w0, [x20, #25]
    40003db8:	121d7800 	and	w0, w0, #0xfffffffb
    40003dbc:	39006680 	strb	w0, [x20, #25]
	z_ready_thread(&z_main_thread);
    40003dc0:	aa1403e0 	mov	x0, x20
    40003dc4:	940001c2 	bl	400044cc <z_ready_thread>
		init_idle_thread(i);
    40003dc8:	52800000 	mov	w0, #0x0                   	// #0
    40003dcc:	97ffff9d 	bl	40003c40 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    40003dd0:	90000060 	adrp	x0, 4000f000 <z_idle_threads>
    40003dd4:	91000000 	add	x0, x0, #0x0
    40003dd8:	f9000e60 	str	x0, [x19, #24]
		_kernel.cpus[i].irq_stack =
    40003ddc:	f00002a0 	adrp	x0, 4005a000 <z_interrupt_stacks+0x950>
    40003de0:	911ac000 	add	x0, x0, #0x6b0
    40003de4:	f9000660 	str	x0, [x19, #8]
		_kernel.cpus[i].id = i;
    40003de8:	3900927f 	strb	wzr, [x19, #36]
    40003dec:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003df0:	d50342df 	msr	daifset, #0x2
	old_thread = _current;
    40003df4:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    40003df8:	12800140 	mov	w0, #0xfffffff5            	// #-11
    40003dfc:	b900cec0 	str	w0, [x22, #204]
MAKE_REG_HELPER(daif)
    40003e00:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003e04:	d50342df 	msr	daifset, #0x2
	new_thread = z_swap_next_thread();
    40003e08:	94000107 	bl	40004224 <z_swap_next_thread>
	if (new_thread != old_thread) {
    40003e0c:	eb0002df 	cmp	x22, x0
    40003e10:	540000e0 	b.eq	40003e2c <z_cstart+0x108>  // b.none
    40003e14:	aa0003f4 	mov	x20, x0
		z_reset_time_slice();
    40003e18:	9400006f 	bl	40003fd4 <z_reset_time_slice>
{
}

static inline void arch_switch(void *switch_to, void **switched_from)
{
	z_arm64_call_svc(switch_to, switched_from);
    40003e1c:	910342c1 	add	x1, x22, #0xd0
		_current_cpu->current = new_thread;
    40003e20:	f9000a74 	str	x20, [x19, #16]
    40003e24:	f9406a80 	ldr	x0, [x20, #208]
    40003e28:	97fffab9 	bl	4000290c <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    40003e2c:	92407eb5 	and	x21, x21, #0xffffffff
    40003e30:	d51b4235 	msr	daif, x21

0000000040003e34 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    40003e34:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    40003e38:	9102e008 	add	x8, x0, #0xb8
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    40003e3c:	91003c42 	add	x2, x2, #0xf
{
    40003e40:	910003fd 	mov	x29, sp
    40003e44:	a90153f3 	stp	x19, x20, [sp, #16]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    40003e48:	927cec42 	and	x2, x2, #0xfffffffffffffff0
	stack_ptr = (char *)stack + stack_obj_size;
    40003e4c:	8b020034 	add	x20, x1, x2
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
    40003e50:	a90ba008 	stp	x8, x8, [x0, #184]
{
    40003e54:	aa0003f3 	mov	x19, x0
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    40003e58:	b94023e8 	ldr	w8, [sp, #32]
	thread_base->pended_on = NULL;
    40003e5c:	f900081f 	str	xzr, [x0, #16]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    40003e60:	aa1403e2 	mov	x2, x20
	thread_base->user_options = (uint8_t)options;
    40003e64:	39006008 	strb	w8, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
    40003e68:	52800088 	mov	w8, #0x4                   	// #4
    40003e6c:	39006408 	strb	w8, [x0, #25]

	thread_base->prio = priority;
    40003e70:	39006807 	strb	w7, [x0, #26]

	thread_base->sched_locked = 0U;
    40003e74:	39006c1f 	strb	wzr, [x0, #27]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
    40003e78:	a902fc1f 	stp	xzr, xzr, [x0, #40]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    40003e7c:	97fffaa6 	bl	40002914 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
    40003e80:	90000060 	adrp	x0, 4000f000 <z_idle_threads>
    40003e84:	f9431800 	ldr	x0, [x0, #1584]
    40003e88:	f9406c00 	ldr	x0, [x0, #216]
	new_thread->init_data = NULL;
    40003e8c:	f9005a7f 	str	xzr, [x19, #176]
	new_thread->resource_pool = _current->resource_pool;
    40003e90:	f9006e60 	str	x0, [x19, #216]
}
    40003e94:	aa1403e0 	mov	x0, x20
    40003e98:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003e9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003ea0:	d65f03c0 	ret

0000000040003ea4 <z_init_static_threads>:
{
    40003ea4:	d10103ff 	sub	sp, sp, #0x40
    40003ea8:	a9017bfd 	stp	x29, x30, [sp, #16]
    40003eac:	910043fd 	add	x29, sp, #0x10
    40003eb0:	a90253f3 	stp	x19, x20, [sp, #32]
	_FOREACH_STATIC_THREAD(thread_data) {
    40003eb4:	f00002b3 	adrp	x19, 4005a000 <z_interrupt_stacks+0x950>
    40003eb8:	911c2273 	add	x19, x19, #0x708
    40003ebc:	aa1303f4 	mov	x20, x19
{
    40003ec0:	a9035bf5 	stp	x21, x22, [sp, #48]
	_FOREACH_STATIC_THREAD(thread_data) {
    40003ec4:	f00002b5 	adrp	x21, 4005a000 <z_interrupt_stacks+0x950>
    40003ec8:	911c22b5 	add	x21, x21, #0x708
    40003ecc:	eb15027f 	cmp	x19, x21
    40003ed0:	540001a3 	b.cc	40003f04 <z_init_static_threads+0x60>  // b.lo, b.ul, b.last
	_FOREACH_STATIC_THREAD(thread_data) {
    40003ed4:	aa1403f3 	mov	x19, x20

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    40003ed8:	b0000014 	adrp	x20, 40004000 <z_reset_time_slice+0x2c>
    40003edc:	91153294 	add	x20, x20, #0x54c
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
    40003ee0:	d2800156 	mov	x22, #0xa                   	// #10
	k_sched_lock();
    40003ee4:	940000c6 	bl	400041fc <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    40003ee8:	eb15027f 	cmp	x19, x21
    40003eec:	54000283 	b.cc	40003f3c <z_init_static_threads+0x98>  // b.lo, b.ul, b.last
}
    40003ef0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40003ef4:	a94253f3 	ldp	x19, x20, [sp, #32]
    40003ef8:	a9435bf5 	ldp	x21, x22, [sp, #48]
    40003efc:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
    40003f00:	140001ac 	b	400045b0 <k_sched_unlock>
		z_setup_new_thread(
    40003f04:	f9402a60 	ldr	x0, [x19, #80]
    40003f08:	f90007e0 	str	x0, [sp, #8]
    40003f0c:	b9403e60 	ldr	w0, [x19, #60]
    40003f10:	b90003e0 	str	w0, [sp]
    40003f14:	a9400660 	ldp	x0, x1, [x19]
    40003f18:	a9419263 	ldp	x3, x4, [x19, #24]
    40003f1c:	a9429a65 	ldp	x5, x6, [x19, #40]
    40003f20:	b9401262 	ldr	w2, [x19, #16]
    40003f24:	b9403a67 	ldr	w7, [x19, #56]
    40003f28:	97ffffc3 	bl	40003e34 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    40003f2c:	f9400260 	ldr	x0, [x19]
    40003f30:	f9005813 	str	x19, [x0, #176]
	_FOREACH_STATIC_THREAD(thread_data) {
    40003f34:	91016273 	add	x19, x19, #0x58
    40003f38:	17ffffe5 	b	40003ecc <z_init_static_threads+0x28>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    40003f3c:	b9404262 	ldr	w2, [x19, #64]
    40003f40:	3100045f 	cmn	w2, #0x1
    40003f44:	54000100 	b.eq	40003f64 <z_init_static_threads+0xc0>  // b.none
					    K_MSEC(thread_data->init_delay));
    40003f48:	7100005f 	cmp	w2, #0x0
    40003f4c:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
    40003f50:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
    40003f54:	93407c43 	sxtw	x3, w2
		t += off;
    40003f58:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    40003f5c:	b5000083 	cbnz	x3, 40003f6c <z_init_static_threads+0xc8>
	z_sched_start(thread);
    40003f60:	94000166 	bl	400044f8 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    40003f64:	91016273 	add	x19, x19, #0x58
    40003f68:	17ffffe0 	b	40003ee8 <z_init_static_threads+0x44>
    40003f6c:	9ad60842 	udiv	x2, x2, x22
    40003f70:	aa1403e1 	mov	x1, x20
    40003f74:	9100a000 	add	x0, x0, #0x28
    40003f78:	94000219 	bl	400047dc <z_add_timeout>
    40003f7c:	17fffffa 	b	40003f64 <z_init_static_threads+0xc0>

0000000040003f80 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    40003f80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003f84:	910003fd 	mov	x29, sp
    40003f88:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003f8c:	d50342df 	msr	daifset, #0x2
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    40003f90:	97fff990 	bl	400025d0 <arch_cpu_idle>
    40003f94:	17fffffd 	b	40003f88 <idle+0x8>

0000000040003f98 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    40003f98:	a9400801 	ldp	x1, x2, [x0]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    40003f9c:	f9000041 	str	x1, [x2]
	next->prev = prev;
    40003fa0:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    40003fa4:	a9007c1f 	stp	xzr, xzr, [x0]
	sys_dnode_init(node);
}
    40003fa8:	d65f03c0 	ret

0000000040003fac <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    40003fac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003fb0:	aa0003e3 	mov	x3, x0
    40003fb4:	910003fd 	mov	x29, sp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    40003fb8:	97fffff8 	bl	40003f98 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
    40003fbc:	39406400 	ldrb	w0, [x0, #25]
    40003fc0:	121e7800 	and	w0, w0, #0xfffffffd
    40003fc4:	39006460 	strb	w0, [x3, #25]
}
    40003fc8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	thread->base.pended_on = NULL;
    40003fcc:	f900087f 	str	xzr, [x3, #16]
}
    40003fd0:	d65f03c0 	ret

0000000040003fd4 <z_reset_time_slice>:
{
    40003fd4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003fd8:	910003fd 	mov	x29, sp
    40003fdc:	f9000bf3 	str	x19, [sp, #16]
	if (slice_time != 0) {
    40003fe0:	90000073 	adrp	x19, 4000f000 <z_idle_threads>
    40003fe4:	b9469660 	ldr	w0, [x19, #1684]
    40003fe8:	34000160 	cbz	w0, 40004014 <z_reset_time_slice+0x40>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    40003fec:	97fffec5 	bl	40003b00 <sys_clock_elapsed>
    40003ff0:	2a0003e1 	mov	w1, w0
    40003ff4:	b9469660 	ldr	w0, [x19, #1684]
    40003ff8:	90000062 	adrp	x2, 4000f000 <z_idle_threads>
}
    40003ffc:	f9400bf3 	ldr	x19, [sp, #16]
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    40004000:	0b010001 	add	w1, w0, w1
}
    40004004:	a8c27bfd 	ldp	x29, x30, [sp], #32
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    40004008:	b9064041 	str	w1, [x2, #1600]
		z_set_timeout_expiry(slice_time, false);
    4000400c:	52800001 	mov	w1, #0x0                   	// #0
    40004010:	1400024a 	b	40004938 <z_set_timeout_expiry>
}
    40004014:	f9400bf3 	ldr	x19, [sp, #16]
    40004018:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000401c:	d65f03c0 	ret

0000000040004020 <z_swap_irqlock>:
{
    40004020:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004024:	910003fd 	mov	x29, sp
    40004028:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    4000402c:	f0000053 	adrp	x19, 4000f000 <z_idle_threads>
    40004030:	91188273 	add	x19, x19, #0x620
{
    40004034:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004038:	2a0003f4 	mov	w20, w0
	old_thread->swap_retval = -EAGAIN;
    4000403c:	12800140 	mov	w0, #0xfffffff5            	// #-11
	old_thread = _current;
    40004040:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    40004044:	b900cec0 	str	w0, [x22, #204]
MAKE_REG_HELPER(daif)
    40004048:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000404c:	d50342df 	msr	daifset, #0x2
	return _kernel.ready_q.cache;
    40004050:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    40004054:	eb1502df 	cmp	x22, x21
    40004058:	540000c0 	b.eq	40004070 <z_swap_irqlock+0x50>  // b.none
		z_reset_time_slice();
    4000405c:	97ffffde 	bl	40003fd4 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    40004060:	f9000a75 	str	x21, [x19, #16]
    40004064:	f9406aa0 	ldr	x0, [x21, #208]
    40004068:	910342c1 	add	x1, x22, #0xd0
    4000406c:	97fffa28 	bl	4000290c <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    40004070:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    40004074:	f9400a60 	ldr	x0, [x19, #16]
}
    40004078:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000407c:	b940cc00 	ldr	w0, [x0, #204]
    40004080:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004084:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004088:	d65f03c0 	ret

000000004000408c <z_swap>:
{
    4000408c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004090:	910003fd 	mov	x29, sp
    40004094:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    40004098:	f0000053 	adrp	x19, 4000f000 <z_idle_threads>
    4000409c:	91188273 	add	x19, x19, #0x620
{
    400040a0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400040a4:	2a0103f4 	mov	w20, w1
	old_thread->swap_retval = -EAGAIN;
    400040a8:	12800141 	mov	w1, #0xfffffff5            	// #-11
	old_thread = _current;
    400040ac:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    400040b0:	b900cec1 	str	w1, [x22, #204]
	if (!is_spinlock || lock != &sched_spinlock) {
    400040b4:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    400040b8:	911ab421 	add	x1, x1, #0x6ad
    400040bc:	eb00003f 	cmp	x1, x0
    400040c0:	54000060 	b.eq	400040cc <z_swap+0x40>  // b.none
    400040c4:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400040c8:	d50342df 	msr	daifset, #0x2
    400040cc:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    400040d0:	eb1502df 	cmp	x22, x21
    400040d4:	540000c0 	b.eq	400040ec <z_swap+0x60>  // b.none
		z_reset_time_slice();
    400040d8:	97ffffbf 	bl	40003fd4 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    400040dc:	f9000a75 	str	x21, [x19, #16]
    400040e0:	f9406aa0 	ldr	x0, [x21, #208]
    400040e4:	910342c1 	add	x1, x22, #0xd0
    400040e8:	97fffa09 	bl	4000290c <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    400040ec:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    400040f0:	f9400a60 	ldr	x0, [x19, #16]
}
    400040f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400040f8:	b940cc00 	ldr	w0, [x0, #204]
    400040fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004100:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004104:	d65f03c0 	ret

0000000040004108 <k_sched_time_slice_set>:
{
    40004108:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000410c:	910003fd 	mov	x29, sp
    40004110:	f9000bf3 	str	x19, [sp, #16]
    40004114:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004118:	d50342df 	msr	daifset, #0x2
		_current_cpu->slice_ticks = 0;
    4000411c:	f0000042 	adrp	x2, 4000f000 <z_idle_threads>
		if (result32 && (t < BIT64(32))) {
    40004120:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
    40004124:	b906405f 	str	wzr, [x2, #1600]
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    40004128:	2a0003e2 	mov	w2, w0
		t += off;
    4000412c:	91002442 	add	x2, x2, #0x9
		if (result32 && (t < BIT64(32))) {
    40004130:	eb03005f 	cmp	x2, x3
    40004134:	54000208 	b.hi	40004174 <k_sched_time_slice_set+0x6c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    40004138:	11002402 	add	w2, w0, #0x9
    4000413c:	52800143 	mov	w3, #0xa                   	// #10
    40004140:	1ac30842 	udiv	w2, w2, w3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    40004144:	7100001f 	cmp	w0, #0x0
    40004148:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    4000414c:	540001ac 	b.gt	40004180 <k_sched_time_slice_set+0x78>
			slice_time = MAX(2, slice_time);
    40004150:	b9069402 	str	w2, [x0, #1684]
		slice_max_prio = prio;
    40004154:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
MAKE_REG_HELPER(daif)
    40004158:	92407e73 	and	x19, x19, #0xffffffff
    4000415c:	b9069001 	str	w1, [x0, #1680]
		z_reset_time_slice();
    40004160:	97ffff9d 	bl	40003fd4 <z_reset_time_slice>
    40004164:	d51b4233 	msr	daif, x19
}
    40004168:	f9400bf3 	ldr	x19, [sp, #16]
    4000416c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004170:	d65f03c0 	ret
			return t / ((uint64_t)from_hz / to_hz);
    40004174:	d2800143 	mov	x3, #0xa                   	// #10
    40004178:	9ac30842 	udiv	x2, x2, x3
    4000417c:	17fffff2 	b	40004144 <k_sched_time_slice_set+0x3c>
			slice_time = MAX(2, slice_time);
    40004180:	7100085f 	cmp	w2, #0x2
    40004184:	52800043 	mov	w3, #0x2                   	// #2
    40004188:	1a83a042 	csel	w2, w2, w3, ge  // ge = tcont
    4000418c:	17fffff1 	b	40004150 <k_sched_time_slice_set+0x48>

0000000040004190 <z_reschedule>:
{
    40004190:	2a0103e2 	mov	w2, w1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    40004194:	36380062 	tbz	w2, #7, 400041a0 <z_reschedule+0x10>
    40004198:	d51b4222 	msr	daif, x2
}
    4000419c:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    400041a0:	d53bd063 	mrs	x3, tpidrro_el0
    400041a4:	927db063 	and	x3, x3, #0xfffffffffff8
	if (resched(key.key) && need_swap()) {
    400041a8:	b9400063 	ldr	w3, [x3]
    400041ac:	35ffff63 	cbnz	w3, 40004198 <z_reschedule+0x8>
	new_thread = _kernel.ready_q.cache;
    400041b0:	f0000043 	adrp	x3, 4000f000 <z_idle_threads>
    400041b4:	91188063 	add	x3, x3, #0x620
	if (resched(key.key) && need_swap()) {
    400041b8:	f9401864 	ldr	x4, [x3, #48]
    400041bc:	f9400863 	ldr	x3, [x3, #16]
    400041c0:	eb03009f 	cmp	x4, x3
    400041c4:	54fffea0 	b.eq	40004198 <z_reschedule+0x8>  // b.none
		z_swap(lock, key);
    400041c8:	17ffffb1 	b	4000408c <z_swap>

00000000400041cc <z_reschedule_irqlock>:
{
    400041cc:	2a0003e1 	mov	w1, w0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    400041d0:	36380061 	tbz	w1, #7, 400041dc <z_reschedule_irqlock+0x10>
MAKE_REG_HELPER(daif)
    400041d4:	d51b4221 	msr	daif, x1
}
    400041d8:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    400041dc:	d53bd062 	mrs	x2, tpidrro_el0
    400041e0:	927db042 	and	x2, x2, #0xfffffffffff8
	if (resched(key)) {
    400041e4:	b9400042 	ldr	w2, [x2]
    400041e8:	35ffff62 	cbnz	w2, 400041d4 <z_reschedule_irqlock+0x8>
		z_swap_irqlock(key);
    400041ec:	17ffff8d 	b	40004020 <z_swap_irqlock>

00000000400041f0 <z_reschedule_unlocked>:
MAKE_REG_HELPER(daif)
    400041f0:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400041f4:	d50342df 	msr	daifset, #0x2
	(void) z_reschedule_irqlock(arch_irq_lock());
    400041f8:	17fffff5 	b	400041cc <z_reschedule_irqlock>

00000000400041fc <k_sched_lock>:
MAKE_REG_HELPER(daif)
    400041fc:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004200:	d50342df 	msr	daifset, #0x2
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    40004204:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004208:	f9431822 	ldr	x2, [x1, #1584]
    4000420c:	39406c41 	ldrb	w1, [x2, #27]
    40004210:	51000421 	sub	w1, w1, #0x1
    40004214:	39006c41 	strb	w1, [x2, #27]
MAKE_REG_HELPER(daif)
    40004218:	92407c00 	and	x0, x0, #0xffffffff
    4000421c:	d51b4220 	msr	daif, x0
}
    40004220:	d65f03c0 	ret

0000000040004224 <z_swap_next_thread>:
}
    40004224:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    40004228:	f9432800 	ldr	x0, [x0, #1616]
    4000422c:	d65f03c0 	ret

0000000040004230 <z_get_next_switch_handle>:
	z_sched_usage_switch(_kernel.ready_q.cache);
    40004230:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004234:	91188021 	add	x1, x1, #0x620
	_current->switch_handle = interrupted;
    40004238:	f9400823 	ldr	x3, [x1, #16]
	z_sched_usage_switch(_kernel.ready_q.cache);
    4000423c:	f9401822 	ldr	x2, [x1, #48]
	_current_cpu->current = new_thread;
    40004240:	f9000822 	str	x2, [x1, #16]
	_current->switch_handle = interrupted;
    40004244:	f9006860 	str	x0, [x3, #208]
}
    40004248:	f9406840 	ldr	x0, [x2, #208]
    4000424c:	d65f03c0 	ret

0000000040004250 <z_priq_dumb_best>:
	return list->head == list;
    40004250:	f9400001 	ldr	x1, [x0]
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
    40004254:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    40004258:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
    4000425c:	d65f03c0 	ret

0000000040004260 <update_cache>:
{
    40004260:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004264:	2a0003e2 	mov	w2, w0
	return _priq_run_best(curr_cpu_runq());
    40004268:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    4000426c:	91196000 	add	x0, x0, #0x658
{
    40004270:	910003fd 	mov	x29, sp
    40004274:	a90153f3 	stp	x19, x20, [sp, #16]
    40004278:	f0000053 	adrp	x19, 4000f000 <z_idle_threads>
    4000427c:	91188273 	add	x19, x19, #0x620
	return _priq_run_best(curr_cpu_runq());
    40004280:	97fffff4 	bl	40004250 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    40004284:	b50001c0 	cbnz	x0, 400042bc <update_cache+0x5c>
    40004288:	f9400e74 	ldr	x20, [x19, #24]
	if (z_is_thread_prevented_from_running(_current)) {
    4000428c:	f9400a61 	ldr	x1, [x19, #16]
	if (preempt_ok != 0) {
    40004290:	350001a2 	cbnz	w2, 400042c4 <update_cache+0x64>
	if (z_is_thread_prevented_from_running(_current)) {
    40004294:	39406420 	ldrb	w0, [x1, #25]
    40004298:	f240101f 	tst	x0, #0x1f
    4000429c:	54000141 	b.ne	400042c4 <update_cache+0x64>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
    400042a0:	79403420 	ldrh	w0, [x1, #26]
    400042a4:	7101fc1f 	cmp	w0, #0x7f
    400042a8:	540000e9 	b.ls	400042c4 <update_cache+0x64>  // b.plast
		_kernel.ready_q.cache = _current;
    400042ac:	f9001a61 	str	x1, [x19, #48]
}
    400042b0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400042b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400042b8:	d65f03c0 	ret
    400042bc:	aa0003f4 	mov	x20, x0
    400042c0:	17fffff3 	b	4000428c <update_cache+0x2c>
		if (thread != _current) {
    400042c4:	eb01029f 	cmp	x20, x1
    400042c8:	54000040 	b.eq	400042d0 <update_cache+0x70>  // b.none
			z_reset_time_slice();
    400042cc:	97ffff42 	bl	40003fd4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    400042d0:	f9001a74 	str	x20, [x19, #48]
}
    400042d4:	17fffff7 	b	400042b0 <update_cache+0x50>

00000000400042d8 <move_thread_to_end_of_prio_q>:
{
    400042d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400042dc:	aa0003e3 	mov	x3, x0
    400042e0:	910003fd 	mov	x29, sp
	if (z_is_thread_queued(thread)) {
    400042e4:	39c06402 	ldrsb	w2, [x0, #25]
	return (thread->base.thread_state & state) != 0U;
    400042e8:	39406401 	ldrb	w1, [x0, #25]
    400042ec:	36f80082 	tbz	w2, #31, 400042fc <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    400042f0:	12001821 	and	w1, w1, #0x7f
    400042f4:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    400042f8:	97ffff28 	bl	40003f98 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    400042fc:	39406460 	ldrb	w0, [x3, #25]
    40004300:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004304:	91188021 	add	x1, x1, #0x620
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40004308:	f0000042 	adrp	x2, 4000f000 <z_idle_threads>
    4000430c:	91196042 	add	x2, x2, #0x658
    40004310:	32196000 	orr	w0, w0, #0xffffff80
    40004314:	39006460 	strb	w0, [x3, #25]
	return (node == list->tail) ? NULL : node->next;
    40004318:	a9439420 	ldp	x0, x5, [x1, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000431c:	eb02001f 	cmp	x0, x2
    40004320:	540002c0 	b.eq	40004378 <move_thread_to_end_of_prio_q+0xa0>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    40004324:	b40002a0 	cbz	x0, 40004378 <move_thread_to_end_of_prio_q+0xa0>
	int32_t b1 = thread_1->base.prio;
    40004328:	39c06866 	ldrsb	w6, [x3, #26]
	int32_t b2 = thread_2->base.prio;
    4000432c:	39c06804 	ldrsb	w4, [x0, #26]
	if (b1 != b2) {
    40004330:	6b0400df 	cmp	w6, w4
    40004334:	540001a0 	b.eq	40004368 <move_thread_to_end_of_prio_q+0x90>  // b.none
		return b2 - b1;
    40004338:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000433c:	7100009f 	cmp	w4, #0x0
    40004340:	5400014d 	b.le	40004368 <move_thread_to_end_of_prio_q+0x90>
	sys_dnode_t *const prev = successor->prev;
    40004344:	f9400402 	ldr	x2, [x0, #8]
	node->prev = prev;
    40004348:	a9000860 	stp	x0, x2, [x3]
	prev->next = node;
    4000434c:	f9000043 	str	x3, [x2]
	successor->prev = node;
    40004350:	f9000403 	str	x3, [x0, #8]
}
    40004354:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    40004358:	f9400820 	ldr	x0, [x1, #16]
    4000435c:	eb03001f 	cmp	x0, x3
    40004360:	1a9f17e0 	cset	w0, eq  // eq = none
    40004364:	17ffffbf 	b	40004260 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    40004368:	eb05001f 	cmp	x0, x5
    4000436c:	54000060 	b.eq	40004378 <move_thread_to_end_of_prio_q+0xa0>  // b.none
    40004370:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    40004374:	b5fffdc0 	cbnz	x0, 4000432c <move_thread_to_end_of_prio_q+0x54>
	node->prev = tail;
    40004378:	a9001462 	stp	x2, x5, [x3]
	tail->next = node;
    4000437c:	f90000a3 	str	x3, [x5]
	list->tail = node;
    40004380:	f9002023 	str	x3, [x1, #64]
}
    40004384:	17fffff4 	b	40004354 <move_thread_to_end_of_prio_q+0x7c>

0000000040004388 <z_time_slice>:
{
    40004388:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000438c:	2a0003e3 	mov	w3, w0
    40004390:	910003fd 	mov	x29, sp
    40004394:	f9000bf3 	str	x19, [sp, #16]
    40004398:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000439c:	d50342df 	msr	daifset, #0x2
	if (slice_time && sliceable(_current)) {
    400043a0:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    400043a4:	b9469400 	ldr	w0, [x0, #1684]
    400043a8:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    400043ac:	91188021 	add	x1, x1, #0x620
    400043b0:	340003c0 	cbz	w0, 40004428 <z_time_slice+0xa0>
    400043b4:	f9400820 	ldr	x0, [x1, #16]
		&& !z_is_idle_thread_object(thread);
    400043b8:	79403402 	ldrh	w2, [x0, #26]
    400043bc:	7101fc5f 	cmp	w2, #0x7f
    400043c0:	54000348 	b.hi	40004428 <z_time_slice+0xa0>  // b.pmore
		&& !z_is_thread_prevented_from_running(thread)
    400043c4:	39406402 	ldrb	w2, [x0, #25]
    400043c8:	f240105f 	tst	x2, #0x1f
    400043cc:	540002e1 	b.ne	40004428 <z_time_slice+0xa0>  // b.any
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    400043d0:	39c06804 	ldrsb	w4, [x0, #26]
    400043d4:	f0000042 	adrp	x2, 4000f000 <z_idle_threads>
    400043d8:	b9469042 	ldr	w2, [x2, #1680]
    400043dc:	6b02009f 	cmp	w4, w2
    400043e0:	5400024b 	b.lt	40004428 <z_time_slice+0xa0>  // b.tstop
		&& !z_is_idle_thread_object(thread);
    400043e4:	f0000042 	adrp	x2, 4000f000 <z_idle_threads>
    400043e8:	91000042 	add	x2, x2, #0x0
    400043ec:	eb02001f 	cmp	x0, x2
    400043f0:	540001c0 	b.eq	40004428 <z_time_slice+0xa0>  // b.none
		if (ticks >= _current_cpu->slice_ticks) {
    400043f4:	b9402022 	ldr	w2, [x1, #32]
    400043f8:	6b03005f 	cmp	w2, w3
    400043fc:	5400010c 	b.gt	4000441c <z_time_slice+0x94>
			move_thread_to_end_of_prio_q(_current);
    40004400:	97ffffb6 	bl	400042d8 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    40004404:	97fffef4 	bl	40003fd4 <z_reset_time_slice>
MAKE_REG_HELPER(daif)
    40004408:	92407e73 	and	x19, x19, #0xffffffff
    4000440c:	d51b4233 	msr	daif, x19
}
    40004410:	f9400bf3 	ldr	x19, [sp, #16]
    40004414:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004418:	d65f03c0 	ret
			_current_cpu->slice_ticks -= ticks;
    4000441c:	4b030042 	sub	w2, w2, w3
    40004420:	b9002022 	str	w2, [x1, #32]
    40004424:	17fffff9 	b	40004408 <z_time_slice+0x80>
		_current_cpu->slice_ticks = 0;
    40004428:	b900203f 	str	wzr, [x1, #32]
    4000442c:	17fffff7 	b	40004408 <z_time_slice+0x80>

0000000040004430 <ready_thread>:
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    40004430:	39c06402 	ldrsb	w2, [x0, #25]
    40004434:	39406401 	ldrb	w1, [x0, #25]
    40004438:	37f80482 	tbnz	w2, #31, 400044c8 <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000443c:	f240103f 	tst	x1, #0x1f
    40004440:	54000441 	b.ne	400044c8 <ready_thread+0x98>  // b.any
    40004444:	f9401402 	ldr	x2, [x0, #40]
    40004448:	b5000402 	cbnz	x2, 400044c8 <ready_thread+0x98>
	return list->head == list;
    4000444c:	f0000042 	adrp	x2, 4000f000 <z_idle_threads>
    40004450:	91188042 	add	x2, x2, #0x620
	thread->base.thread_state |= _THREAD_QUEUED;
    40004454:	32196021 	orr	w1, w1, #0xffffff80
    40004458:	39006401 	strb	w1, [x0, #25]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000445c:	f0000043 	adrp	x3, 4000f000 <z_idle_threads>
    40004460:	91196063 	add	x3, x3, #0x658
	return (node == list->tail) ? NULL : node->next;
    40004464:	a9439441 	ldp	x1, x5, [x2, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40004468:	eb03003f 	cmp	x1, x3
    4000446c:	54000260 	b.eq	400044b8 <ready_thread+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    40004470:	b4000241 	cbz	x1, 400044b8 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    40004474:	39c06806 	ldrsb	w6, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    40004478:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000447c:	6b0400df 	cmp	w6, w4
    40004480:	54000140 	b.eq	400044a8 <ready_thread+0x78>  // b.none
		return b2 - b1;
    40004484:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    40004488:	7100009f 	cmp	w4, #0x0
    4000448c:	540000ed 	b.le	400044a8 <ready_thread+0x78>
	sys_dnode_t *const prev = successor->prev;
    40004490:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    40004494:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    40004498:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000449c:	f9000420 	str	x0, [x1, #8]
		update_cache(0);
    400044a0:	52800000 	mov	w0, #0x0                   	// #0
    400044a4:	17ffff6f 	b	40004260 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    400044a8:	eb05003f 	cmp	x1, x5
    400044ac:	54000060 	b.eq	400044b8 <ready_thread+0x88>  // b.none
    400044b0:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    400044b4:	b5fffe21 	cbnz	x1, 40004478 <ready_thread+0x48>
	node->prev = tail;
    400044b8:	a9001403 	stp	x3, x5, [x0]
	tail->next = node;
    400044bc:	f90000a0 	str	x0, [x5]
	list->tail = node;
    400044c0:	f9002040 	str	x0, [x2, #64]
}
    400044c4:	17fffff7 	b	400044a0 <ready_thread+0x70>
}
    400044c8:	d65f03c0 	ret

00000000400044cc <z_ready_thread>:
{
    400044cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400044d0:	910003fd 	mov	x29, sp
    400044d4:	f9000bf3 	str	x19, [sp, #16]
    400044d8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400044dc:	d50342df 	msr	daifset, #0x2
			ready_thread(thread);
    400044e0:	97ffffd4 	bl	40004430 <ready_thread>
MAKE_REG_HELPER(daif)
    400044e4:	92407e73 	and	x19, x19, #0xffffffff
    400044e8:	d51b4233 	msr	daif, x19
}
    400044ec:	f9400bf3 	ldr	x19, [sp, #16]
    400044f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400044f4:	d65f03c0 	ret

00000000400044f8 <z_sched_start>:
{
    400044f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400044fc:	910003fd 	mov	x29, sp
    40004500:	f9000bf3 	str	x19, [sp, #16]
    40004504:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004508:	d50342df 	msr	daifset, #0x2
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    4000450c:	39406402 	ldrb	w2, [x0, #25]
	if (z_has_thread_started(thread)) {
    40004510:	371000c2 	tbnz	w2, #2, 40004528 <z_sched_start+0x30>
MAKE_REG_HELPER(daif)
    40004514:	92407e73 	and	x19, x19, #0xffffffff
    40004518:	d51b4233 	msr	daif, x19
}
    4000451c:	f9400bf3 	ldr	x19, [sp, #16]
    40004520:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004524:	d65f03c0 	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
    40004528:	121d7842 	and	w2, w2, #0xfffffffb
    4000452c:	39006402 	strb	w2, [x0, #25]
	ready_thread(thread);
    40004530:	97ffffc0 	bl	40004430 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    40004534:	2a1303e1 	mov	w1, w19
    40004538:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    4000453c:	911ab400 	add	x0, x0, #0x6ad
}
    40004540:	f9400bf3 	ldr	x19, [sp, #16]
    40004544:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&sched_spinlock, key);
    40004548:	17ffff12 	b	40004190 <z_reschedule>

000000004000454c <z_thread_timeout>:
{
    4000454c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004550:	910003fd 	mov	x29, sp
    40004554:	f9000bf3 	str	x19, [sp, #16]
    40004558:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000455c:	d50342df 	msr	daifset, #0x2
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    40004560:	d100a004 	sub	x4, x0, #0x28
		if (!killed) {
    40004564:	52800501 	mov	w1, #0x28                  	// #40
    40004568:	39406480 	ldrb	w0, [x4, #25]
    4000456c:	6a00003f 	tst	w1, w0
    40004570:	54000161 	b.ne	4000459c <z_thread_timeout+0x50>  // b.any
			if (thread->base.pended_on != NULL) {
    40004574:	f9400880 	ldr	x0, [x4, #16]
    40004578:	b4000060 	cbz	x0, 40004584 <z_thread_timeout+0x38>
				unpend_thread_no_timeout(thread);
    4000457c:	aa0403e0 	mov	x0, x4
    40004580:	97fffe8b 	bl	40003fac <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    40004584:	39406480 	ldrb	w0, [x4, #25]
    40004588:	12800281 	mov	w1, #0xffffffeb            	// #-21
    4000458c:	0a010000 	and	w0, w0, w1
    40004590:	39006480 	strb	w0, [x4, #25]
			ready_thread(thread);
    40004594:	aa0403e0 	mov	x0, x4
    40004598:	97ffffa6 	bl	40004430 <ready_thread>
MAKE_REG_HELPER(daif)
    4000459c:	92407e73 	and	x19, x19, #0xffffffff
    400045a0:	d51b4233 	msr	daif, x19
}
    400045a4:	f9400bf3 	ldr	x19, [sp, #16]
    400045a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400045ac:	d65f03c0 	ret

00000000400045b0 <k_sched_unlock>:
{
    400045b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400045b4:	910003fd 	mov	x29, sp
    400045b8:	f9000bf3 	str	x19, [sp, #16]
    400045bc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400045c0:	d50342df 	msr	daifset, #0x2
		++_current->base.sched_locked;
    400045c4:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    400045c8:	f9431801 	ldr	x1, [x0, #1584]
MAKE_REG_HELPER(daif)
    400045cc:	92407e73 	and	x19, x19, #0xffffffff
    400045d0:	39406c20 	ldrb	w0, [x1, #27]
    400045d4:	11000400 	add	w0, w0, #0x1
    400045d8:	39006c20 	strb	w0, [x1, #27]
		update_cache(0);
    400045dc:	52800000 	mov	w0, #0x0                   	// #0
    400045e0:	97ffff20 	bl	40004260 <update_cache>
    400045e4:	d51b4233 	msr	daif, x19
}
    400045e8:	f9400bf3 	ldr	x19, [sp, #16]
    400045ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
    400045f0:	17ffff00 	b	400041f0 <z_reschedule_unlocked>

00000000400045f4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    400045f4:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    400045f8:	91188000 	add	x0, x0, #0x620
    400045fc:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004600:	91196021 	add	x1, x1, #0x658
	list->tail = (sys_dnode_t *)list;
    40004604:	a9038401 	stp	x1, x1, [x0, #56]
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    40004608:	52800001 	mov	w1, #0x0                   	// #0
    4000460c:	52800000 	mov	w0, #0x0                   	// #0
    40004610:	17fffebe 	b	40004108 <k_sched_time_slice_set>

0000000040004614 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    40004614:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    40004618:	f9431800 	ldr	x0, [x0, #1584]
    4000461c:	d65f03c0 	ret

0000000040004620 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    40004620:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004624:	910003fd 	mov	x29, sp
    40004628:	a90153f3 	stp	x19, x20, [sp, #16]
    4000462c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004630:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004634:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    40004638:	39406401 	ldrb	w1, [x0, #25]
    4000463c:	361800e1 	tbz	w1, #3, 40004658 <z_thread_abort+0x38>
MAKE_REG_HELPER(daif)
    40004640:	92407e94 	and	x20, x20, #0xffffffff
    40004644:	d51b4234 	msr	daif, x20
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    40004648:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000464c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004650:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004654:	d65f03c0 	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    40004658:	121a7822 	and	w2, w1, #0xffffffdf
    4000465c:	aa0003f3 	mov	x19, x0
    40004660:	321d0043 	orr	w3, w2, #0x8
		if (z_is_thread_queued(thread)) {
    40004664:	37380382 	tbnz	w2, #7, 400046d4 <z_thread_abort+0xb4>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    40004668:	39006403 	strb	w3, [x0, #25]
		if (thread->base.pended_on != NULL) {
    4000466c:	f9400a60 	ldr	x0, [x19, #16]
    40004670:	b4000060 	cbz	x0, 4000467c <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
    40004674:	aa1303e0 	mov	x0, x19
    40004678:	97fffe4d 	bl	40003fac <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    4000467c:	9102e276 	add	x22, x19, #0xb8
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    40004680:	9100a260 	add	x0, x19, #0x28
    40004684:	9400009d 	bl	400048f8 <z_abort_timeout>
	return list->head == list;
    40004688:	f9405e75 	ldr	x21, [x19, #184]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000468c:	eb1602bf 	cmp	x21, x22
    40004690:	54000040 	b.eq	40004698 <z_thread_abort+0x78>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    40004694:	b50002d5 	cbnz	x21, 400046ec <z_thread_abort+0xcc>
		update_cache(1);
    40004698:	52800020 	mov	w0, #0x1                   	// #1
    4000469c:	97fffef1 	bl	40004260 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    400046a0:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    400046a4:	f9431800 	ldr	x0, [x0, #1584]
    400046a8:	eb13001f 	cmp	x0, x19
    400046ac:	54fffca1 	b.ne	40004640 <z_thread_abort+0x20>  // b.any
MAKE_REG_HELPER(tpidrro_el0);
    400046b0:	d53bd060 	mrs	x0, tpidrro_el0
    400046b4:	927db000 	and	x0, x0, #0xfffffffffff8
    400046b8:	b9400000 	ldr	w0, [x0]
    400046bc:	35fffc20 	cbnz	w0, 40004640 <z_thread_abort+0x20>
		z_swap(&sched_spinlock, key);
    400046c0:	2a1403e1 	mov	w1, w20
    400046c4:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    400046c8:	911ab400 	add	x0, x0, #0x6ad
    400046cc:	97fffe70 	bl	4000408c <z_swap>
    400046d0:	17ffffdc 	b	40004640 <z_thread_abort+0x20>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    400046d4:	52800be2 	mov	w2, #0x5f                  	// #95
    400046d8:	0a020021 	and	w1, w1, w2
    400046dc:	321d0021 	orr	w1, w1, #0x8
    400046e0:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    400046e4:	97fffe2d 	bl	40003f98 <sys_dlist_remove>
}
    400046e8:	17ffffe1 	b	4000466c <z_thread_abort+0x4c>
		unpend_thread_no_timeout(thread);
    400046ec:	aa1503e0 	mov	x0, x21
    400046f0:	97fffe2f 	bl	40003fac <unpend_thread_no_timeout>
    400046f4:	9100a2a0 	add	x0, x21, #0x28
    400046f8:	94000080 	bl	400048f8 <z_abort_timeout>
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
    400046fc:	b900cebf 	str	wzr, [x21, #204]
		ready_thread(thread);
    40004700:	aa1503e0 	mov	x0, x21
    40004704:	97ffff4b 	bl	40004430 <ready_thread>
    40004708:	17ffffe0 	b	40004688 <z_thread_abort+0x68>

000000004000470c <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    4000470c:	17ffffc5 	b	40004620 <z_thread_abort>

0000000040004710 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    40004710:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    40004714:	b9469800 	ldr	w0, [x0, #1688]
    40004718:	35000040 	cbnz	w0, 40004720 <elapsed+0x10>
    4000471c:	17fffcf9 	b	40003b00 <sys_clock_elapsed>
}
    40004720:	52800000 	mov	w0, #0x0                   	// #0
    40004724:	d65f03c0 	ret

0000000040004728 <next_timeout>:

static int32_t next_timeout(void)
{
    40004728:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
    4000472c:	d00002a0 	adrp	x0, 4005a000 <z_interrupt_stacks+0x950>
    40004730:	911bc001 	add	x1, x0, #0x6f0
    40004734:	910003fd 	mov	x29, sp
    40004738:	f9000bf3 	str	x19, [sp, #16]
    4000473c:	f9437813 	ldr	x19, [x0, #1776]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40004740:	eb01027f 	cmp	x19, x1
    40004744:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    40004748:	97fffff2 	bl	40004710 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    4000474c:	b4000213 	cbz	x19, 4000478c <next_timeout+0x64>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40004750:	f9400e61 	ldr	x1, [x19, #24]
    40004754:	cb20c020 	sub	x0, x1, w0, sxtw
	int32_t ret = to == NULL ? MAX_WAIT
    40004758:	f100001f 	cmp	x0, #0x0
    4000475c:	540001cd 	b.le	40004794 <next_timeout+0x6c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40004760:	b2407be1 	mov	x1, #0x7fffffff            	// #2147483647
    40004764:	eb01001f 	cmp	x0, x1
	int32_t ret = to == NULL ? MAX_WAIT
    40004768:	9a81d000 	csel	x0, x0, x1, le

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    4000476c:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004770:	b9464021 	ldr	w1, [x1, #1600]
    40004774:	34000061 	cbz	w1, 40004780 <next_timeout+0x58>
    40004778:	6b01001f 	cmp	w0, w1
    4000477c:	1a81d000 	csel	w0, w0, w1, le
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    40004780:	f9400bf3 	ldr	x19, [sp, #16]
    40004784:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004788:	d65f03c0 	ret
	int32_t ret = to == NULL ? MAX_WAIT
    4000478c:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    40004790:	17fffff7 	b	4000476c <next_timeout+0x44>
    40004794:	52800000 	mov	w0, #0x0                   	// #0
    40004798:	17fffff5 	b	4000476c <next_timeout+0x44>

000000004000479c <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    4000479c:	f9400001 	ldr	x1, [x0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    400047a0:	b4000140 	cbz	x0, 400047c8 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
    400047a4:	d00002a2 	adrp	x2, 4005a000 <z_interrupt_stacks+0x950>
    400047a8:	f9437c42 	ldr	x2, [x2, #1784]
    400047ac:	eb02001f 	cmp	x0, x2
    400047b0:	540000c0 	b.eq	400047c8 <remove_timeout+0x2c>  // b.none
	if (next(t) != NULL) {
    400047b4:	b40000a1 	cbz	x1, 400047c8 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
    400047b8:	f9400c03 	ldr	x3, [x0, #24]
    400047bc:	f9400c22 	ldr	x2, [x1, #24]
    400047c0:	8b030042 	add	x2, x2, x3
    400047c4:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
    400047c8:	f9400402 	ldr	x2, [x0, #8]
	prev->next = next;
    400047cc:	f9000041 	str	x1, [x2]
	next->prev = prev;
    400047d0:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    400047d4:	a9007c1f 	stp	xzr, xzr, [x0]
}
    400047d8:	d65f03c0 	ret

00000000400047dc <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    400047dc:	b100045f 	cmn	x2, #0x1
    400047e0:	540008a0 	b.eq	400048f4 <z_add_timeout+0x118>  // b.none
{
    400047e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400047e8:	910003fd 	mov	x29, sp
    400047ec:	a90153f3 	stp	x19, x20, [sp, #16]
    400047f0:	aa0003f3 	mov	x19, x0
    400047f4:	aa0203f4 	mov	x20, x2
    400047f8:	f90013f5 	str	x21, [sp, #32]
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    400047fc:	f9000801 	str	x1, [x0, #16]
MAKE_REG_HELPER(daif)
    40004800:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004804:	d50342df 	msr	daifset, #0x2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    40004808:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    4000480c:	eb02001f 	cmp	x0, x2
    40004810:	54000244 	b.mi	40004858 <z_add_timeout+0x7c>  // b.first
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    40004814:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004818:	f9433822 	ldr	x2, [x1, #1648]
    4000481c:	cb020000 	sub	x0, x0, x2
    40004820:	cb140002 	sub	x2, x0, x20

			to->dticks = MAX(1, ticks);
    40004824:	f100005f 	cmp	x2, #0x0
    40004828:	9a9fc442 	csinc	x2, x2, xzr, gt
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    4000482c:	f9000e62 	str	x2, [x19, #24]
	return list->head == list;
    40004830:	d00002a2 	adrp	x2, 4005a000 <z_interrupt_stacks+0x950>
    40004834:	911bc041 	add	x1, x2, #0x6f0
    40004838:	f9437840 	ldr	x0, [x2, #1776]
	sys_dnode_t *const tail = list->tail;
    4000483c:	f9400425 	ldr	x5, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40004840:	eb01001f 	cmp	x0, x1
    40004844:	540001c1 	b.ne	4000487c <z_add_timeout+0xa0>  // b.any
	node->prev = tail;
    40004848:	a9001661 	stp	x1, x5, [x19]
	tail->next = node;
    4000484c:	f90000b3 	str	x19, [x5]
	list->tail = node;
    40004850:	f9000433 	str	x19, [x1, #8]
}
    40004854:	14000015 	b	400048a8 <z_add_timeout+0xcc>
    40004858:	97ffffae 	bl	40004710 <elapsed>
    4000485c:	91000682 	add	x2, x20, #0x1
    40004860:	8b20c042 	add	x2, x2, w0, sxtw
    40004864:	17fffff2 	b	4000482c <z_add_timeout+0x50>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    40004868:	cb040063 	sub	x3, x3, x4
    4000486c:	f9000e63 	str	x3, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
    40004870:	eb0000bf 	cmp	x5, x0
    40004874:	54fffea0 	b.eq	40004848 <z_add_timeout+0x6c>  // b.none
    40004878:	f9400000 	ldr	x0, [x0]
		for (t = first(); t != NULL; t = next(t)) {
    4000487c:	b4fffe60 	cbz	x0, 40004848 <z_add_timeout+0x6c>
			if (t->dticks > to->dticks) {
    40004880:	f9400c04 	ldr	x4, [x0, #24]
    40004884:	f9400e63 	ldr	x3, [x19, #24]
    40004888:	eb03009f 	cmp	x4, x3
    4000488c:	54fffeed 	b.le	40004868 <z_add_timeout+0x8c>
				t->dticks -= to->dticks;
    40004890:	cb030083 	sub	x3, x4, x3
    40004894:	f9000c03 	str	x3, [x0, #24]
	sys_dnode_t *const prev = successor->prev;
    40004898:	f9400403 	ldr	x3, [x0, #8]
	node->prev = prev;
    4000489c:	a9000e60 	stp	x0, x3, [x19]
	prev->next = node;
    400048a0:	f9000073 	str	x19, [x3]
	successor->prev = node;
    400048a4:	f9000413 	str	x19, [x0, #8]
	return list->head == list;
    400048a8:	f9437840 	ldr	x0, [x2, #1776]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    400048ac:	eb01001f 	cmp	x0, x1
    400048b0:	54000160 	b.eq	400048dc <z_add_timeout+0x100>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    400048b4:	eb00027f 	cmp	x19, x0
    400048b8:	54000121 	b.ne	400048dc <z_add_timeout+0x100>  // b.any
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    400048bc:	97ffff9b 	bl	40004728 <next_timeout>

			if (next_time == 0 ||
    400048c0:	340000a0 	cbz	w0, 400048d4 <z_add_timeout+0xf8>
			    _current_cpu->slice_ticks != next_time) {
    400048c4:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
			if (next_time == 0 ||
    400048c8:	b9464021 	ldr	w1, [x1, #1600]
    400048cc:	6b00003f 	cmp	w1, w0
    400048d0:	54000060 	b.eq	400048dc <z_add_timeout+0x100>  // b.none
				sys_clock_set_timeout(next_time, false);
    400048d4:	52800001 	mov	w1, #0x0                   	// #0
    400048d8:	97fffc64 	bl	40003a68 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    400048dc:	92407eb5 	and	x21, x21, #0xffffffff
    400048e0:	d51b4235 	msr	daif, x21
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    400048e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400048e8:	f94013f5 	ldr	x21, [sp, #32]
    400048ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400048f0:	d65f03c0 	ret
    400048f4:	d65f03c0 	ret

00000000400048f8 <z_abort_timeout>:
    400048f8:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400048fc:	d50342df 	msr	daifset, #0x2
int z_abort_timeout(struct _timeout *to)
{
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    40004900:	f9400001 	ldr	x1, [x0]
    40004904:	b4000121 	cbz	x1, 40004928 <z_abort_timeout+0x30>
{
    40004908:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(daif)
    4000490c:	92407c84 	and	x4, x4, #0xffffffff
    40004910:	910003fd 	mov	x29, sp
			remove_timeout(to);
    40004914:	97ffffa2 	bl	4000479c <remove_timeout>
			ret = 0;
    40004918:	52800000 	mov	w0, #0x0                   	// #0
    4000491c:	d51b4224 	msr	daif, x4
		}
	}

	return ret;
}
    40004920:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004924:	d65f03c0 	ret
	int ret = -EINVAL;
    40004928:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000492c:	92407c84 	and	x4, x4, #0xffffffff
    40004930:	d51b4224 	msr	daif, x4
}
    40004934:	d65f03c0 	ret

0000000040004938 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    40004938:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000493c:	910003fd 	mov	x29, sp
    40004940:	a90153f3 	stp	x19, x20, [sp, #16]
    40004944:	2a0003f3 	mov	w19, w0
    40004948:	f90013f5 	str	x21, [sp, #32]
    4000494c:	12001c35 	and	w21, w1, #0xff
    40004950:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004954:	d50342df 	msr	daifset, #0x2
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    40004958:	97ffff74 	bl	40004728 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    4000495c:	6b13001f 	cmp	w0, w19
    40004960:	3a41b804 	ccmn	w0, #0x1, #0x4, lt  // lt = tstop
    40004964:	7a410804 	ccmp	w0, #0x1, #0x4, eq  // eq = none
    40004968:	540000ad 	b.le	4000497c <z_set_timeout_expiry+0x44>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    4000496c:	6b13001f 	cmp	w0, w19
    40004970:	2a1503e1 	mov	w1, w21
    40004974:	1a93d000 	csel	w0, w0, w19, le
    40004978:	97fffc3c 	bl	40003a68 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    4000497c:	92407e94 	and	x20, x20, #0xffffffff
    40004980:	d51b4234 	msr	daif, x20
		}
	}
}
    40004984:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004988:	f94013f5 	ldr	x21, [sp, #32]
    4000498c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004990:	d65f03c0 	ret

0000000040004994 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    40004994:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40004998:	910003fd 	mov	x29, sp
    4000499c:	a90153f3 	stp	x19, x20, [sp, #16]
    400049a0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400049a4:	2a0003f5 	mov	w21, w0
    400049a8:	a90363f7 	stp	x23, x24, [sp, #48]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    400049ac:	97fffe77 	bl	40004388 <z_time_slice>
    400049b0:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400049b4:	d50342df 	msr	daifset, #0x2
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    400049b8:	f0000054 	adrp	x20, 4000f000 <z_idle_threads>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    400049bc:	f0000056 	adrp	x22, 4000f000 <z_idle_threads>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400049c0:	911a6297 	add	x23, x20, #0x698
    400049c4:	aa1603f8 	mov	x24, x22
	announce_remaining = ticks;
    400049c8:	b9069a95 	str	w21, [x20, #1688]
	return list->head == list;
    400049cc:	d00002b5 	adrp	x21, 4005a000 <z_interrupt_stacks+0x950>
    400049d0:	911bc2b5 	add	x21, x21, #0x6f0
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400049d4:	b94002e4 	ldr	w4, [x23]
	return key;
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	write_daif(key);
    400049d8:	2a1303f3 	mov	w19, w19
    400049dc:	f94002a0 	ldr	x0, [x21]
		curr_tick += dt;
    400049e0:	f9433ac3 	ldr	x3, [x22, #1648]
    400049e4:	93407c82 	sxtw	x2, w4
	return sys_dlist_is_empty(list) ? NULL : list->head;
    400049e8:	eb15001f 	cmp	x0, x21
    400049ec:	540000e0 	b.eq	40004a08 <sys_clock_announce+0x74>  // b.none
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400049f0:	b40000c0 	cbz	x0, 40004a08 <sys_clock_announce+0x74>
    400049f4:	f9400c01 	ldr	x1, [x0, #24]
    400049f8:	eb02003f 	cmp	x1, x2
    400049fc:	540001ed 	b.le	40004a38 <sys_clock_announce+0xa4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    40004a00:	cb020021 	sub	x1, x1, x2
    40004a04:	f9000c01 	str	x1, [x0, #24]
	}

	curr_tick += announce_remaining;
    40004a08:	8b030042 	add	x2, x2, x3
	announce_remaining = 0;
    40004a0c:	b9069a9f 	str	wzr, [x20, #1688]
	curr_tick += announce_remaining;
    40004a10:	f9033b02 	str	x2, [x24, #1648]

	sys_clock_set_timeout(next_timeout(), false);
    40004a14:	97ffff45 	bl	40004728 <next_timeout>
    40004a18:	52800001 	mov	w1, #0x0                   	// #0
    40004a1c:	97fffc13 	bl	40003a68 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    40004a20:	d51b4233 	msr	daif, x19

	k_spin_unlock(&timeout_lock, key);
}
    40004a24:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004a28:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004a2c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004a30:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40004a34:	d65f03c0 	ret
		curr_tick += dt;
    40004a38:	8b21c062 	add	x2, x3, w1, sxtw
		announce_remaining -= dt;
    40004a3c:	4b010081 	sub	w1, w4, w1
		t->dticks = 0;
    40004a40:	f9000c1f 	str	xzr, [x0, #24]
		curr_tick += dt;
    40004a44:	f9033ac2 	str	x2, [x22, #1648]
		announce_remaining -= dt;
    40004a48:	b90002e1 	str	w1, [x23]
		remove_timeout(t);
    40004a4c:	97ffff54 	bl	4000479c <remove_timeout>
    40004a50:	d51b4233 	msr	daif, x19
		t->fn(t);
    40004a54:	f9400801 	ldr	x1, [x0, #16]
    40004a58:	d63f0020 	blr	x1
    40004a5c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004a60:	d50342df 	msr	daifset, #0x2
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    40004a64:	17ffffdc 	b	400049d4 <sys_clock_announce+0x40>

0000000040004a68 <free_page_frame_list_put>:
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    40004a68:	f0000043 	adrp	x3, 4000f000 <z_idle_threads>
    40004a6c:	9119e061 	add	x1, x3, #0x678
    40004a70:	f9400422 	ldr	x2, [x1, #8]
	parent->next = child;
    40004a74:	f900001f 	str	xzr, [x0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    40004a78:	b5000102 	cbnz	x2, 40004a98 <free_page_frame_list_put+0x30>
	list->head = node;
    40004a7c:	f9033c60 	str	x0, [x3, #1656]
	list->tail = node;
    40004a80:	f9000420 	str	x0, [x1, #8]
static void free_page_frame_list_put(struct z_page_frame *pf)
{
	PF_ASSERT(pf, z_page_frame_is_available(pf),
		 "unavailable page put on free list");
	sys_slist_append(&free_page_frame_list, &pf->node);
	z_free_page_count++;
    40004a84:	f0000041 	adrp	x1, 4000f000 <z_idle_threads>
    40004a88:	f9434420 	ldr	x0, [x1, #1672]
    40004a8c:	91000400 	add	x0, x0, #0x1
    40004a90:	f9034420 	str	x0, [x1, #1672]
}
    40004a94:	d65f03c0 	ret
	parent->next = child;
    40004a98:	f9000040 	str	x0, [x2]
	list->tail = node;
    40004a9c:	f9000420 	str	x0, [x1, #8]
}
    40004aa0:	17fffff9 	b	40004a84 <free_page_frame_list_put+0x1c>

0000000040004aa4 <z_mem_manage_init>:
MAKE_REG_HELPER(daif)
    40004aa4:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004aa8:	d50342df 	msr	daifset, #0x2
	list->head = NULL;
    40004aac:	f0000040 	adrp	x0, 4000f000 <z_idle_threads>
    40004ab0:	9119e001 	add	x1, x0, #0x678

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40004ab4:	f00002a2 	adrp	x2, 4005b000 <_end>
    40004ab8:	91000042 	add	x2, x2, #0x0
    40004abc:	f9033c1f 	str	xzr, [x0, #1656]
	list->tail = NULL;
    40004ac0:	f0000044 	adrp	x4, 4000f000 <z_idle_threads>
    40004ac4:	911ab484 	add	x4, x4, #0x6ad
    40004ac8:	90ffffe0 	adrp	x0, 40000000 <__text_region_start>
    40004acc:	91000000 	add	x0, x0, #0x0
static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
    40004ad0:	b26287e7 	mov	x7, #0xffffffffc0000000    	// #-1073741824
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
    40004ad4:	528000a8 	mov	w8, #0x5                   	// #5
    40004ad8:	f900043f 	str	xzr, [x1, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40004adc:	eb02001f 	cmp	x0, x2
    40004ae0:	54000183 	b.cc	40004b10 <z_mem_manage_init+0x6c>  // b.lo, b.ul, b.last
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40004ae4:	d2a80006 	mov	x6, #0x40000000            	// #1073741824
    40004ae8:	d2a90007 	mov	x7, #0x48000000            	// #1207959552
		if (z_page_frame_is_available(pf)) {
    40004aec:	39402080 	ldrb	w0, [x4, #8]
    40004af0:	340003c0 	cbz	w0, 40004b68 <z_mem_manage_init+0xc4>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40004af4:	914004c6 	add	x6, x6, #0x1, lsl #12
    40004af8:	91002484 	add	x4, x4, #0x9
    40004afc:	eb0700df 	cmp	x6, x7
    40004b00:	54ffff61 	b.ne	40004aec <z_mem_manage_init+0x48>  // b.any
MAKE_REG_HELPER(daif)
    40004b04:	92407ca5 	and	x5, x5, #0xffffffff
    40004b08:	d51b4225 	msr	daif, x5
    40004b0c:	d65f03c0 	ret
    40004b10:	8b070001 	add	x1, x0, x7
    40004b14:	d34cfc21 	lsr	x1, x1, #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40004b18:	8b010c21 	add	x1, x1, x1, lsl #3
    40004b1c:	8b010086 	add	x6, x4, x1
	pf->addr = addr;
    40004b20:	f8216880 	str	x0, [x4, x1]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40004b24:	91400400 	add	x0, x0, #0x1, lsl #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40004b28:	394020c3 	ldrb	w3, [x6, #8]
		pf->flags |= Z_PAGE_FRAME_PINNED;
    40004b2c:	2a080061 	orr	w1, w3, w8
    40004b30:	390020c1 	strb	w1, [x6, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40004b34:	17ffffea 	b	40004adc <z_mem_manage_init+0x38>
		if (z_page_frame_is_available(pf)) {
    40004b38:	39402080 	ldrb	w0, [x4, #8]
    40004b3c:	35000060 	cbnz	w0, 40004b48 <z_mem_manage_init+0xa4>
			free_page_frame_list_put(pf);
    40004b40:	aa0403e0 	mov	x0, x4
    40004b44:	97ffffc9 	bl	40004a68 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40004b48:	914004c6 	add	x6, x6, #0x1, lsl #12
    40004b4c:	91002484 	add	x4, x4, #0x9
    40004b50:	eb0700df 	cmp	x6, x7
    40004b54:	54ffff21 	b.ne	40004b38 <z_mem_manage_init+0x94>  // b.any
    40004b58:	92407ca5 	and	x5, x5, #0xffffffff
    40004b5c:	d51b4225 	msr	daif, x5
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
    40004b60:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004b64:	d65f03c0 	ret
{
    40004b68:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40004b6c:	910003fd 	mov	x29, sp
    40004b70:	17fffff4 	b	40004b40 <z_mem_manage_init+0x9c>

0000000040004b74 <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
    40004b74:	d65f03c0 	ret

0000000040004b78 <boot_banner>:
#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
	       STRINGIFY(BUILD_VERSION), BOOT_DELAY_BANNER);
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
    40004b78:	d0000002 	adrp	x2, 40006000 <levels.0+0x10>
    40004b7c:	9102a442 	add	x2, x2, #0xa9
    40004b80:	d0000001 	adrp	x1, 40006000 <levels.0+0x10>
    40004b84:	9103d421 	add	x1, x1, #0xf5
    40004b88:	d0000000 	adrp	x0, 40006000 <levels.0+0x10>
    40004b8c:	9103f000 	add	x0, x0, #0xfc
    40004b90:	17fff188 	b	400011b0 <printk>
	...
